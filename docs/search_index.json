[
["index.html", "Biostatistika Kurso svetainė Pradžia", " Biostatistika Kurso svetainė Vilmantas Gėgžna Pradžia Medžiaga atnaujinta: 2019-02-18 Šios svetainės turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija, nebent šalia konkretaus elemento nenurodyta kitaip. Jei konkretus elementas (pvz., paveikslas) yra paimtas iš kito šaltinio (parašyta šalia elemento arba pateikta nuoroda), tada jam taikoma pradiniame šaltinyje apibrėžta licencija. "],
["apie.html", "Apie Apie šią svetainę Reikalavimai studentui", " Apie Apie šią svetainę Šioje svetainėje pateikiama pagalbinė medžiaga kurso „Biostatistika“ (2019) bei „Biometrija“ (2019) pratyboms. Šio kurso metu susipažinsime su statistinei duomenų analizei naudojamais įrankiais, tokiais kaip: Programa „R“; Patogesniam darbui su „R“ skirta aplinka (programa) „RStudio“: \\(R \\neq RStudio\\)! Ataskaitų rengimui skirtomis „R“ galimybėmis, pvz., „R Markdown“ dokumentais. Svetainės valdymas klavišais Šios svetainės valdymas klaviatūra: Norėdami paslėpti (ar vėl rodyti) turinį, paspauskite klavišą S. Naudodami rodykles ← ar →, galite pereiti į kitą temą. Norėdami atlikti paiešką visoje svetainėje, paspauskite klavišą F. Funkcija veikia ne visose naršyklėse. Pastabos Pastaba 1. Kiekvieno skyriaus gale yra vieta (DISQUS forumas), kurioje galite pateikti komentarą, patarimą, pastabą ar klausimą. Būkite mandagūs, tolerantiški, supratingi, laikykitės raštvedybos ir kitų universiteto studentams prideramų taisyklių. Pastaba 2. Svetainėje esanti mokomoji medžiaga yra orientuota į operacinės sistemos „Windows“ naudotojus. Kitų sistemų naudotojams kai kurios instrukcijos gali šiek tiek skirtis. Pastaba 3. Lokalė – kompiuteryje ir jo programinėje įrangoje naudojamų elementų, priklausančių nuo kalbos ir kultūros normų, visuma (šaltinis: ). Paprasčiau sakant – tai nuo kalbos ir vietovės priklausančios programų bei dokumentų savybės, pvz., mėnesių pavadinimai skirtingomis kalbomis. Detalesnį paaiškinimą galite rasti enciklopediniame kompiuterijos žodyne . Daugelis šioje svetainėje rodomų pavyzdžių pateikti darant prielaidą, kad programoje „R“ pasirinkta lietuviškoji lokalė, kurią nustatyti galite naudodami programos „R“ komandą: # „Windows“ naudotojams Sys.setlocale(locale = &quot;Lithuanian&quot;) # „Mac OS“ ir kai kurioms „Linux“ versijoms Sys.setlocale(locale = &quot;lt_LT.UTF-8&quot;) Sys.setlocale(locale = &quot;lt_LT.utf8&quot;) „Linux“ sistemų naudotojai visas įdiegtas lokales gali sužinoti parašę komandą system(&quot;locale -a&quot;). Įprastai lokalę reikia pakeisti kiekvieną kartą perkrovus programą „R“. Jei programoje „R“ nustatyta lokalė veikia neteisingai, įsitikinkite, kad jūsų kompiuterio operacinės sistemos lokalė taip pat lietuviška (kai kuriais atvejais, operacinės sistemos lokalė gali užgožti programoje „R“ nustatytąją). Dėžučių reikšmės Knygoje naudojamų spalvotų dėžučių reikšmės: Informacija. Užduotys. Rekomendacija arba pastaba. Pastaba. Įspėjimas ir vengtini dalykai. Reikalavimai studentui Įgūdžiai Anglų kalba (gebėjimas analizuoti literatūrą, audio ir video šaltinius). Darbo kompiuteriu įgūdžiai: elementaraus kompiuterinio raštingumo įgūdžiai; gebėjimas internete susirasti reikiamą informaciją: „Google Search“, „YouTube“, t.t.; gebėjimas pagal instrukcijas parsisiųsti ir įsidiegti reikiamas programas. Reikmenys pratyboms Nuosavos ausinės pratybų metu (privaloma). Kompiuteris su „Windows“, „Linux“ arba „Mac OS“ operacine sistema. Arba prieiga prie tokio kompiuterio namų darbams atlikti. Reikmenys paskaitoms (Rekomenduojama) Išmanusis įrenginys (telefonas, planšetė, …) arba kompiuteris: turintis prieigą prie interneto, pvz.,galintis prisijungti prie tinklalapių quizizz.com/join ir kahoot.it ; kurio baterija įkrauta pakankamai arba turėti krovimo laidą. "],
["diegimas.html", "1. Programų diegimas ir nustatymai 1.1 Apie programą R 1.2 Pastabos prieš diegiant 1.3 Pagrindinės programos 1.4 R paketų diegimas 1.5 Programų konfigūravimas 1.6 Papildomos instrukcijos 1.7 Paskyros Klausimai ir komentarai", " 1. Programų diegimas ir nustatymai 1.1 Apie programą R „R“ – tai duomenų analizei skirta kompiuterinė programa (pav. 1.1), turinti ir interaktyvios duomenų analizės, ir programavimo galimybes. Pagal savo paskirtį „R“ orientuota į (statistinę) duomenų analizę ir duomenų vaizdinimą. Tačiau programos funkcionalumą smarkiai išplečia daugybė (virš 14000!) papildinių, dar vadinamų paketais, kurie leidžia spręsti įvairioms mokslo šakoms aktualius skaičiavimo, duomenų pertvarkymo, parengimo analizei bei vaizdinimo uždavinius, kurti automatizuotas ataskaitas ir pateikti jas įvairiomis formomis, pvz., internetinio tinklalapio ar „Microsoft Word“ formatu, rašyti mokslinius straipsnius, net knygas! Ši mokomoji medžiaga taip pat sukurta naudojantis „R“. Pav. 1.1: Programos „R“ logotipas . Programa „R“ – GNU projekto dalis, yra visiškai nemokama ir laisvai platinama. Jos vystymu rūpinasi „R“ fondas (The R Foundation). Daugiau informacijos apie programą rasite svetainėje www.r-project.org. Jei programos ir jai skirtų papildinių dar neturite, toliau bus rašoma, kaip juos parsisiųsti ir įsidiegti į savo kompiuterį. Įspėjimas: programa „R“ nėra pakaitalas jūsų smegenų darbui. Tikslas – atsisiųsti, įsidiegti ir susikonfigūruoti programas „R“, „RStudio“ ir bei svarbiausius „R“ papildinius, vadinamus paketais. 1.2 Pastabos prieš diegiant Kelios bendrosios pastabos prieš diegiantis programas. Pastaba 1. Šiame skyriuje nurodytos programos yra visiškai nemokamos naudoti akademiniais tikslais. Pastaba 2. Ši svetainė (ir joje esančios instrukcijos) orientuota į operacinės sistemos „Windows“ vartotojus. Kitų sistemų vartotojams kai kurios instrukcijos gali skirtis. Pastaba 3. Diegiantis programas procesai vyks greičiau, jei bus įjungtas sparčiojo veikimo režimas (angl., high performance), išjungtas kompiuterio energijos taupymas bei įjungtas kompiuterio krovimo laidas (žr. skyriuje „Sparčiojo veikimo režimas“). Ši pastaba galios ir tada, kai programa „R“ atliksite skaičiavimus. Tad pratybų metu naudodami savo kompiuterį naudokite ir krovimo laidą. Pastaba 4. Aplanko, į kurį bus įdiegtos programos „R“, „RStudio“ bei jų papildiniai, pavadinimuose esančios raidės gali būti tik angliškos, t. y., nei vienoje pavadinimo dalyje negali būti nei lietuviškų, nei rusiškų, nei kiniškų ar kitokių neangliškų simbolių: BLOGAI: C:/ĄĄĄĄČĘ C:/žurnalas/programos/R C:/dokumentai/Žygimantas/R D:/biostatistiką/R TINKA: C:/AAAACE C:/zurnalas/programos/R C:/dokumentai/Zygimantas/R D:/biostatistika/R Įsidiegti pavyks, bet kils problemų dirbant. Tad pasirinkite tinkamą aplanko pavadinimą. Kita pastaba taikytina tik tada, jei paketus diegiate pakartotinai. Pastaba 5. Jei programos „R“ paketus diegti nusprendėte darbo metu, perkraukite programą „R“, kad neliktų užkrautų paketų, kurie trukdytų diegimui ar atnaujinimui. Rekomenduojama apskritai uždaryti „RStudio“ projektą, jei jį buvote atidarę. Pastaba 6. Jei diegiant paketus įvyko klaida, perskaitykite, ką programa „R“ parašė. Jei nesuprantate žinutės esmės ar nežinote sprendimo, naudokite „Copy-Paste-Google“ metodą (nukopijuokite klaidos žinutės esmę į „Google“ internetinės paieškos sistemą ir atsakymą raskite internete). Tai bene greičiausias būdas rasti sprendimą. 1.3 Pagrindinės programos Video medžiagoje 1.1 pateikti pavyzdžiai, kaip atsisiųsti, įsidiegti ir atsidaryti reikiamas programas. Epizodas buvo skirtas ankstesnių metų kursui, todėl rodoma, kaip įsidiegti šiek tiek senesnes programų versijas. Tačiau esmė liko ta pati. Epizodo pabaigoje (po 9:58 min.) esanti informacija jau nebeaktuali. Nuorodos į reikiamus tinklalapius pateiktos kituose skyriuose. Jei kyla neaiškumų, naudingos nuorodos pateiktos skyriuje 1.6. Video medžiagą žiūrėdami pagreitintai – bent ×1,5 greičiu – taupysite laiką. Rekomenduojamas peržiūros greitis – ×2. Video epizodas 1.1 Video instrukcijos: „R“, „RStudio“, „Pandoc“ atsisiuntimas ir diegimas. Programos „Pandoc“ kol kas diegtis nereikia, nes ji yra „RStudio“ dalis. Be to, naujausioje „Pandoc“ versijoje (v2.5) yra strigtis, trukdanti sklandžiai dirbti. 1.3.1 Programa R Pirmiausia parsisiųsite programą „R“. Be jos negalėsite atlikti analizės. Programą rasite svetainėje https://cloud.r-project.org/ Pav. 1.2: Programos „R“ parsisiuntimas. Nueikite į svetainę https://cloud.r-project.org/. Atsidarys langas, kurio fragmentą matote A dalyje. Pasirinktie nuorodą pagal savo kompiuterio operacinę sistemą („Linux“, „Mac“ ar „Windows“). Naujai atsidariusiame lange (B) rinkitės „base“ (bazinis „R“ paketas). Kitame lange (C) bus rodoma naujausia „R“ versija (tarkim, 3.5.2). Spauskite „Download“ ir pradėkite siųstis programą. Pastaba: dabartinė programos versija yra naujesnė nei 3.4.1. Diegdami „R“ atkreipkite dėmesį į du dalykus: Pasirinkite aplanką, kurio pavadinime esančios raidės yra tik angliškos, t. y., nėra nei lietuviškų, nei rusiškų, nei kiniškų simbolių. Į aplanką, kurio pavadinime yra ne angliškų raidžių, programas įdiegti pavyks, bet vėliau dirbant kils problemų ir net neatrodys, kad jos kyla dėl aplanke esančių raidžių. Pasirinkite jūsų kompiuteriui tinkamas programos 32 ar 64 bitų bylų versijas, kaip pavaizduota paveiksle 1.3. Pav. 1.3: Programos „R“ diegimas. Programos branduolio („Core“) bylas įdiegti būtina. Taupantiems vietą kietajame diske: pasirinkite įsidiegti arba vien tik 64 bitų (A), arba 32 bitų (B) versiją, kuri labiau tinkama jūsų kompiuteriui. Jei jūsų kompiuteris naujesnis nei 3 metų senumo, rinkitės 64 bitų versiją. Jei dvejojate, kurią rinktis, rinkitės abi. Užduotis 1.1 Atsisiųskite ir įsidiekite programą „R“. 1.3.2 Programa RStudio Programa „RStudio“ yra darbui su „R“ skirta aplinka (angl. integrated development environment, IDE), skirta programai „R“. Trumpai tariant, tai kita programa, kuri palengvina darbą su „R“. Yra 2 „RStudio“ tipai: Desktop (skirtas asmeniniam kompiuteriui) ir Server (skirtas serveriui). Mums reikalingas pirmasis. Parsisiųsti galime iš: https://www.rstudio.com/products/rstudio/download/ (pav. 1.4). Pav. 1.4: Programos RStudio parsisiuntimui skirto tinklalapio fragmentas. Tinklalapio apačioje yra skiltis „RStudio Desktop“, kurioje išvardintos asmeniniam kompiuteriui skirtos versijos: pasirinkite tą, kuri pritaikyta jūsų kompiuterio operacinei sistemai („Linux“, „Mac“ ar „Windows“). Pastaba: dabartinė programos versija yra naujesnė nei 1.1.419. Užduotis 1.2 Atsisiųskite ir įsidiekite naujausią programos „RStudio“ versiją. 1.3.3 Mac naudotojams Sistemos Mac naudotojams papildomai reikia atsisiųsti ir įsidiegti programą XQuartz, nes be jos neveiks papildinys R Commander. Daugiau instrukcijų galite rasti šiame tinklalapyje: nuoroda . Įsidiegę šią programą perkraukite kompiuterį ir tik tada tęskite darbą. 1.4 R paketų diegimas Paketas, tai standartizuotas „R“ papildinys, praplečiantis programos galimybes. Apie šiuos papildinius plačiau bus rašoma skyriuje „5 R paketai“. Dabar išmoksite atsisiųsti labiausiai reikalingus. Atsidarykite programą „RStudio“ ir į langą, pavadintą „Console“, nukopijuokite iš karto visas žemiau parašytas „R“ paketų diegimo komandas ir paspauskite Enter klavišą. Bus įdiegti nurodyti „R“ paketai. Įprasta, jei parsisiuntimo ir diegimo procesas užtruks iki 20-40 minučių ir prireiks apie 1 GB vietos kietajame diske. Jei interneto ryšys arba kompiuterio veikimas yra lėti, diegimas gali užtrukti ilgiau. Paketų diegimą tęskite iki galo, neišjunkite programos viduryje nebaigto proceso. Pavyzdys, kaip įdiegiamas paketas devtools, pateiktas pav. 1.5. Pav. 1.5: R paketo devtools diegimas programiškai. Lange „Console“ \\((A)\\) parašomas/įklijuojamas programos kodas \\((B)\\) ir paspaudžiamas klavišas Enter. Atsiranda „STOP“ ženkliukas \\((C)\\), užrašai, rodantys, kad paketai parsiunčiami ir diegiami \\((D)\\) bei atsisiuntimo progreso juosta, kuri iššoka daugybę kartų (čia neparodyta). Sėkmingai įsidiegus paketui, atsiranda apie tai pranešantys užrašai \\((E)\\), išnyksta „STOP“ ikona bei atsiranda „&gt;“ ženkliukas \\((F)\\), rodantis, kad „R“ laukia naujos komandos. Jei paketas nebūtų įdiegtas sėkmingai, „R“ taip pat parašytų priežastį. Jei dega „STOP“ ženkliukas, bet atrodo, kad diegimas nevyksta, įsitikinkite, kad nėra lentelės, pavaizduotos pav. 1.6 (ši lentelė gali būti „pasislėpusi“ už kitų langų) bei kad programa nelaukia jūsų sprendimo (pav. 1.7). Pav. 1.6: „R“ siūlo paketus įdiegti į asmeninę biblioteką. Pamatę analogišką lentelę, įsitikinkite, kad aplanko pavadinime nėra neangliškų (pvz., lietuviškų) raidžių ir spauskite „Yes“. Pav. 1.7: R klausia, ar įdiegti paketus, kuriuos reikia kompiliuoti (atlikti procedūrą, kurios pagalba paketai pritaikomi veikti jūsų kompiuteryje). Jei pasirodys analogiškas klausimas, įrašykite raidę „y“ ir paspauskite „Enter“. Naudojant naujausią „R“ versiją, vietoje 1.7 pav. vaizduojamų komandų iššoks lentelė panaši į pavaizduotąją pav. 1.6. Paketus diegiantis pirmą kartą tokio tipo lentelė įprastai iššoka 2 kartus. Kodas reikiamiems paketams diegti (visas kita spalva pažymėtas blokas): # R paketų diegimo komandos # Paketų diegimas iš saugyklos CRAN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ # Paketų parsisiuntimui install.packages(c(&quot;remotes&quot;, &quot;devtools&quot;, &quot;ctv&quot;)) # Rekomenduojami R paketai list_of_packages &lt;- c( # Vizualizavimui/Grafikams &quot;ggplot2&quot;, &quot;ggpubr&quot;, &quot;ggrepel&quot;, &quot;ggthemes&quot;, &quot;plotly&quot;, &quot;cowplot&quot;, &quot;qqplotr&quot;, # Kiti &quot;data.table&quot;, &quot;BBmisc&quot;, &quot;checkmate&quot;, &quot;infer&quot;, &quot;aplpack&quot;, &quot;arm&quot;, &quot;coda&quot;, &quot;leaps&quot;, &quot;lmtest&quot;, &quot;matrixcalc&quot;, &quot;sem&quot;, &quot;TH.data&quot;, &quot;rgl&quot;, &quot;mi&quot;, &quot;multcomp&quot;, &quot;mvtnorm&quot;, &quot;car&quot;, &quot;carData&quot;, &quot;RCurl&quot;, &quot;openxlsx&quot;, &quot;tidyselect&quot;, &quot;readxl&quot;, &quot;forcats&quot;, &quot;dplyr&quot;, &quot;stringi&quot;, &quot;stringr&quot;, &quot;tidyr&quot;, &quot;broom&quot;, &quot;tidyverse&quot;, &quot;skimr&quot;, &quot;rcompanion&quot;, &quot;sigr&quot;, &quot;fs&quot;, &quot;DescTools&quot;, &quot;shiny&quot;, &quot;PMCMR&quot;, &quot;PMCMRplus&quot;, &quot;officer&quot;, &quot;flextable&quot;, &quot;pander&quot;, &quot;descriptr&quot;, &quot;vcd&quot;, &quot;vcdExtra&quot;, &quot;fitdistrplus&quot;, &quot;Rcmdr&quot;, &quot;RcmdrMisc&quot;, &quot;RcmdrPlugin.EZR&quot;, &quot;RcmdrPlugin.KMggplot2&quot; ) # Rekomenduojamų paketų diegimas install.packages(list_of_packages, dependencies = c(&quot;Depends&quot;, &quot;Imports&quot;)) # Paketų diegimas pagal temas ctv::update.views(c(&quot;ReproducibleResearch&quot;, &quot;Graphics&quot;)) # Paketų diegimas iš GitHub saugyklų ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ remotes::install_github(&quot;GegznaV/RcmdrPlugin.EZR@unmodified_Rcmdr_menu&quot;, upgrade = FALSE) remotes::install_github(&quot;GegznaV/addin.tools&quot;, upgrade = FALSE) remotes::install_github(&quot;GegznaV/addins.rmd&quot;, upgrade = FALSE) remotes::install_github(&quot;GegznaV/addins.rs&quot;, upgrade = FALSE) remotes::install_github(&quot;Rapporter/pander&quot;, upgrade = FALSE) remotes::install_github(&#39;stefano-meschiari/latex2exp&#39;, upgrade = FALSE) remotes::install_github(&quot;ropenscilabs/skimr&quot;, ref = &quot;v2&quot;, upgrade = FALSE) # Pranešimas baigus diegti ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ message(&quot;Atlikta!&quot;) Paketus rvg ir ggstatsplot bandykite diegti po vieną. „Linux“ ir „Mac“ naudotojams gali reikti papildomų programų ar leidimų. Gali padėti informacija, esanti šiuose tinklalapiuose: https://indrajeetpatil.github.io/ggstatsplot/ https://github.com/davidgohel/rvg install.packages(&quot;rvg&quot;) install.packages(&quot;ggstatsplot&quot;) Jei kils neaiškumų ar nesklandumų peržiūrėkite skyriuose 1.4.1 ir 1.6 pateiktą informaciją. Taip pat padarykite ekrano nuotraukas (angl. print screen), nukopijuokite kitą svarbią informaciją, kurią galėtumėte pratybų metu parodyti dėstytojui. Užduotis 1.3 Įsidiekite nurodytus programos „R“ paketus. Jei kils problemų, skaitykite skyrių žemiau. 1.4.1 Kilus problemų dėl paketų diegimo… Jei jums neleidžiama diegti „R“ paketų dėl to, kad „R“ rekomenduojamos bibliotekos (aplanko) pavadinime yra lietuviškų raidžių, gali padėti pav. 1.8 esanti informacija, kaip nurodyti kitą aplanką diegimui. ATSARGIAI: tai pažengusiųjų lygio modifikacijos sistemai „Windows“. Atidarytuose languose nieko papildomai nekeiskite ir neištrinkite, nebent suprantate, ką darote. Pav. 1.8: Numatytojo aplanko „R“ paketams (bibliotekos) keitimas. Jums paieškos lange reikia rasti ir atsidaryti „Advanced system settings“ kortelę. joje pasirinkti „Environment variables“ (aplinkos kintamieji). Aplinkos kintamųjų kortelėje pasirinkti naują vartotojo aplinkos kintamąjį. Naudotojo naujo aplinkos kintamojo kortelėje („New user variable“) esančiame laukelyje „Variable name“ \\((A)\\) reikia įrašyti „R_LIBS_USER“, o laukelyje „Variable value“ \\((B)\\) – aplanko, į kurį turi būti diegiami paketai, pavadinimą. Pavadinimą galima įrašyti, įkopijuoti arba susirasti naudojant „Browse Directory“ (naršyti aplankuose) mygtuką. Tai – pažengusiųjų lygio modifikacijos, tad būkite atidūs ir keiskite tik tai, ką keisti būtina. Išsaugoję nustatymus, kompiuterį perkraukite. PASTABA. Pakeitus šiuos nustatymus būtina perkrauti (angl. restart) kompiuterį ir tik tada tikrinti, ar jie išsprendė problemą. 1.5 Programų konfigūravimas 1.5.1 Sparčiojo veikimo režimas Dirbant duomenų analizės programomis kai kurie veiksmai reikalauja didelių skaičiuojamųjų kompiuterio resursų. Jei įjungtas energijos taupymo režimas, skaičiavimai užtruks ilgiau nei reikėtų. Todėl atliekant analizę siūlau: Įsijungti sparčiojo veikimo (angl. high-performance) režimą ir išjungti energijos taupymą. Taip skaičiavimai, paveikslų braižymas, didelių duomenų lentelių išsaugojimas bei panašūs veiksmai bus atlikti greičiau. Visgi žinokit, kad šiuo režimu kompiuteris vartoja daugiau energijos, ir dirbant „iš baterijos“ – greičiau išsikraus. Dirbti prisijungus kompiuterio krovimo laidą. Galima nustatyti, kad prisijungus laidą automatiškai būtų aktyvuojamas sparčiojo veikimo režimas. Windows 10 Pavyzdys, kaip operacinėje sistemoje „Windows 10“ pasirinkti sparčiojo veikimo režimą (planą), pateiktas pav. 1.9 bei šioje video medžiagoje: . Pav. 1.9: Pavyzdys, kaip sistemoje „Windows 10“ įsijungti sparčiojo veikimo režimą. Susiraskite baterijos ikoną darbalaukio meniu juostoje (1) ir paspauskite ją dešiniuoju pelės klavišu (2). Atsidariusiame meniu pasirinkite „Power Options“ arba atitikmenį kita kalba (3). Atsidarys langas, kuriame susiraskite ir pasirinkite sparčiojo veikimo režimą (planą), pvz., (A). Mano kompiuteryje yra 2 šio tipo planai (A, B). Jei rodomi ne visi – spauskite (C). Jei nėra reikiamo plano, jį susikurkite. Video pavyzdys: . 1.5.2 RStudio: UTF-8 koduotė dokumentams Parsisiuntę programą „R Studio“, ją susikonfigūruokite. Vienintelis privalomas nustatymas yra UTF-8 koduotės pasirinkimas dokumentams. (Jei nenustatysite UTF-8, dokumentuose negalėsite matyti lietuviškų, rusiškų ar kitokių anglų kalboje nenaudojamų simbolių.) Visi kiti nustatymai – tik rekomenduojami dėl patogumo. Detalios instrukcijos video medžiagoje, santrauka – paveiksle žemiau. Tam, kad išvengtume kai kurių problemų, susijusių su lietuvių kalbos atpažinimu, parinktį RStudio → Tools → Global Options → Code → Saving → Default text encoding nustatykite į UTF-8. Pav. 1.10: Schema, demonstruojanti, kaip pasirinkti, kad bylos RStudio aplinkoje būtų nuskaitomos naudojant UTF-8 standartą. 1.5.3 RStudio: kiti nustatymai Visos kitos šiame skyriuje siūlomos parinktys yra rekomendacinio pobūdžio. Video epizode 1.2 rodoma, kaip sukonfigūruoti RStudio, kurios versija 1.0.x (x – versijos papildymo numeris). Todėl naudojant naujausią 1.1.x ar 1.2.x versiją, nustatymų išdėstymas ir ikonų paveikslai skiriasi, tačiau principai liko tie patys. Video medžiagą žiūrėdami pagreitintai – bent ×1,5 greičiu – taupysite laiką. Rekomenduojamas peržiūros greitis – ×2. Video epizodas 1.2 Programos „RStudio“ parengimas darbui (konfigūravimas). Pav. 1.11: Priedas prie video medžiagos: rekomenduojama programos „R Studio“ (versija 1.2) konfigūracija. Geltonai pažymėti nustatymai, kurie skiriasi nuo numatytųjų. (Dėkoju Stepan Avdevič už pagalbą rengiant iliustraciją.) Norintys daugiau paaiškinimų, ką reiškia konkretūs nustatymai, juos gali rasti straipsnyje „Customizing RStudio“ . Užduotis 1.4 „RStudio“ nustatykite UTF-8 koduotę atidaromoms byloms. Pagal rekomendacijas atlikite kitus „RStudio“ konfigūracijos veiksmus. 1.6 Papildomos instrukcijos Papildomų programų diegimo instrukcijų, kurios gali būti naudingos visų operacinių sistemų naudotojams, galite rasti: straipsnyje „Installing R and RStudio - Easy R Programming“ – bendrieji „R“ ir „RStudio“ diegimo klausimai „Windows“, „Linux“ ir „Mac“ sistemoms; tinklalapyje „R Commander Installation Notes“ – su papildinio „R Commander“ (paketas Rcmdr) diegimu susiję klausimai. 1.7 Paskyros 1.7.1 „Emokymai“ sistema Jūs vasario 4 d. automatiškai būsite prijungti prie kurso „Biostatistika ir biometrija“ VU „Emokymai“ sistemoje. Iš šios sistemos į VU studento el. pašto dėžutę bus siunčiami pranešimai, todėl dėžutę tikrinkite reguliariai. 1.7.2 „Data Camp“ paskyra Jums į VU studento el. pašto dėžutę bus atsiųstas pakvietimas nemokamai prisijungti prie mokomosios medžiagos „DataCamp“ sistemoje. Pakvietimą privalote priimti per 2 savaites nuo kurso pradžios. Jei laiško negausite per 1 savaitę nuo kurso pradžios, kreipkitės į teorinės dalies dėstytoją. 1.7.3 „GitHub“ paskyra Norint atlikti kai kurias papildomas užduotis, reikės paskyros svetainėje https://github.com. Pastaba: paskyra šioje svetainėje yra tarsi jūsų, kaip profesionalo, vizitinė kortelė. Žmonės, norintys parodyti savo programavimo ir duomenų analizės žinias, susikuria savo demonstracinių ar realių projektų portfelį. Užduotis 1.5 Susikurkite „GitHub“ paskyrą. Įsiminkite naudotojo vardą ir slaptažodį. Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["pradines-savokos.html", "2. Pradinės duomenų analizės sąvokos (teorija) 2.1 Statistinio tyrimo ciklas 2.2 Svarbiausia analizės dalis – klausimas 2.3 Generalinė aibė, imtis ir duomenys 2.4 Statistikos mokslas ir jo dalys 2.5 Kintamųjų tipai statistikoje 2.6 Duomenų saugojimo formos 2.7 Duomenų eilutės 2.8 Duomenų lentelės Klausimai ir komentarai", " 2. Pradinės duomenų analizės sąvokos (teorija) Šiame skyriuje susipažinsime su svarbiausiomis duomenų analizės sąvokomis. 2.1 Statistinio tyrimo ciklas Statistinio tyrimo eigą galime suskirstyti į 5 sąlygines dalis (pav. 2.1). Pav. 2.1: Statistinio tyrimo ciklas. Glaustas kiekvienos ciklo dalies apibūdinimas: Klausimas. Pirmiausia, iškeliame klausimą, susiformuluojame mokslinę problemą, kad žinotume, ką norime padaryti, į kokį klausimą atsakyti, kokią problemą išspręsti savo analize. (Žiūrėkite kitame poskyryje). Be klausimo nėra ir analizės tikslo. Planas. Kai jau žinome klausimą, galime susiplanuoti, kaip į jį atsakysime. Vėlesni tyrimo etapai negali atsverti ir ištaisyti prastai suplanuoto bei nekorektiškai atlikto tyrimo pasekmių. Duomenys. Surenkame duomenis, kurie yra tinkami atsakyti į išsikeltą klausimą. Duomenis parengiame analizei. Analizė. Padarome duomenų suvestines. Pagal klausimą ir duomenų savybes pasirenkame tinkamą tolimesnės analizės metodą. Atliekame šią analizę. Išvados. Grįsdami analizės rezultatais, padarome išvadas – atsakome į iškeltą klausimą. Įprastai gavus atsakymą į vieną klausimą, kyla dar keletas naujų klausimų. Tad toliau bandant atsakyti į naujuosius klausimus susidaro ciklas. Jei reikėtų pasirinkti, kas svarbiau atliekant tyrimą – analizės metodas, tinkami duomenys, tyrimo planas ar klausimas,– jūs turėtumėte aiškiai žinoti, kad pagal svarbą šie dalykai išsirikiuoja šitaip: klausimas (ir tikslas) → tyrimo planas → tinkami duomenys → analizės metodas. Jei neaišku kodėl – tada dar kartą perskaitykite kiekvienos statistinio tyrimo ciklo dalies apibūdinimą. 2.2 Svarbiausia analizės dalis – klausimas Prieš pradedant duomenų analizę, reikia aiškiai žinoti, kokiu tikslu ji yra daroma. Ir pagrindinis analizės tikslas – spręsti tam tikrą mokslinę, socialinę, verslo, medicininę, gamtinę ar kitokią realaus gyvenimo problemą bei atsakyti į tam tikrą specifinį klausimą, kuris buvo suformuluotas prieš atliekant analizę. Pvz., kuris šokoladas Lietuvos žmonėms labiau patinka (juodasis, pieniškas ar baltasis); kokią įtaką vienas papildomas euras, išleistas ledų reklamai, darytų įmonės pelnui; ar GMC studentai greičiau įsisavina kurso medžiagą, jei prie įprastos rašytinės medžiagos papildomai pateikiama video medžiaga; kurioje terpėje dumbliai greičiau auga; ar naujai kuriamas vaistas gali pailginti miego trukmę; ar pagal fenotipinius požymius galima atpažinti bakterijos genotipinius Gardnerella vaginalis pogrupius; ar kovų baidymas padeda reikšmingai sumažinti paukščių keliamą triukšmą Panevėžio mieste? Analizė, neturinti klausimo ir nesprendžianti problemos yra bevertė, nes neturi tikslo („analizė dėl analizės“). Tad tinkamas aiškiai ir konkrečiai suformuluotas klausimas – pati svarbiausia visos analizės dalis. Pav. 2.2: Klausimas – pati svarbiausia duomenų analizės dalis, nes suteikia analizei tikslą. Tinkamas aiškiai ir konkrečiai suformuluotas klausimas – pati svarbiausia tyrimo dalis. 2.3 Generalinė aibė, imtis ir duomenys Statistikoje yra keli svarbūs pradiniai terminai: generalinė aibė (populiacija), imtis bei duomenys (pav. 2.3). Pav. 2.3: Generalinė aibė, imtis ir duomenys. Iš visos tyrimo metu analizuojamos objektų visumos (generalinės aibės, GA) visiškai atsitiktinai arba kitu tikimybiniu būdu sudarome tiriamųjų imtį (paimame dalį GA). Tada išmatuojame ar užregistruojame vieną arba kelis mus dominančius tiriamųjų požymius ir taip gauname duomenis (duomenų imtį). Generalinė aibė (GA), arba populiacija (statistikos prasme),– tai statistinio tyrimo metu nagrinėjama objektų (arba jų savybių) visuma. Imtis – tai į tyrimą patekusi GA dalis (į tyrimą patekę objektai). Duomenys – tai imties objektų savybių reikšmės. Savybės gali būti kokybinės (pvz., spalva) bei kiekybinės (pvz., svoris). Imties dydis – tai imtyje esančių elementų (objektų, tiriamųjų, stebėjimų) skaičius. Pavyzdys. GA – tai visi 4-5 m. amžiaus naminiai šunys, imtis – tai į tyrimą patekę 4-5 m. amžiaus naminiai šunys, duomenys – į tyrimą patekusių šunų kailio spalva: šviesi, tamsi, marga, … Statistiniam tyrimui tinkama imtis privalo būti pakankamo dydžio ir reprezentatyvi. Reprezentatyvi imtis yra tokia, kurioje pakankamai tiksliai atsispindi visos GA savybės. Tai tarsi maža GA kopija. Imtis turi būti reprezentatyvi tai GA, apie kurią daromos statistinės išvados. Kitu atveju išvados bus klaidingos. T. y., jei imtyje yra tik vyresni nei 60 m. amžiaus vyrai, tai didelis klausimas, ar ištyrę juos galime daryti išvadas apie visus žmones, tarp kurių yra ir moterys, vaikai, kūdikiai bei jaunimas. Per mažo dydžio imtys yra nereprezentatyvios ir iš jų padarytos išvados, tikėtina, bus klaidingos. Vien tik didelis imties dydis irgi negarantuoja reprezentatyvumo, jei imtis sudaryta netinkamu būdu. Kelios pastabos: Atkreipkite dėmesį į tai, kad terminas „populiacija“ statistikoje reiškia ne tą patį, ką biologijoje, todėl, vengiant dviprasmybės, Lietuvių kalba yra aprobuotas kitas statistinis terminas („populiacijos“ sinonimas) – generalinė aibė (GA). Terminas „imtis“ gali reikšti ir tiriamųjų imtį (pvz., į tyrimą įtraukti 4-5 m. amžiaus naminiai šunys) ir duomenų imtį (pvz., tyrimo metu užregistruota kiekvieno iš šių šunų kailio spalva). 2.4 Statistikos mokslas ir jo dalys Statistikos mokslą galima apibūdinti kaip tikslųjį mokslą (matematikos šaką) apie tyrimo planavimą, duomenų rinkimą, sisteminimą, kiekybinę analizę bei rezultatų interpretavimą. Biostatistika ir biometrija yra taikomosios statistikos šakos, orientuotos į medicininių ir biologinių duomenų analizę. Statistikos metodus galima suskirstyti į 3-4 pagrindines dalis, tokias kaip: Tyrimo planavimas (angl. study/experimental design) – prieš vykdant tyrimą, visa eiga turi būti kruopščiai suplanuojama: suplanuojama tai, kaip bus sudaryta tiriamųjų imtis, kuri yra tinkama atsakyti į pagrindinį tyrimo klausimą, kokio dydžio ši imtis turėtų būti, kaip bus renkami duomenys, kokius metodus ar bent jau kokio tipo metodus naudosime analizei; Aprašomoji statistika (angl. descriptive statistics) – grafiniai ir skaitiniai duomenų sisteminimo metodai. Jais apibūdiname esmines surinktų duomenų savybes, o tai padeda pasirinkti tolimesnę analizės eigą; Statistinių išvadų darymas (angl. inferential statistics) bei prognozavimas (angl. prediction) – analizės ir interpretavimo metodai, pagal imties duomenis leidžiantys daryti išvadas apie visą GA ir/arba prognozuoti. Tyrimo eiga nuo imties sudarymo iki statistinių išvadų ir prognozavimo gali būti atvaizduojama paveikslu 2.4: tam, kad statistinės išvados būtų pagrįstos, imtis turi būti sudaryta tinkamai – būti pakankamo dydžio ir reprezentatyvi, t.y., pagal savo sudėtį ir savybes proporcinga visai generalinei aibei. Pav. 2.4: Sąsaja tarp imties sudarymo, aprašomosios statistikos bei statistinių išvadų darymo ir prognozavimo. „Statistikos uždavinys – aiškiai pasakyti tiesą: (pakankamai) tiksliai ir suprantamai.“ — Stephen McCurdy 2.5 Kintamųjų tipai statistikoje Statistikoje „kintamaisiais“ vadinamos tiriamųjų/objektų savybės. Duomenų analizės metodo pasirinkimas labai smarkiai priklausys nuo kintamojo prigimties. Pagal prigimtį statistiniai kintamieji skirstomi į 2 dideles grupes: kokybinius (kategorinius plačiąja prasme) ir kiekybinius. Šie, savo ruožtu, skaidomi į 4 pagrindinius tipus (pav. 2.5). Pav. 2.5: Pagrindiniai statistinių kintamųjų tipai. Kokybiniai (kategoriniai) kintamieji: nominalieji (angl. nominal variable) – tai tokie kintamieji, kurių reikšmių (vadinamos kategorijomis) išdėstymo tvarka nesvarbi, t. y., reikšmės natūralios eilės tvarkos neturi. Matavimo vienetų irgi neturi. Pvz., ląstelės spalva – violetinė, raudona, melsva, bespalvė, – ląstelės forma – apvali, kvadratinė, pailga, netaisyklinga. Kartais kategorijos užkoduojamos skaičiais, pvz., 0 – sveikas, 1 – serga, bet dėl to kintamasis netampa kiekybiniu. 0 ir 1 tai tik kategorijų kodai, kurių eilės tvarka nesvarbi. ranginiai (angl. ranked/ordered variable) – tai tokie kintamieji, kurių reikšmės (vadinamos kategorijomis) turi natūralią didėjimo ar mažėjimo tvarką, tačiau atstumas tarp gretimų reikšmių nėra pastovus ar tiksliai išmatuojamas. Įprastai matavimo vienetų neturi. Pvz., ląstelės dydžio kategorija – maža, vidutinė, didelė; savijauta – labai prasta, prasta, neutrali, gera, puiki. Ranginiams priklauso ir balais matuojami duomenys. Kiekybiniai kintamieji: kiekybiniai diskretieji (angl. discrete variable) – tai tokie skaitiniai kintamieji, kurie yra suskaičiuojami. Jie turi baigtinį (suskaičiuojamą) galimų reikšmių skaičių ir atstumas tarp dviejų galimų gretimų reikšmių yra pastovus ir gali būti tiksliai išmatuotas. Paprasčiau sakant, kiekybiniai diskretieji kintamieji išreiškiami teigiamais ir neigiamais sveikaisiais skaičiais bei nuliu. Įprastai aprašo kieno nors skaičių, pvz., ląstelių skaičių, dantų skaičių, kėdžių skaičių, į paskaitą atėjusių studentų skaičių, sėkmingų bandymų skaičių, raudonų mėgintuvėlių skaičių; tolydieji (angl. continuous variable) – tai skaitiniai kintamieji, kurie įprastai yra išmatuojami ar užregistruojami (bet ne suskaičiuojami). Gali įgyti ir trupmeniniais skaičiais užrašomas reikšmes (tarkim, 2,2354), teoriškai gali būti išmatuoti daugybės skaitmenų po kablelio tikslumu. Pasirinktame reikšmių intervale tarp dviejų skaičių (tarkim, tarp 2,2 ir 2,4) gali įgyti be galo daug reikšmių, nes skaičių po kablelio gali būti be galo daug. Įprastai turi konkrečius matavimo vienetus, nors gali būti išreikšti ir santykiniais vienetais ar būti bedimensiai dydžiai. Pvz., ląstelės svoris kilogramais, ilgis centimetrais, trukmė sekundėmis (kai skaičiuojamos ir sekundžių dalys), regėjimo aštrumas dioptrijomis, santykis tarp ilgio (metrais) ir pločio (metrais), šviesos intensyvumas santykiniais vienetais. Įprastai tokius skaičius suapvaliname iki tam tikro tikslumo tik dėl to, kad negalime išmatuoti be galo tiksliai arba praktiniam naudojimui užtenka ir mažesnio baigtinio tikslumo. Visgi teoriškai matuojamas kintamasis išlieka tolydusis. Kokius veiksmus galima atlikti su skirtingų tipų kintamųjų reikšmėmis? Nominaliąsias reikšmes galima tik suskaičiuoti: pasakyti, kiek kokių reikšmių yra. Ranginiais – galima suskaičiuoti, išdėstyti eilės tvarka ir palyginti, kuri didesnė/mažesnė. Su kiekybinių kintamųjų reikšmėmis – skaičiais – galima atlikti iš principo visus matematinius veiksmus (suskaičiuoti, palyginti, sudėti, atimti, padauginti, padalinti, apskaičiuoti vidurkį, …). Kokie kintamieji atrodo kaip skaitiniai (kiekybiniai), bet iš tiesų yra kategoriniai? Kategorijos, užkoduotos skaičiais, vis tiek yra kategorijos (tad joms skaičiuoti vidurkį nėra prasmės). Balais matuojami kintamieji iš tiesų yra ranginiai. Visgi, jei jie gali įgyti pakankamai daug reikšmių ir jų vidurkis turi prasmę (turbūt žinote, kas yra sesijos pažymių vidurkis), dažnai interpretuojami kaip skaitiniai. Visgi reikia prisiminti, kad pagal prigimtį – tai iš eilės išdėliotos kategorijos (rangai). Užduotis 2.1 Kuriam iš keturių tipų (nominalieji, ranginiai, diskretieji, tolydieji) priklauso šie duomenys: Šokolado svoris (g); Šokolado skonis (neskanus, skanus, labai skanus); Šokolado pakuotės spalva; Šokolado lydymosi temperatūra (°C); Šokolado plytelių skaičius; Šokolado porėtumas (porėtas/neporėtas); Šokolado rūšis (juodasis, baltasis, pieniškas, mėtinis); Šokolade esančių riešutų skaičius. 2.6 Duomenų saugojimo formos Atliekant tyrimą svarbus dalykas yra nuspręsti, kokia forma rinksime, organizuosime ir saugosime duomenis. Mūsų pasirinkimas priklauso nuo tyrimo srities, sprendžiamo uždavinio ir duomenų sudėtingumo. Šio kurso metu daugiausiai dirbsime su dviem formomis (duomenų struktūromis) – duomenų eilutėmis (duomenų sekomis) ir duomenų lentelėmis (duomenų sekomis, stulpeliais išdėliotomis į lentelės pavidalą) – tad siūlau skirti pakankamai daug laiko, kad tinkamai perprastumėte šias dvi struktūras. 2.7 Duomenų eilutės Duomenų eilutės – tai duomenų reikšmių seka. Joje įrašomos vienõs užregistruotos tiriamųjų savybės (tarkim, apklaustųjų ūgio) reikšmės. Duomenų eilutės pavyzdys – išmatuoti kurso kolegų ūgiai (centimetrais): 180, 168, 171, 173, 185, 179, 164. Duomenų eilutę taip pat galima pavadinti statistiniu kintamuoju, nes reikšmės nėra fiksuotos, bet kinta. (PASTABA: vėliau susipažinsime su kompiuteriniu terminu „kintamasis“, tad atskirkite, kad tai panašūs, bet skirtingi dalykai). Analizei svarbu atpažinti tokias duomenų eilutes: statistinė eilutė – duomenys surašyti eilės tvarka, pagal tai, kada buvo surinkti ir užregistruoti; variacinė eilutė – duomenys išrikiuoti didėjimo (arba nemažėjimo, jei yra vienodų reikšmių) tvarka. 2.8 Duomenų lentelės Duomenų lentelės – yra statistiniam tyrimui svarbiausia duomenų organizavimo forma. Ji yra standartizuota ir pritaikyta darbui statistinėmis programomis. Tvarkingos duomenų lentelės sudarymo principas: viena eilutė skirta vienam tiriamajam, vienas stulpelis – vienai savybei (kintamajam), o langeliuose – kiekvieno tiriamojo savybių reikšmės (žiūrėti pav. 2.6). Pav. 2.6: Duomenų lentelės struktūra. Atkreipkite dėmesį, kad stulpelių pavadinimai nurodo tiriamųjų savybes. Be to, įprastai lentelė turi pavadinimą, kuris turėtų būti prasmingas ir apibendrinti lentelėje surinktus duomenis. Duomenų lentelė gali būti gaunama vienos ar kelių duomenų eilučių reikšmes surašius kaip stulpelius. Tik svarbu, kad pirma kiekvienos duomenų eilutės reikšmė būtų iš pirmo tiriamojo, antra – iš antro ir t.t. T. y., kad eilės tvarka atitiktų teisingai. Visgi, vykdant tyrimą, duomenis rekomenduoju rinkti iš karto duomenų lentelės pavidalu, papildomai pasidarant duomenų lentelės aprašymą. Aprašymas reikalingas tam, kad jūsų kolegos, vadovas arba jūs pats/pati po 6 mėnesių tiksliai žinotumėte, kokie duomenys šioje lentelėje. Aprašyme bent trumpai apibūdinkite tyrimą, jo tikslą, nurodykite duomenų rinkimo metodus ir prietaisus, pateikite kintamųjų aprašymą, kuriame nurodyti matavimo vienetai. Rekomendacija: surinktus duomenis iš karto surašykite į duomenų lentelės pavidalą + būtinai pasidarykite duomenų lentelės kintamųjų aprašymą. Užduotis 2.2 Kas yra duomenų lentelė? Kas jos stulpeliuose ir kas - eilutėse? Išvardinkite 4 pagrindinius statistiniams skaičiavimams svarbius duomenų tipus ir nurodykite bent po 2-3 jiems būdingus požymius. Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["rstudio.html", "3. Programa RStudio 3.1 RStudio 3.2 RStudio langų išdėstymas 3.3 Komandų langas 3.4 Redaktoriaus langas 3.5 Paketų valdymo langas 3.6 Pagalbos langas 3.7 RStudio projektai Klausimai ir komentarai", " 3. Programa RStudio Šis skyrius skirtas susipažinti su programa „RStudio“. Jame nagrinėsime organizacinius ir pagalbinius duomenų analizės bei darbo programa „R“ aspektus. Išsamesnei pažinčiai su programos „R“ kodu bus skirtos kitos temos. Tikslas – įgyti darbo programa „RStudio“ pradmenis. Jūsų užduotys skaitant šį skyrių: Sužinoti ir mokėti paaiškinti, kas yra „RStudio“ ir kuo skiriasi nuo „R“; Išmokti atsidaryti programą „RStudio“; Sužinoti ir mokėti apibūdinti pagrindinių „RStudio“ langų paskirtį; Išmokti kompiuteriui pateikti komandas naudojantis „R“ komandų langu; Išmokti kompiuteriui pateikti komandas naudojantis „R“ redaktoriaus langu; Sužinoti, kas yra „R“ paketas ir naudojantis „RStudio“ išmokti parsisiųsti ir užsikrauti paketą; Išmokti informaciją apie „R“ komandą susirasti pagalbos ir dokumentacijos („Help“) lange; Išmokti susikurti „RStudio“ projektą. 3.1 RStudio Programa „RStudio“ (pav 3.1) yra patogesniam darbui su „R“ skirta aplinka (integruota kūrimo aplinka, angl. IDE – integrated development environment). Jei imtume automobilį kaip atitikmenį, tai jo variklis būtų „R“, o mašinos salonas – vairas, pedalai, spidometras, šviesų jungiklis, masažinės sėdynės ir borto kompiuteris – „RStudio“ (pav. 3.2). Pav. 3.1: „RStudio“ logotipas. Iliustracijos šaltinis: . „R“ – variklis „RStudio“ – patogiam valdymui skirtas salonas Pav. 3.2: Analogija tarp „R“, „RStudio“ bei automobilio. Iliustracijos šaltinis: Papildoma. Galite peržiūrėti šiuos du video epizodus (anglų kalba), kuriuose pristatoma programa „RStudio“: „RStudio“ tinklalapyje ir „DataCamp“ tinklalspyje . Užduotis 3.1 Atsidarykite programą „RStudio“. Jei programos ikonos nėra darbalaukyje, pasinaudokite savo operacinės sistemos programų paieškos sistema. 3.2 RStudio langų išdėstymas Standartinis programos „RStudio“ langų išdėstymas ir kiti elementai, į kuriuos rekomenduojama atkreipti dėmesį, pavaizduoti pav. 3.3. Pirmą kartą atsidarę programą galite matyti tik tris langų grupes, o ne keturias, kaip vaizduojama iliustracijoje. Pav. 3.3: Keturios pagrindinės programos „RStudio“ langų grupės (1-4), langų išdėstymą valdantis meniu (5A, 5B), pagrindinė programos meniu juosta viršuje (6) bei dabartinio projekto pavadinimas (7). Paveiksle vaizduojamas langų išdėstymas šioje svetainėje bus vadinamas standartiniu. 3.3 Komandų langas Svarbiausias pirmosios langų grupės (pav. 3.3) langas yra komandų langas (pultas, „konsolė“, angl. console). Tai pagrindinis bendravimo su programa langas: čia rašome komandas ir gauname skaitinius arba žodinius atsakymus iš programos „R“. Jei komandų lange dega „&gt;“ ženkliukas (angliškai vadinamas prompt), vadinasi, programa pasirengusi priimti jūsų komandas. Norėdami, kad jos būtų įvykdytos, įrašome programos kodą ir paspaudžiame Enter. Jei komandos vykdymas trunka ilgai, užsidega „Stop“ ženkliukas . Kai jis užgęsta – skaičiavimas baigtas. Jei norime nutraukti skaičiavimą anksčiau laiko, paspaudžiame šį ženkliuką. Jei norime išvalyti komandų langą, spaudžiame ikoną, kurioje vaizduojama šluota arba Ctrl+L. Jei lange vietoje &gt; dega +, vadinasi, nebaigta vesti komanda. Šiuo atveju yra 2 išeitys: arba įvesti komandą iki galo, arba spausti „Escape“ (Esc) klavišą, kol vėl atsiras &gt; (pav. 3.4). Pav. 3.4: Vienas iš galimų sprendimų, jei komandų lange vietoje &gt; dega +, yra kelis kartus paspausti Esc. Iliustracijos šaltinis: . Užduotis 3.2 Perskaitykite, kas parašyta komandų lange, kai vos tik paleidžiate programą. Kokia tai informacija? Išvalykite komandų langą. Naudodamiesi komandų langu įvykdykite komandą „trys minus dvidešimt“: 3 - 20. Rezultatas turėtų būti „[1] -17“. 3.4 Redaktoriaus langas Antrai langų grupei (pav. 3.3) priklauso redaktoriaus langas (angl. source code editor). Šiame lange atidaromi įvairūs tekstiniai dokumentai, kurie naudojami kaip užrašų knygutė programos kodui bei tekstui. Pvz., „R“ programos kodui skirtas „R Script“, o ataskaitoms ar kitokiems dokumentams rengti – „R Markdown“ formatai. Dokumentus galime išsaugoti paspaudę Ctrl+S (rekomenduoju šią kombinaciją spausti reguliariai). Jei programą atsidarote pirmą kartą, redaktoriaus lango galite ir nematyti. Tokiu atveju paspauskite Ctrl+Shift+N ir atsidarys „R“ programos kodui rašyti (ir išsaugoti) skirtas langas („R Script“). Taip pat galite naudoti pav. 3.5 pateiktas instrukcijas. Pav. 3.5: Žingsniai, kaip „RStudio“ redaktoriaus lange atsidaryti programos kodui skirtą „R Script“ dokumentą. Numeriais pažymėti punktai rodo vietas, kur reikia spausti pele. Norėdami įvykdyti redaktoriaus lange parašytas komandas, programos kodą pažymime pele ir spaudžiame mygtuką („Run“) arba klavišų kombinaciją Ctrl+Enter. Užduotis 3.3 Patikrinkite, ar matote visus keturis „RStudio“ langus, vaizduojamus pav. 3.3. Jei kurio nors trūksta, atsidarykite. Įsitikinkite, kad programoje „RStudio“ nustatyta UTF-8 koduotė. Jei nepamenate kaip, žiūrėkite skyriuje 1.5.2. Redaktoriaus lange padėkite grotelių simbolį # ir raštu glaustai apibūdinkite, kas yra „R“ ir kas yra „RStudio“? Kuo skiriasi? Kuri iš programų – svarbesnė (kuri be kurios kita neveiktų)? Redaktoriaus lange naujoje eilutėje (be grotelių) įrašykite 2 + 3, šią išraišką pažymėkite pele ir paspauskite Ctrl+Enter. Kuriame lange atsirado atsakymas „[1] 5“? 3.5 Paketų valdymo langas Apie šį langą plačiau kalbama skyriuje „5 R paketai“ bei poskyryje „5.2 RStudio langas Packages“. 3.6 Pagalbos langas Vienas iš centrinių „R“ kodo elementų yra funkcija (žr. skyriuje 4.2.1). Norint rasti kurios nors funkcijos aprašymą ar naudojimo pavyzdžių galime pasinaudoti pagalbos langu „Help“. Šį langą galime atsidaryti tokiais būdais: naudodamiesi pele (pav. 3.6), redaktoriaus lange pažymėję funkcijos pavadinimą ir paspaudę F1, naudodami specializuotas funkcijas, tokias kaip help(), ?, ??. Kaip naudotis langu, paaiškinta pav. 3.6. Pav. 3.6: Naudojimasis pagalbos ir dokumentacijos langu. Ketvirtoje „RStudio“ langų grupėje (pav. 3.3) atsidarome kortelę „Help“ (1), įvedame dominančios funkcijos pavadinimą (2) ir iš iššokusio sąrašo pasirenkame patikslintą temą (3) arba tiesiog paspaudžiame Enter. Raidėmis pažymėtos dalys paaiškintos tekste. Dažnai naudingiausia dalis yra pavyzdžiai (G). Funkcijos dokumentacijos dalys, kurias įprastai turi aprašymas pagalbos lange (atitinka raidinius pav. 3.6 žymėjimus): Pačiame viršuje – funkcijos ir paketo, iš kurio ta funkcija paimta, pavadinimai tokiu formatu funkcija {paketas}; Aprašo pavadinimas (kuriame įprastai atsispindi funkcijos esmė); Skiltis Description – trumpas aprašas, ką funkcija atlieka; Skiltis Usage – „R“ kalbos sintaksė, kaip naudoti tą funkciją; Skiltis Arguments – funkcijos argumentų aprašymas; Skiltis Value – rezultato, kurį sukuria funkcija, aprašymas; Skiltis Examples – tai turbūt pati naudingiausia skiltis, kurioje yra programos kodo pavyzdžiai, rodantys kaip naudoti šią funkciją; Paketo pavadinimas ir versija. Priklausomai nuo aprašo, jo dalių skaičius gali būti kitoks. Paprastoji paieška programiškai. Komandų lange parašome komandą help(), o jos skliaustuose – dominančios funkcijos pavadinimą. „R“ ieško funkcijos aprašymų šiuo metu užkrautuose paketuose, todėl šis paieškos būdas labai spartus. Sakykime, norime apskaičiuoti medianą, bet nežinome, kaip naudojama funkcija median(). Rašome komandą: help(median) Kaip alternatyva gali būti naudojamas klaustuko operatorius: ?median Išplėstinė paieška programiškai. Jei paprastoji paieška aprašymo neranda, galite mėginti dviejų klaustukų operatorių, kurio pagalba aprašo ieškoma visoje „R“ dokumentacijoje: ??median Šio tipo paieška žymiai lėtesnė, tad procesas gali užtrukti. Plačiau apie „R“ pagalbos sistemą ir kaip ja naudotis rašoma straipsnyje „Getting Help with R“ bei forumo temoje „How to get help in R?“ . Užduotis 3.4 Nustatykite, ką atlieka ir kaip naudojamos (peržiūrėkite pavyzdžius) funkcijos sd(), max(), matrix() bei kokiame pakete jos yra. 3.7 RStudio projektai Geras bruožas – duomenų analizę atlikti tvarkingai. „RStudio“ turi specializuotų šiam tikslui skirtų įrankių. Vienas iš jų – „RStudio“ projektai, kurių ikona vaizduojama pav. 3.7. „RStudio“ projektas – tai aplankas jūsų kompiuteryje, skirtas kokiam nors duomenų analizės projektui. Šį aplanką programa pasižymi įkeldama bylą plėtiniu „.Rproj“ (pvz., „projektas.Rproj“), tad atidarius šią bylą atidaroma ir programa „RStudio“. Tame aplanke saugoma dalis programos nustatymų, skirtų projektui, taip pat gali būti saugomi duomenys, programos kodai ar kiti su projektu susiję dokumentai. Projektai labai pravartūs, jei tuo pačiu laikotarpiu dirbame su keliomis užduotimis, kurioms atlikti naudojame „R“, pvz., biostatistikos pratybomis, kursiniu darbu ir praktikos laboratorijoje užduotimis. Įprastai projekto aplankas laikomas aktyviuoju (darbiniu) aplanku (angl. working directory) – programa „R“ duomenų ir kitų bylų ieško būtent šiame aplanke. Pav. 3.7: „RStudio“ projekto ikona (autorių teisės gali būti saugomos). Visos programos vietos, paženklintos šiuo simboliu, yra susijusios su projektais. Projekto aplanke esanti „.Rproj“ byla taip pat paženklinta šiuo simboliu. „RStudio“ projektų valdymo meniu bei naujo projekto kūrimas vaizduojami pav. 3.8 ir 3.9. Pav. 3.8: Darbo su „RStudio“ projektais pagrindai. Pav. 3.9: Naujo „RStudio“ projekto kūrimo žingsniai. Punktus 1-4, 7 ir 8 pasirenkame pele, nurodome naujo projekto (5) ir aplanko, kuriame jis bus sukurtas (6) pavadinimus. 7 – jei varnelė uždėta, dabartinis projektas liks atidarytas. Bangelė aplanko pavadinime nurodom jog tai „Dokumentai“/„My documents“ (sistemoje „Windows“) arba pradžios (Home) aplankas (sistemose „Linux“, „Mac“). Būsimų pratybų metu jums bus duodami „RStudio“ projektai, suarchyvuoti (.zip) formatu. Prieš juos atsidarant, archyvų turinį būtina išskleisti („iš’zip’inti“) į atskirą aplanką, projektą atsidaryti ir atkreipti dėmesį į tai, koks atsidariusio projekto pavadinimas (pav. 3.10). Jei pavadinime yra archyvo plėtinys, pvz., „.zip“, vadinasi projektas atsidarytas ne taip, kaip reikia, ir kils problemų dirbant. Sprendimas: projektą uždaryti, „zip“ archyvo turinį išarchyvuoti („iš’zip’inti“) į atskirą aplanką ir projektą atidaryti iš šio naujojo aplanko. Pav. 3.10: „RStudio“ projekto pavadinimas. Užkrovus „RStudio“ projektą, matomas aplanko, kuriame yra projektas, pavadinimas (tarkime „Pratybos-2“). Jei projektas neužkrautas, matome užrašą „Project: (none)“. Jei projektą užkrauname iš bylos, kuri yra suarchyvuota (t. y., užkrauname netinkamai), projekto pavadinime yra archyvo bylos plėtinio (.zip, .rar ar pan.) pavadinimas. Tinkamai užkrauto projekto pavadinimas – tai projekto aplanko (o ne „.Rproj“ bylos) pavadinimas. Kartais (pvz., diegiantis paketus) projektą reikia uždaryti. Taip pat programa „RStudio“ suteikia galimybę greituoju būdu atsidaryti iki 10 naujausių projektų. Kaip tai padaryti vaizduojama pav. 3.11. Pav. 3.11: Projekto uždarymas ir neseniai uždaryto projekto atvėrimas. Pasirenkame ikoną, ties kuria – dabartinio projekto pavadinimas (1). Norėdami užverti projektą, renkamės „Close Project“ (2). Iki 10 vėliausiai naudotų projektų matome sąraše žemiau (pavyzdyje tik vienas projektas, pavadintas „Pratybos-2“). Vėliau norėdami atverti vieną iš šių 10 projektų, galime spustelti arba patį projekto pavadinimą (3) arba ikoną ties juo (4): (3) projektą atvers dabartiniame lange, o (4) – naujame (dabartinis irgi liks atidarytas). Norėdami peržiūrėti dabartinio projekto aplanko turinį arba šį aplanką atsidaryti iš programos „RStudio“, naudokitės pav. 3.12 pateiktomis instrukcijomis. Pav. 3.12: Aplanko peržiūra ir atidarymas. Programos „RStudio“ 4 langų grupėje (pav. 3.3) pasirinkite „Files“ kortelę (1). Joje matysite šiuo metu peržiūrimo aplanko pavadinimą (2). Namuko simbolis ir užrašas „Home“ (analogiškai kaip ir bangelė) sistemoje „Windows“ žymi jūsų dokumentų aplanką. Paspaudę kortelėje esančią projekto ikoną (3), pamatysite bylas ir aplankus, esančius jūsų projekto aplanke. Jei dirbate ne projekte, ikonos nebus. Toliau dirbant langas privalo būti pakankamai didelis, kad matytųsi visi mygtukai. Jei nesimato, langą reikia praplatinti: užveskite pelės žymeklį ties riba tarp dviejų langų, kol žymeklio ikona pasikeis (4) ir paspaudę pele ribą patempkite iki tol, kol langas taps reikiamo dydžio. Norėdami peržiūrimą aplanką atidaryti, spauskite mygtuką „More“ (5). Atsidariusiame meniu pasirinkite komandą „Show Folder in New Window“ (6). Aplankas atsidarys įprastu būdu, t. y., pagrindine jūsų kompiuterio sistemos aplankų peržiūrėjimo programa. Papildoma. Plačiau apie „RStudio“ projektus galite skaityti „RStudio“ pagalbos tinklalapyje . Užduotis 3.5 Susikurkite naują „RStudio“ projektą pavadinimu „Pratybos-1“ . Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["r-pradmenys.html", "4. Programos R pradmenys 4.1 Pirmieji R kodo elementai 4.2 R funkcijos 4.3 R objektai 4.4 Svarbiausi R duomenų tipai 4.5 R duomenų struktūros 4.6 Klausimai savikontrolei Klausimai ir komentarai", " 4. Programos R pradmenys „R“ yra programa, specializuota duomenų analizei. Šiame skyriuje susipažinsime su „R“ kaip su kompiuterine duomenų analizės kalba. Tikslas – įgyti darbo programa „R“ pradmenis: susipažinti su pagrindiniais „R“ kodo elementais, svarbiausiais „R“ duomenų tipais bei „R“ duomenų struktūromis. Jūsų užduotys skaitant šį skyrių: Išmokti suprasti ir naudoti „R“ sintaksės elementus, tokius kaip komentarai ir funkcijos (komandos). Sužinoti, kas yra funkcijos argumentas; Išmokti sukurti „R“ objektą (atlikti priskyrimo operaciją) ir sužinoti, kokie pavadinimai objektams yra leistini; Išmokti apibūdinti svarbiausius šiam kursui kompiuterinius „R“ duomenų tipus (skaičius, faktorius, tekstinius ir loginius kintamuosius) ir sužinoti, kokius statistinius duomenų tipus (kategorinius nominaliuosius, kategorinius ranginius, kiekybinius diskrečiuosius, kiekybinius tolydžiuosius ar nei vienas) jie atitinka. Išmokti programoje „R“ kurti duomenų sekas („R“ vektorius) ir atlikti paprastus veiksmus su šiomis sekomis („DataCamp“ užduotis). Pagrindinė ir svarbiausia praktinė jūsų šios dienos užduotis pateikta sistemoje „DataCamp“. Jos aprašymas: Užduotis 4.1 Norėdami praktiškai susipažinti su šiame skyriuje išdėstyta medžiaga, atlikite pamokos „Introduction to R“ 1, 2 ir 4 skyrius (įvadas, vektoriai ir faktoriai) sistemoje „DataCamp“ (1-2 val.). Prie sistemos prisijunkite naudodami savo VU studento el.pašto adresą. Kitaip nebus galimybės patikrinti, ar užduotį tikrai atlikote. 4.1 Pirmieji R kodo elementai Turbūt pamenate lietuvių kalbos pamokas apie „sintaksę ir skyrybą“. Jų metu mokėtės rašyti sakinius, taisyklingai sujungti įvairias jų dalis, tokias kaip aplinkybės, bei taisyklingai jas atskirti tinkamais skyrybos ženklais. Kompiuterijoje taip pat yra terminas „sintaksė“, kuriuo nusakoma kompiuterinės kalbos rašymo taisyklių visuma. Sintaksė (kompiuterijoje) yra kompiuterinės kalbos rašymo taisyklių visuma. Jūsų uždavinys analizuojant šį poskyrį – išmokti atpažinti kelis pagrindinius „R“ programos kodo sintaksės elementus bei susipažinti su šioje mokomojoje medžiagoje (svetainėje) naudojamu jų spalviniu žymėjimu. 4.1.1 R kodo komentarai (#) Vienas iš „R“ kalbos elementų yra komentaras. Grotelių ženklas (#) šalia „R“ komandų reiškia, kad tai komentaro pradžia. To, kas yra parašyta po grotelių, programa „R“ neskaito. Šitokiu būdu galime rašyti pastabas patys sau: # Tai komentaras, kurio R neskaito Komentaro ženklas galioja iki eilutės pabaigos, o rašant iš naujos eilutės – nebegalioja, tad norint tęsti komentarą kitoje eilutėje reikia groteles rašyti iš naujo: # Tai komentaras, # kuris tęsiasi per # kelias eilutes Tam, kad būtų paprasčiau susigaudyti, modernios programos įprastai skirtingomis spalvomis paryškina įvairius „R“ kodo elementus. Konkrečios spalvos ir paryškinimo būdas priklauso nuo naudojamos programos ir pasirinktų nustatymų. Šioje elektroninėje knygoje komentarai bus išryškinami tamsiai mėlyna spalva (kaip matote pavyzdyje virš šios pastraipos). Dirbdami programa „RStudio“, komentarus galite uždėti ir nuimti naudodami sparčiųjų klavišų kombinaciją Ctrl+Shift+C. Užduotis 4.2 Atsidarykite „RStudio“ redaktoriaus langą, jame – „R Script“ dokumentą. Jei dokumentas jau buvo atidarytas, naujo galite nekurti. Pirmoje eilutėje užrašykite „Author:“ ir savo vardą. Antroje – „Date:“ ir šios dienos datą. Abi eilutes pažymėkite pele. Naudodami greitųjų klavišų kombinaciją, eilutę užkomentuokite. Naudodami tą pačią kombinaciją atkomentuokite ir vėl užkomentuokite (t. y., įsitikinkite, kad ta pati kombinacija atlieka du veiksmus ir veikia tinkamai). 4.1.2 Rezultatų ženklinimas (##) Šioje svetainėje prieš rezultatus, kuriuos apskaičiuoja programa „R“, bus padedami du grotelių (t.y., komentaro) simboliai iš eilės (##) ir rezultatų tekstas bus nuspalvinamas pilkai: ## tai rezultatas, kurį pateikė R Pavyzdys: sudėjus 2 ir 3 (šią komandą parašome mes) atsakymas yra 5 (atsakymą apskaičiuoja ir parašo programa „R“): 2 + 3 ## [1] 5 Jei rezultatas bus apskaičiuojamas dirbant programa „R“, tai šių dviejų grotelių nepamatysite, nes dirbant programa ir taip aišku, kur jūsų parašyta komanda, o kur kompiuterio atsakymas. Užduotis 4.3 Programos „RStudio“ komandų lange (konsolėje) parašykite matematinį veiksmą 3 + 2. Kokį rezultatą gavote? Ką jis reiškia? Ar matote grotelių simbolį (##)? 4.1.3 Elementų eilės numerių žymėjimas: [ ] Praeitame pavyzdyje pastebėjote, kad eilutės pradžioje laužtiniuose skliaustuose atsirado papildomas skaičius [1]. Jis nurodo tos eilutės pirmojo elemento eilės numerį (pavyzdyje jo reikšmė buvo 5, o eilės numeris – 1). Aišku, šiuo atveju užrašas [1] duoda mažai naudos. Tačiau yra labai patogus, kai atsakymo elementų yra daug ir jie netelpa į vieną eilutę. Tokiu atveju laužtiniuose skliaustuose nurodomas kiekvienos eilutės pirmojo elemento eilės numeris, pvz.: ## [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ## [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ## [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 ## [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 ## [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 ## [86] 95 96 97 98 99 100 Pavyzdyje matome, kad elemento, kurio eilės numeris yra [69] reikšmė yra 78. Programoje „R“ elementų numeravimas (indeksavimas) prasideda nuo 1. T. y., indeksas „1“ reiškia, kad elemento eilės numeris yra pirmas. Kai kuriuose kituose programose indeksai prasideda nuo 0, o tai nėra taip patogu. Užduotis 4.4 „RStudio“ konsolėje parašykite komandą 595:200, kuri sukurs mažėjančių skaičių seką nuo 595 iki 200. Kokios elementų, kurių eilės numeriai 20 ir 380 reikšmės? 4.1.4 Kitų elementų spalvinis žymėjimas Skaičiai, simbolių eilutės, loginiai kintamieji bus išryškinami jiems būdingomis spalvomis: # Šioje eilutėje komentaras objekto_pavadinimas 335 # Skaičius TRUE # Loginė reikšmė &quot;simbolių eilutė (tekstas) rašoma kabutėse&quot; Užduotis 4.5 Aukščiau esantį programos kodo pavyzdį nukopijuokite į „RStudio“ redaktoriaus langą („R script“ dokumentą). Kokiomis spalvomis nusidažė skirtingi „R“ sintaksės elementai? 4.1.5 Programos kodas: blokais ir tekste Didesni kodo pavyzdžiai bus pateikiami blokais su spalvomis išryškintais elementais, kaip matėte ankstesniuose pavyzdžiuose: # Sudedame 5 bei 4 ir ištraukiame šaknį. # Atsakymas bus 3: sqrt(5 + 4) ## [1] 3 Kodo pavyzdžiai gali būti pateikiami ir toje pačioje eilutėje su tekstu, pvz., sqrt(5 + 4). (Komanda sqrt() reiškia kvadratinė šaknis, angl. square root). Žinokite, kad tai programos kodas. 4.2 R funkcijos Viskas, kas vyksta programoje „R“ – sudėtis, lango atidarymas, paveikslo nubraižymas, duomenų išsaugojimas, spalvos pakeitimas – yra kokios nors komandos vykdymo rezultatas. Komandas galima suskirstyti į įprastines funkcijas ir operatorius. 4.2.1 Įprastinės funkcijos ir jų argumentai Funkcija – tai veiksmas ar komanda, kurią nurodome atlikti kompiuteriui. Jos rašomas kaip vienas žodis be tarpelių (susidedantis iš raidžių, skaičių, taškų ir/arba apatinių brūkšnių), kurio gale yra paprastieji apvalūs skliausteliai (). Atkreipkite dėmesį į tai, kad tarp komandos pavadinimo ir skliausto tarpų nepaliekame. Šioje svetainėje funkcijos bus paryškintos žydrai, pavyzdžiui: r_funkcija() Pastaba: jūsų kompiuteryje užrašas r_funkcija() neveiks, nes tai tik pavyzdys. Komandos skliausteliuose rašome taip vadinamus funkcijos argumentus (terminai „funkcijos“, „argumentai“ – visai tokie, kaip per matematikos paskaitą): r_funkcija(argumento_reikšmė) Argumentai gali turėti pavadinimus ir šie bus pabraukti (kol kas nesijaudinkite, jei neaišku, kas tie argumentai ir t.t. Dabar svarbiausia, kad suprastumėte tik jų spalvinį žymėjimą): r_funkcija(argumento_pavadinimas = argumento_reikšmė) Jei argumentas turi pavadinimą, jo reikšmė nurodoma naudojant = (bet ne operatorių &lt;-, apie kurį rašoma skyriuje „Objektų kūrimas“). Pavadinimą turinčio funkcijos argumento reikšmė nurodoma naudojant operatorių = (bet ne &lt;-). Pavyzdys, funkcija log(), kuri įprastai apskaičiuoja natūrinį logaritmą. Apskaičiuokime \\(ln(100)\\): log(100) ## [1] 4.60517 Funkcija log() turi argumentą x, tad galime užrašyti kitaip ir gauti tą patį rezultatą: log(x = 100) ## [1] 4.60517 Užduotis 4.6 Programos „RStudio“ konsolėje parašykite žodį „log(“ (programa automatiškai padės uždarantį skliaustelį). Tada paspauskite klavišą Tab. Programa parašys, kokie galimi funkcijos log() argumentų pavadinimai (juos galėsite pasirinkti pele). Įvardinkite šiuos argumentus. Analogiškai išsiaiškinkite, kokie galimi funkcijos data.frame() argumentų pavadinimai. Kol kas jų reikšmės suprasti nereikia. Atlikdami pratimą išsiaiškinome, kad iš tiesų funkcija log() turi kelis argumentus, ir kai argumentų daug, jų parašymas funkcijos viduje suteikia aiškumo: log(100, base = 10) ## [1] 2 Turbūt supratote, kad buvo pakeistas logaritmo pagrindas („base“) į 10 ir apskaičiuota išraiška \\(log_{10}(100)\\). Tuo tarpu užrašas be argumentų pavadinimų nėra toks aiškus: log(100, 10) ## [1] 2 Jei norite daugiau sužinoti apie funkciją log(), komandų lange įrašykite ?log (prieš funkcijos pavadinimą padėkite klaustuką) ir pagalbos bei dokumentacijos lange „Help“ (pav. 3.3 langas Nr. 4) pamatysite aprašymą. Jei naudojame kelis funkcijos argumentus, juos atskiriame kableliais (,), o po kablelio padedame tarpelį: r_funkcija(reikšmė_1, reikšmė_1, reikšmė_3) Arba: r_funkcija(arg_1 = reikšmė_1, arg_2 = reikšmė_1, arg_3 = reikšmė_3) Pavyzdys – funkcija c(), kuri skirta kurti duomenų sekas (vektorius): c(1, 16, 99, -3, 58) ## [1] 1 16 99 -3 58 Funkcija c() bus viena iš dažniausiai naudojamų, todėl ją įsiminkite labai gerai. Užduotis 4.7 Apskaičiuokite dvejetainį logaritmą skaičiui 65. Koks atsakymas? Sukurkite seką („R“ vektorių) iš skaičių: 1; 10; 100; 1000; 10000. 4.2.2 Operatoriai „R“ operatoriai – tai pavieniai simboliai ar kelių simbolių sekos, atliekančios tam tikrus veiksmus (t. y., operacijas). Iš principo, operatorius – tai „R“ funkcija, tik užrašoma ne žodžiais, o simboliais. Pavyzdžiui, sudėties operatorius +: -25 + 43 ## [1] 18 Operatoriai būna: Aritmetiniai: atlieka matematines operacijas, pvz., +, -; Palyginimo: lygina reikšmes, pvz., &lt;; Loginiai: (&amp; – IR, | – ARBA, ! – NE) – įprastai naudojami tikrinant sąlygas, pvz., ar geras IR turtingas; Priskyrimo: pvz., &lt;-, -&gt; ar = – skirti kurti „R“ objektus; Skaičių sekų kūrimo, pvz., :; Kitokie, pvz., funkcijų jungimo į grandinę operatorius %&gt;%. Užduotis 4.8 „RStudio“ pagalbos lango („Help“) paieškos laukelyje parašykite nurodytus operatorius ir suraskite reikiamą informaciją apie juos: &lt;- – kaip vadinasi tema? | – kaip vadinasi tema? + – kaip vadinasi tema ir ar dokumentacijoje pateikta pavyzdžių? : – kam skirtas šis operatorius ir kaip juo naudotis? 4.3 R objektai Viskas, kas „R“ atmintyje yra išsaugota tam tikru pavadinimu, vadinama objektais. Išsaugoti galime skaičius, duomenų sekas, duomenų lenteles ir netgi funkcijas (pav., 4.1). „R“ objektai dar vadinami kintamaisiais kompiuterijos prasme (angl. variable), nes pavadinimu žymimą reikšmę galime pakeisti. Pav. 4.1: Programos „R“ objektų tipų pavyzdžiai. Pastabos. Atkreipkite dėmesį į tai, kad vienodai skambantys terminai (pvz., „objektas“, „kintamasis“) statistikos ir kompiuterijos prasme gali turėti susijusias, bet skirtingas reikšmes. Tikiuosi, kad greit susigaudysite ir tai nekels problemų. 4.3.1 Objektų kūrimas Veiksmas, kurio metu kintamajam priskiriama reikšmė (t. y., kurio metu sukuriamas objektas), vadinamas priskyrimu (angl., assignmemt). „R“ objektai sukuriami naudojant taip vadinamą priskyrimo operatorių: arba &lt;- (įprastinis „R“ naudotojo pasirinkimas), arba =. Rodyklė &lt;- susideda iš simbolių „mažiau“ ir „minus“, parašytų be tarpo. Programoje „RStudio“ įterpiama naudojant kombinaciją Alt+-. Kartais paspaudus šią kombinaciją įterpiamas operatorius =. Tokiu atveju programa mano, kad esamoje situacijoje šis operatorius yra tinkamesnis. Būtinai atkreipkite dėmesį į tai, kad iš kiekvienos operatoriaus pusės yra palikta po tarpelį. Tai suteikia aiškumo. Sukurkime objektą objekto_pavadinimas kurio reikšmė būtų skaičius keturi: # Skaitinės reikšmės priskyrimas objekto_pavadinimas = 4 # Skaitinės reikšmės priskyrimas objekto_pavadinimas &lt;- 4 Sakoma, kad objektui objekto_pavadinimas priskiriama reikšmė 4. Jei parašome sukurto kintamojo pavadinimą, įprastai atspausdinama jo reikšmė (tai vadinama spausdinimu pagal nutylėjimą): objekto_pavadinimas ## [1] 4 Taip pat tą patį rezultatą galime pasiekti naudodami komandą print() (šiuo atveju tai išreikštasis spausdinimas, nes parašome komandą): print(objekto_pavadinimas) ## [1] 4 Vėliau sukurtą objektą galima panaudoti atliekant tolimesnius veiksmus. Panagrinėkime pavyzdį. Sukurkime objektą ir priskirkime jam reikšmę: nupirkom_kiausiniu &lt;- 10 Atspausdinkime sukurtą objektą (reikšmės spausdinimas pagal nutylėjimą): nupirkom_kiausiniu ## [1] 10 Sukurkime dar vieną objektą: suvalgem_kiausiniu &lt;- 6 Atspausdinkime ir jį: suvalgem_kiausiniu ## [1] 6 Su šiais dviem objektais galime atlikti matematinius veiksmus tarsi tai būtų skaičiai, kuriuos priskyrėme: liko_kiausiniu &lt;- nupirkom_kiausiniu - suvalgem_kiausiniu Atspausdinkime rezultatą: liko_kiausiniu ## [1] 4 Reikšmes taip pat galima priskirti naudojant ir = simbolį: po_papildymo = liko_kiausiniu + 3 po_papildymo ## [1] 7 Užduotis 4.9 Naudodami operatorių &lt;- sukurkite objektus pavadinimais „a“, „b“ ir „c“ kurių reikšmės būtų atitinkamai 96, -6, 0.01. Visus šiuos objektus sudėkite. Ar rezultatas toks, kokio tikėjotės? 4.3.2 Darbinė erdvė Galime apsibrėžti, kad darbinė erdvė, arba darbinė aplinka (angl., workspace, arba working environment), – tai visi darbinėje „R“ atmintyje esantys (sukurti ar įkelti) objektai. Jų pavadinimai yra išvardinti lange „Environment“ (pav. 3.3 langas Nr. 3). „Išvalyti darbinę erdvę“ – reiškia ištrinti visus „R“ atmintyje esančius objektus. „Išsaugoti/užkrauti darbinę erdvę“ – šiuos objektus išsaugoti į kietąjį diską ar vėl įkelti į „R“. Užduotis 4.10 Į konsolę nukopijuokite programos kodą x &lt;- 2 ir paspauskite klavišą Enter. Lange „Environment“ atsiras objektas, pavadinimu „x“. Ar matote jį? Jei norime, kad „R“’as konsolėje išvardintų objektų, šiuo metu esančių jo atmintyje, pavadinimus, galime naudoti komandą objects(): objects() # R&#39;as išvardija, kas jo darbinėje atmintyje Dažnai naudojamas komandos objects() sinonimas yra komanda ls(), kuri daro visiškai tą patį: ls() # R&#39;as išvardija, kas jo atmintyje Norėdami pašalinti objektą, naudojame funkciją remove() arba rm(), kurios skliaustuose įrašome objekto pavadinimą, pvz.: remove(suvalgem_kiausiniu) Kaip analizuojant „R“ kodą pagal skliaustelius atpažinti, kur yra įprastinė funkcija, o kur kitoks objektas? Pradiniam susigaudymui galima sakyti, kad po funkcijos rašomi paprastieji apvalieji skliausteliai ( ), pvz., sum(). Jei parašyti laužtiniai skliausteliai [ ] arba [[ ]], vadinasi, tai kitoks objektas (ne funkcija). 4.3.3 Objektų pavadinimai Leistini simboliai pavadinimuose Programoje „R“ objektų pavadinimuose pirmasis simbolis privalo būti raidė. Pirmas gali būti ir taškas, bet tada objektas tampa paslėptas, o tai jau pažengusiųjų lygio tema, tad tokie pavadinimai nerekomenduojami. Antras ir tolimesni simboliai gali būti didžiosios ir mažosios raidės, skaičiai, taškas (.) ir apatinis brūkšnys (_). Ar didžiosios ir mažosios raidės – svarbu? Programa „R“ skirtingai reaguoja į didžiąsias ir mažąsias raides. Tad pavadinimai T ir t arba c ir C, arba mano_mama, mano_Mama ir mano_MAMA yra suprantami kaip skirtingi žodžiai. Skirtingas programų reagavimas į didžiąsias ir mažąsias raides angliškai vadinamas terminu „case sensitive“. Pavadinimų rašymo stilius (rekomendacijos) Ar pamenat filmuką „Kung-fu Panda“? Jame kung-fu meistrai naudojo skirtingus kovos stilius: tigro, gervės, gyvatės… Panašiai ir rašant kintamųjų pavadinimus, kuriuose norima pavartoti kelis žodžius, naudojami įvairūs stiliai: DvikuprioKupranugarioStilius – žodžiai rašomi iš didžiosios raidės, be tarpų (angl. big/upper camel case); vienkuprioKupranugarioStilius – visi žodžiai, išskyrus pirmąjį, rašomi iš didžiosios raidės, be tarpų (angl. small/lower camel case); taškuotojo.leopardo.stilius – žodžiai atskiriami taškais; gyvatės_stilius – visos raidės mažosios, o žodžiai atskiriami apatiniais brūkšniais (angl. snake case). Šio kurso metu daug dėmesio skirsime darbui „Tidyverse“ sistema. Todėl objektų pavadinimus rašysime pagal „Tidyverse“ stiliaus gido rekomendacijas – naudosime gyvatės_stilių, kur: pavadinime naudojamos tik mažosios raidės, skaičiai ir apatinis brūkšnys _; pirmasis simbolis pavadinime – visada raidė (mažoji). Taip pat stenkitės kurti prasmingus pavadinimus, pvz., ugis, svoris, amzius (vietoje x, y ar z), kurie padėtų lengviau suprasti jūsų kodo esmę ir kitam žmogui (tarkim, jums po 6 mėnesių) būtų paprasčiau jį suprasti. Pastebėsite, kad kitų autorių kode objektų pavadinimuose taškas (.) yra vartojamas gana dažnai. Deja, tam tikrame kontekste jis įgyja specialiąją reikšmę. Todėl taško „R“ objektų pavadinimuose venkite. Kaip kurti „R“ objektų pavadinimus, kad vėliau nekiltų problemų? Naudotis „Tidyverse“ stiliaus rekomendacijomis: pirmasis simbolis pavadinime privalo būti mažoji raidė; kiti simboliai – tik mažosios raidės, skaičiai ir apatiniai brūkšniai _; pavadinimai turėtų būti prasmingi, bet trumpi. Taško „R“ objektų pavadinimuose venkite. Lietuviškų (tiksliau, neangliškų) raidžių „R“ objektų pavadinimuose taip pat siūlau vengti. Gali kilti problemų, jei nustatyta netinkama lokalė. Papildoma. Visą „Tidyverse“ stiliaus gidą galite rasti adresu style.tidyverse.org . Užduotis 4.11 Kurie iš šių „R“ objektų pavadinimų (1) yra leistini programoje „R“ apskritai ir kurie (2) rekomenduojamų vartoti simbolių prasme yra tinkami pagal „Tidyverse“ stiliaus gidą? pirmoobjektopavadinimas &lt;- 1 PIRMOOBJEKTOPAVADINIMAS &lt;- 1 1objektopavadinimas &lt;- 1 pirmo.objekto.pavadinimas &lt;- 1 Objekto.pavadinimas.1 &lt;- 1 obj.....nr..........1 &lt;- 1 pirmo!objekto!pavadinimas &lt;- 1 o001452475584 &lt;- 1 pirmo_objekto_pavadinimas &lt;- 1 pirmo_objekto$pavadinimas &lt;- 1 pirmoObjektoPavadinimas &lt;- 1 0pavadinimas0 &lt;- 1 PIRMO_OBJEKTO_PAVADINIMAS &lt;- 1 _objektas &lt;- 1 obj_1 &lt;- 1 Netaisyklingi pavadinimai Programoje „R“ yra mechanizmas, skirtas naudoti ir netaisyklingus pavadinimus: pavadinimus reikia įrašyti tarp atgal pasvirusių simbolių, vadinamų – graviais ` (angl. backtick). Šis simbolis įprastai yra šalia Esc ir ~. `1 netaisyklingas pavadinimas +` &lt;- 22 `1 netaisyklingas pavadinimas +` ## [1] 22 Kai kuriais atvejais, tarkim, dirbant papildiniu „R Commander“, šis metodas neveiks arba rezultatai bus netikėti (pvz., klaida). Tad dirbant „R Commander“ rekomenduoju naudoti tik taisyklingus objektų pavadinimus. 4.4 Svarbiausi R duomenų tipai Programa „R“ yra skirta darbui su duomenimis. Pagal prigimtį duomenys būna skirtingų tipų (pvz., skaičiai ar kategorijos). Vieną klasifikaciją, kuri svarbi statistinei analizei, peržvelgėme teorinių paskaitų metu. Dėl praktinių (pvz., ar patogu dirbti) bei techninių (pvz., kiek vietos užima kompiuterio atmintyje) sumetimų kiekviena kompiuterinė duomenų analizės sistema savaip apibrėžia duomenų tipus. Reiktų žinoti, kad yra „teoriniai statistiniai“ ir „kompiuteriniai“ duomenų tipai. Visi „R“ objektai turi savybę pavadinimu klasė (angl. class), kas reiškia, kad su skirtingos klasės objektais tos pačios funkcijos gali elgtis skirtingai (pvz., funkcija plot() braižo skirtingo tipo grafikus, funkcija summary() atlieka skirtingo tipo skaitines suvestines). Objekto klasę galime patikrinti naudodami funkciją class(). Per objektų klasių prizmę ir aptarsime svarbiausius programos „R“ duomenų tipus 4.1. Lentelė 4.1: Pagrindiniai „R“ duomenų tipai. Kompiuterinio duomenų tipo pavadinimas „R“ klasė Alternatyvus pavadinimas Atitinkamas statistinių duomenų tipas Reikšmių užrašymo pavyzdys Sveikieji skaičiai¹ integer Kiekybiniai 1L, -65L, 0L Realieji skaičiai¹ numeric double Kiekybiniai 42, -0.6, 1.2e2, .3 Loginės reikšmės¹ logical boolean Atitikmens neturi TRUE, FALSE Ženklų eilutės¹(tekstas) character strings Atitikmens neturi &quot;labas&quot;, &#39;A4&#39; Faktorius² factor Kategoriniai ¹ – Pagrindinis (atominis) duomenų tipas. ² – Sudėtinis duomenų tipas (bus aptarta vėliau). Aptarkime kiekvieną iš šių klasių plačiau. 4.4.1 Skaitiniai kintamieji Prieš aptardami technines detales apie svarbiausius skaitinius „R“ duomenų tipus įsidėmėkite tai, kad: Klasė „integer“ tinka ir tolydiesiems, ir diskretiesiems (jei jie suapvalinti iki sveikųjų dalių) kiekybiniams duomenims reprezentuoti. Klasė „numeric“ taip pat tinka ir tolydiesiems, ir diskretiesiems kiekybiniams duomenims. Abi skaitinių kompiuterinių duomenų klasės („numeric“ ir „integer“) yra tinkamos statistiniams kiekybiniams kintamiesiems reprezentuoti. Klasė „numeric“ Klasė „numeric“ – tai realieji skaičiai, t. y., skaičiai su kableliu. Šios klasės objektai kompiuterijoje dar vadinami „double“ (nuo „double-precision floating-point format“). Visiems skaičiams (ne tik „numeric“ klasės) programoje naudojamas tam tikras spalvinis žymėjimas. Be papildomų nurodymų programoje „R“ parašytas skaičius suprantamas kaip klasės „numeric“ atstovas, pvz., 0, 42 ar -3.2. Konsolėje parašykite class(42) ir įsitikinsite. Programoje „R“ sveikoji ir dešimtoji dalys skaičių rašomos atskiriant tašku, pvz., 10.66, o ne kableliu 10,66 (atkreipkite dėmesį į tai, kad kablelis paryškintas kita, skaičiams nebūdinga spalva). Taip yra todėl, kad tai, kas lietuviškai vadinama „kableliu“, angliškai užrašoma kaip taškas (žiūrėti pavyzdžius). Jei sveikoji skaičiaus dalis yra 0, tai jos galime nerašyti, pvz., .01 yra tas pats, kas 0.01, o -.2 atitinka -0.2. Šitoks užrašymas gali būti naudojamas ne tik programoje „R“, bet ir mokslinėje literatūroje. Realieji skaičiai gali būti užrašomi ir inžineriniu-moksliniu formatu naudojant simbolius \\(e\\) arba \\(E\\) (abiem atvejais ta pati reikšmė), kur 1e4 reiškia \\(1\\cdot10^4\\), o 2.3e-2 reiškia \\(2.3\\cdot10^{-2}\\). Pvz., 1e2, -1.2E-2. Kad ir kokiu būdu būtų užrašyti, programoje „RStudio“ skaičiai yra išryškinami ta pačia skaičiams būdinga spalva (ji priklauso nuo pasirinktos spalvų schemos): -1.2E-2, 2, .06. (Šioje svetainėje žaliai išryškinami tik sveikieji skaičiai, pvz., lentelėje 4.1). „R“ duomenų statistiniuose aprašymuose trumpinama num arba dbl. Tinka reprezentuoti bet kokiems kiekybiniams statistinių duomenų tipams. Svarbu! Į programą „R“ įvestų skaičių sveikoji ir dešimtoji dalis visada atskiriama tik tašku, bet ne kableliu. Skaičių sekos užrašymo pavyzdys ir jos atvaizdavimo grafiškai pavyzdys: seka_num &lt;- c(125.4, 122.3, 100, 111.2, 101, 121, 122, 119.3) plot(seka_num) Užduotis 4.12 „RStudio“ konsolėje įvykdykite po vieną komandą ir stebėkite, koks atsakymas (gali būti ir klaida): 1 class(1) 1e2 1E3 1e-3 1E-2 1.691e2 class(1.691e2) str(1e2) # str() - objekto struktūra Ar suprantate kiekvieną šio kodo eilutę? Klasė „integer“ Klasei „integer“ priklauso teigiami ir neigiami sveikieji skaičiai bei nulis: Sveikasis skaičius kompiuterio atmintyje užima mažiau vietos nei realusis ar kompleksinis. Mūsų kurso metu naudojamiems duomenims šis skirtumas nebus praktiškai reikšmingas. Norint, kad skaičius būtų saugomas kaip sveikasis, jo pabaigoje parašome L didžiąją raidę, pvz., 4L. Sveikasis skaičius įprastai gali būti ne mažesnis nei -2147483647 ir ne didesnis nei 2147483647. Tačiau to mums prisiminti nereikia, nes jei parašytume netinkamo dydžio skaičių, „R“ mums apie tai praneš įspėjimo žinute. „R“ duomenų statistiniuose aprašymuose trumpinama int. Įprastai naudojamas kiekybiniams diskretiesiems statistiniams kintamiesiems reprezentuoti, bet tinka ir iki sveikosios dalies suapvalintiems tolydiesiems. Užduotis 4.13 „RStudio“ redaktoriaus lange parašykite 100, L, 100L. Kokiomis spalvomis paryškino užrašą 100L? Konsolėje įvykdykite kodą 100L. Koks atsakymas? Konsolėje įvykdykite kodą class(100L). Koks atsakymas? Įvykdykite kodą: str(100L) # str() - objekto struktūra 4.4.2 Loginės reikšmės Programoje „R“ yra dvi loginės reikšmės TRUE (taip, tiesa) ir FALSE (ne, netiesa), kurios priklauso klasei „logical“: Atsiranda atliekant palyginimą arba sąlygos tikrinimą, pvz., 1 &lt; -1 (lyginame 1 ir -1) arba is.numeric(24) (tikriname, ar 24 priklauso klasei „numeric&quot;). Loginės reikšmės gali būti užrašomos ir sutrumpintai (T arba F), bet visą laiką tik didžiosiomis raidėmis. Atliekant matematinius veiksmus, loginės reikšmės automatiškai paverčiamos į skaičius: TRUE į 1, FALSE į 0. Tad veiksmo TRUE + TRUE + FALSE atsakymas bus 2. Jei pradiniai statistiniai duomenys užrašyti loginėmis reikšmėmis, prieš atliekant statistinę analizę, loginius kintamuosius įprastai reikia pasiversti į kategorinius naudojant funkciją factor() arba as.factor(). Statistiniuose „R“ duomenų aprašymuose trumpinama: lgl, lgcl arba logi. Užduotis 4.14 Kam lygios šios išraiškos? Nurodykite konkretų atsakymą, arba kad „R“ neapskaičiuos (bus klaida). Nenaudokite programos „R“, apskaičiuokite mintinai: sum(TRUE, TRUE, TRUE, FALSE, TRUE) x &lt;- c(&quot;vyras&quot;, &quot;moteris&quot;, &quot;vyras&quot;, &quot;moteris&quot;, &quot;moteris&quot;) sum(x == &quot;moteris&quot;) # == atlieka palyginimą, o = priskyrimą Įvykdykite kodą: str(TRUE) # str() - objekto struktūra 4.4.3 Tekstiniai kintamieji Ženklų ir simbolių eilutės (tekstas) – priklauso klasei „character“, angliškai dar vadinamos terminu „strings“: Mūsų kurso metu tai bus pagalbinis duomenų tipas, kurio reikia norint užrašyti, pvz., grafikų pavadinimus. Tekstinės reikšmės sukuriamos tekstą ar simbolius parašius dvigubuose (&quot;...&quot;) ar viengubose (&#39;...&#39;) „kompiuteristų“ kabutėse (atkreipkite dėmesį, kad tos kabutės yra tiesios ir jose esantis tekstas įprastai paryškinamas tam tikra spalva, šioje svetainėje ji yra žalia), o ne pagražintose „literatūrinėse“ kabutėse, pvz., „...“ arba ‘...’ (šio tipo kabutėse esantis tekstas nėra paryškintas klasei „character“ būdinga spalva, jis pilkas). Ženklų eilučių pavyzdžiai: &quot;labas&quot;,&#39;A4&#39;. „R“ duomenų eilutės palaiko specialiuosius simbolius, kurie prasideda ženklu \\, vadinamu „išeities simboliu“ (angl., escape character). Pvz., \\n – nurodo, kad spausdinant tekstą šioje vietoje bus nauja eilutė, \\t – tabuliacija (tam tikros rūšies tarpas), \\&quot; ir \\' – nurodo, kad šioje vietoje bus kabutės (kabutėse), o ne ženklų eilutės pabaiga. Norėdami atspausdinti paprastą atgal pasvirusį brūkšnį, jį turime rašyti 2 kartus (\\\\). Vienose situacijose tai yra labai patogu, kitose – labai neįprasta ir apsunkina eilutės suprantamumą. Jei pradiniai duomenys yra tekstiniai, juos įprastai pasiversime į kategorinius duomenis naudodami funkciją factor() arba as.factor(). Kompiuterio atmintyje faktoriai užima mažiau vietos nei tekstas. „R“ duomenų statistiniuose aprašymuose trumpinama chr arba char. Prieš atliekant statistinę analizę, tekstinių kintamųjų reikšmės verčiamos į kategorinių kintamųjų reikšmes. Užduotis 4.15 Komanda writeLines() žmogui suprantama išraiška atspausdina ženklų eilutes. „RStudio“ konsolėje įvykdykite kiekvieną komandą ir stebėkite, koks atsakymas (gali būti ir klaida): writeLines(&quot;1 Abc&quot;) writeLines(„2 Abc“) # :( writeLines(&#39;3 Abc&#39;) writeLines(‘4 ABC’) # :( writeLines(&quot;5 A &#39;BC&#39;&quot;) writeLines(&#39;6 A &quot;BC&quot;&#39;) writeLines(&quot;7 A \\&quot;BC\\&quot;&quot;) # \\&quot; kabutės kabutėse writeLines(&quot;8 A\\tB\\tC&quot;) # \\t tabuliacija writeLines(&quot;9 A\\nB\\nC&quot;) # \\n nauja eilutė writeLines(&quot;A\\\\B\\\\C&quot;) # \\\\ tiesiog atgal pasviręs brūkšnys str(&quot;ABC&quot;) # str() — objekto struktūra Ar galite paaiškinti, kodėl gautas būtent toks rezultatas? 4.4.4 Faktoriai – kategoriniai kintamieji Nominalieji duomenys Faktorius (klasė „factor“) – tai „R“ duomenų tipas, turintis iš anksto apibrėžtą galimų skirtingų reikšmių (kategorijų) skaičių. Faktoriai skirti saugoti kategorinių kintamųjų reikšmes. Faktoriai turi iš anksto apibrėžtą galimų reikšmių (kategorijų) skaičių. Programoje „R“ kategorijos vadinamos „lygiais“ (angl. levels). Faktorius yra sudėtinis duomenų tipas: faktorių reikšmės kompiuterio atmintyje saugomos kaip sveikieji skaičiai (t. y., kategorijos kodai), o kategorijų pavadinimai – kaip tekstas. Tokiu būdu kategoriniai duomenys kompiuterio atmintyje užima mažiau vietos nei tekstas. Statistiniuose aprašymuose klasė „factor“ trumpinama fct, fctr arba tiesiog Factor. Faktorius gali būti sukurtas naudojant funkciją factor(), o argumentas levels skirtas nurodyti pageidaujamą kategorijų eilės tvarką: mano_kategorijos &lt;- factor(c(&quot;A&quot;, &quot;C&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;A&quot;), levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) mano_kategorijos # Atspausdiname rezultatą ## [1] A C C B A A ## Levels: A B C Tie patys duomenys, tik kita kategorijų eilės tvarka: mano_kategorijos_2 &lt;- factor(mano_kategorijos, levels = c(&quot;B&quot;, &quot;A&quot;, &quot;C&quot;)) mano_kategorijos_2 # Atspausdiname rezultatą ## [1] A C C B A A ## Levels: B A C Duomenys priklauso klasei „factor“: class(mano_kategorijos) ## [1] &quot;factor&quot; Skirtumas pasimato sudarant lenteles ir braižant grafikus: # Stulpelinė diagrama plot(mano_kategorijos) # Stulpelinė diagrama # (tiems patiems duomenims pakeista kategorijų eilės tvarka) plot(mano_kategorijos_2) (Prisiminkite, kokio tipo grafiką funkcija plot() nubraižė skaitiniams kintamiesiems. T. y., ar tokio paties?) Bandant palyginti kelias faktoriaus reikšmes, „R“ pasakys, kad tokį veiksmą atlikti neprasminga (not meaningful for factors), nes kategoriniai kintamieji neturi natūralaus kategorijų eiliškumo: # [1] pirmas elementas, t. y. raidė „A“ # [2] antrasis elementas, t. y. raidė „C“ mano_kategorijos[1] &lt; mano_kategorijos[2] ## Warning in Ops.factor(mano_kategorijos[1], mano_kategorijos[2]): &#39;&lt;&#39; not ## meaningful for factors ## [1] NA Simbolis NA reiškia, kad atsakymas yra negalimas (angl., not available). Ranginiai duomenys Ranginiams duomenims įprastai naudojama klasė „ordered“. Ji sukuriama naudojant tą pačią funkciją factor() ir nurodant argumentą ordered = TRUE: ranginis &lt;- factor(mano_kategorijos, ordered = TRUE) ranginis ## [1] A C C B A A ## Levels: A &lt; B &lt; C Iš principo, tai tie patys faktoriai, tik papildomai kategorijos turi eilės tvarką, todėl galima palyginti, kuri reikšmė yra didesnė. class(ranginis) ## [1] &quot;ordered&quot; &quot;factor&quot; Ranginio kintamojo reikšmes galima palyginti, nes rangai turi eilės tvarką: ranginis[1] &gt; ranginis[2] ## [1] FALSE Statistiniuose aprašymuose klasė „ordered“ trumpinama kaip ord arba Ord.factor. Užduotis 4.16 Atkartokite šiame skyriuje pateiktus pavyzdžius su faktoriais, tik kategorijų eilės tvarką išdėliokite nuo C iki A. Atvaizduokite grafiškai. Kas pasikeitė? Kintamasis mano_kategorijos buvo sukurtas šio skyriaus pavyzdžiuose. Įvykdykite funkciją unclass(mano_kategorijos). Kaip galėtumėte paaiškinti rezultatą? (Užrašę ?unclass gauname tokį paaiškinimą: „unclass returns (a copy of) its argument with its class attribute removed.“) Įvykdykite kodą šiame skyriuje sukurtiems kintamiesiems: str(ranginis) str(mano_kategorijos) 4.5 R duomenų struktūros Terminas „duomenų struktūra“ nurodo formą, kuria saugomi duomenys. Jei duomenis prilygintume mėgintuvėliams, tai duomenų struktūros būtų tam tikro tipo dėžutės ir laikikliai, skirti tam tikru būdu mėgintuvėlius išdėlioti ir saugoti. Programoje „R“ yra 4 pagrindinės duomenų struktūros: (atominis) vektorius (vector) – tai to paties duomenų tipo reikšmių seka. (Žodis „atominis“ ir reiškia, kad duomenys yra vieno tipo). Neturi nei eilučių, nei stulpelių. Ši duomenų struktūra atitinka duomenų eilutę arba kintamąjį statistikos prasme. Mūsų kurso metu ši struktūra yra labai svarbi. Pavyzdys: į vektorių surašomi visų Gyvybės mokslų centro (GMC) studentų ūgiai. Kitas pavyzdys, į vektorių surašomos visų GMC dėstytojų plaukų spalvos. matrica (matrix) – tai lentelės pavidalo duomenų struktūra, sudaryta tik iš vieno tipo duomenų. Turi eilutes ir stulpelius. Iš skaitinių reikšmių sudarytos matricos atitinka matricas, apie kurias mokėmės per matematikos kursą universitete. Naudojantis jomis efektyviai sprendžiami tiesinės algebros uždaviniai, pvz., atliekama pagrindinių komponentų ar klasterinė analizės. duomenų lentelė (data.frame) – tai lentelės pavidalo duomenų struktūra (turi eilutes ir stulpelius), kurios visi stulpeliai yra vienodo ilgio. Nuo matricos skiriasi tuo, kad skirtinguose stulpeliuose gali būti skirtingo tipo duomenys, tačiau tame pačiame stulpelyje būna tik to paties tipo duomenys. T. y., duomenų lentelės stulpeliai yra vienodo ilgio (atominiai) vektoriai. Tai pagrindinė duomenų struktūra, su kuria dirbsime šio kurso metu. Pavyzdys. Duomenų lentelė sudaryta iš 3 stulpelių: pirmame studentų ūgiai, antrame – tų pačių studentų plaukų spalvos, trečiame – vėlgi tų pačių studentų matematikos egzamino pažymiai. sąrašas (list) – tai duomenų struktūra, kurios kiekvienas elementas gali būti skirtingo ilgio ir talpinti skirtingo tipo duomenis. Paprasčiausiu atveju kiekvienas elementas yra skirtingo ilgio ir duomenų tipo vektorius. Tačiau bendruoju atveju, kiekvienas sąrašo elementas yra tarsi atskiras konteineris, kuris gali talpinti skirtingas duomenų struktūras (vektorius, matricas, duomenų lenteles ar net kitus sąrašus). Tokiu būdu dažnai mums atsakymus pateikia įvairios „R“ statistinės analizės funkcijos. Pavyzdys. Sąrašas sudarytas iš 3 elementų: tiriamojo vardas, tiriamojo amžius, tiriamojo vaikų vardai. Akivaizdu, kad vardas ir amžius – skirtingi duomenų tipai. O vaikų skaičius skirtingas, todėl šis elementas kiekvieno tiriamojo atveju bus ne vienodo ilgio. Šio kurso metu svarbiausios duomenų struktūros – vektoriai ir duomenų lentelės. 4.6 Klausimai savikontrolei Užduotis 4.17 Kokie skliaustai (apvalieji, laužtiniai, riestiniai ar trikampiai) rašomi po „R“ funkcijų (komandų) pavadinimų? Kokiu simboliu žymimi „R“ kalbos komentarai? Kuo panašios ir kuo skiriasi šios „R“ programos duomenų struktūros: „R“ vektoriai, „R“ matricos, „R“ sąrašai (lists) ir duomenų lentelės (data.frames)? Lyginkite duomenų tipus, kurie gali būti saugomi šiose struktūrose, duomenų išdėstymo būdą bei kur šios struktūros gali būti panaudotos. Kaip apibūdintumėte, kas yra funkcijos argumentas? Kaip programoje „R“ užrašomos loginės reikšmės „tiesa“ ir „netiesa“? Kas yra „R“ konsolė? Ką ji daro? Ką reiškia užrašai 1e4 bei 9e-4? Kaip rekomenduojama rašyti „R“ objektų pavadinimus? Pateikite 2 tokių pavadinimų pavyzdžius. Kur – matricoje ar duomenų lentelėje – gali būti skirtingų tipų (pvz., ir skaičiai, ir faktoriai, ir tekstas) duomenys? Ar duomenų lentelėje visi stulpeliai būtinai privalo būti vienodo ilgio? Kokie „R“ operatoriai atlieka šias operacijas: objekto kūrimas (reikšmės priskyrimas)? Ką „R“ programos kode reiškia simbolis #? Iki kur jis galioja? Nuo kur nebegalioja? Kokie „R“ duomenų tipai yra svarbiausi šiam kursui? Žinokite jų pavadinimus ir lietuvių, ir anglų kalba. Kokios „R“ klasės tinkamos skaitiniams tolydiesiems ir kokios skaitiniams diskretiesiems duomenis? Kokios „R“ klasės tinkamos kategoriniams duomenims? Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["r-paketai.html", "5. R paketai 5.1 Paketų užkrovimas 5.2 RStudio langas Packages 5.3 R paketų saugyklos 5.4 Apie paketų diegimą 5.5 Funkcijų naudojimas neužkrovus paketų 5.6 Plačiau apie paketus Klausimai ir komentarai", " 5. R paketai Įsivaizduokite, kad įsigijote naują mobilųjį telefoną (pav. 5.1). Kas jame įdiegta? Na, galima sakyti, kad jis yra „tuščias“: sistema, pvz., „Android“, tam, kad telefonas veiktų apskritai, bei kelios programėlės, kad galėtumėte paskambinti, parašyti žinutę ar aplankyti interneto tinklalapį. Ką darote? Ogi einate į svetainę, tokią kaip „Google Play“ (ar kitą priklausomai nuo kompanijos, pagaminusios telefoną), ir atsisiunčiate naujausias ir jums patogiausias programėles, taip išplėsdami savo išmaniojo įrenginio galimybes. „R“ – lyg naujas išmanusis telefonas „R“ paketai – tarsi programėlės, kurias galima parsisiųsti Pav. 5.1: Analogija tarp „R“, „R“ paketų ir mobiliojo telefono. Iliustracijos šaltinis: Panašiai yra ir su programa „R“. Pati programa turi tik bazines funkcijas, todėl užima gana nedaug vietos. Šių funkcijų gali ir užtekti. Visgi, kai kurie naudotojai nori labiau jų poreikiams pritaikytos programos. Turbūt nenustebsite, kad ekonomistams, psichologams, biologams ir kitų sričių specialistams reikalingi šiek tiek kitokie statistinės analizės aspektai. Dėl šių priežasčių programos „R“ galimybes galima smarkiai išplėsti papildiniais, kurie vadinami paketais (angl. packages). Tai tarsi programėlės mobiliojo telefono pavyzdyje. Du svarbūs dalykai susiję su „R“ paketais yra diegimas (angl., installation) ir užkrovimas (angl., loading). Dabar juos apžvelgsime. 5.1 Paketų užkrovimas Atidarius „R“, automatiškai užkraunami tik keli pagrindiniai paketai. Visus likusius užsikrauname, kai jų prireikia. (Juk ir įsijungę telefoną atsidarome ne visus „apps’us“ iš karto, o tik tuos, kuriuos tuo metu naudojame). Be to, paketus reikia užkrauti kiekvieną kartą iš naujo įjungus ar perkrovus „R“, nes kai programa išjungiama, išjungiami ir paketai. Paketus užkrauna komanda library(), kurios skliaustuose rašomas dominančio paketo pavadinimas. Alternatyva (kurios nerekomenduoju) – funkcija require(). Taip pat šiam tikslui skirtas „RStudio“ langas „Packages“. 5.2 RStudio langas Packages Programa „RStudio“ turi paketų valdymui (parsisiuntimui iš saugyklos CRAN, užkrovimui, pašalinimui iš kompiuterio ir kt.) skirtą langą. Paketų valdymo principai naudojant programą „RStudio“ pateikti 5.2. Pav. 5.2: Paketų užkrovimas naudojantis „RStudio“. Paaiškinimai tekste. Paveiksle 5.2 pateiktas pavyzdys, kaip naudojantis „RStudio“ surandamas ir užkraunamas paketas dplyr (A, B, C). Pirma, lango „Packages“ (A) paieškos laukelyje (B) surenkame visą ar dalį paketo pavadinimo. Paketų sąrašas susiaurėja. Sąraše rodomi paketų pavadinimai (pvz., dplyr), aprašymas ir versija (pvz., 0.7.3). Ties norimo paketo pavadinimu uždėję varnelę (C), paketą užkrauname (prijungiame) ir galime naudoti jo funkcijas. Šią varnelę nuėmę, paketą atjungiame ir jo funkcijų naudoti nebegalime. Paspaudus mygtuką, pažymėtą „D“, ištuštinamas paieškos laukelis (B). Paspaudus „Update“ (G) saugykloje „CRAN“ ieškoma, ar yra įdiegtų paketų atnaujinimų: jei yra, programa paklausia, kuriuos paketus norite atnaujinti. Jei paketą neseniai įdiegėme ar atnaujinome ir jo sąraše nesimato, sąrašą galime atnaujinti paspaudę mygtuką, pažymėtą „E“. Jei paspausime mygtuką ties „F“, tada paketas bus pašalintas iš kompiuterio visam laikui (na, iki tol, kol įdiegsime iš naujo). Užduotis 5.1 Naudodamiesi „RStudio“ langu „Packages“: Patikrinkite, ar užkrautas paketas base (jei teisingai ieškosite, paketas bus sąrašo apačioje). Patikrinkite, ar įdiegtas paketas tidyverse. Patikrinkite, ar įdiegtas paketas DescTools. 5.3 R paketų saugyklos Pirmą kartą įsidiegus „R“ ir „RStudio“, į kompiuterį įdiegiami tik keli baziniai paketai. Kai prireikia papildomų, juos reikia atsisiųsti atskirai. Kaip ir telefono programėles, paketus užtenka atsisiųsti vieną kartą (nebent norite atnaujinti). Yra kelios pagrindinės „R“ paketų saugyklos: „CRAN“ (Comperhensive R Archive Network) – pagrindinė saugykla, kurioje esantys paketai turi atitikti tam tikrus kokybės standartus. Jose esančios paketų versijos yra stabilios. Iš čia parsisiuntėme „R“. Iš čia paketus siunčiamės dažniausiai. „Bioconductor“ – tai specializuota saugykla bioinformatikos analizei skirtiems „R“ paketams. „GtiHub“ saugyklos, kuriose galima rasti ne tik „R“, bet ir kitų programų papildinių. Čia įprastai saugomos vis dar kuriamos bei tobulinamos (angl. development) „R“ paketų versijos, tad jos įprastai yra naujesnės, nei „CRAN“’e. Bet nebūtinai stabilios (t. y., gali turėti dar neišspręstų problemų). Yra ir kitų saugyklų. 5.4 Apie paketų diegimą Jei paketo jūsų kompiuteryje nėra, tada jį reikia atsisiųsti ir įsidiegti. Yra keletas vietų (saugyklų), iš kur paketai gali būti atsiųsti. Dėl šios priežasties kiekvienai saugyklai turi būti naudojamas vis kitoks kodas. 5.4.1 Diegimas iš CRAN Diegimui iš „CRAN“ naudojama funkcija install.packages(), kurios skliaustuose kabutėse nurodomas dominančio paketo pavadinimas, pvz.: install.packages(&quot;remotes&quot;) Apie paketų diegimą iš „CRAN“ taip pat rašoma skyriuje „1.4 R paketų diegimas“. 5.4.2 Diegimas iš GitHub Jei norime diegti kelis paketus iš karto, juos nurodome kaip tekstinių reikšmių seką (naudojame funkciją c()): install.packages(c(&quot;remotes&quot;, &quot;devtools&quot;)) Norint diegti iš kitur, prieš tai reikia būti atsisiuntus paketą remotes (arba devtools). Tada diegdami, pvz., iš „GtiHub“, naudojame komandą remotes::install_github(). Funkcijos skliaustuose įrašome vartotojo vardą (kurio paketą diegsimės) ir saugyklos pavadinimą tokiu formatu &quot;vartotojas/saugykla&quot;, pvz.: remotes::install_github(&quot;Rapporter/pander&quot;) Šis kodas iš vartotojo Rapporter saugyklos „pander“ parsiunčia paketą pander. Seniau paketų atsiuntimui naudojamos funkcijos buvo pakete devtools. Tačiau kūrėjai jas perkėlė į remotes, o iš šio paketo importuoja į devtools. Tai reiškia, kad tiek naujoji komanda remotes::install_github(), tiek senoji devtools::install_github() veiks. 5.5 Funkcijų naudojimas neužkrovus paketų Norėdami naudoti funkciją neužkrovus paketo arba norėdami programai „R“ nurodyti, kad būtų naudojama funkcija iš konkretaus paketo, jei yra kelios vienodą pavadinimą turinčios funkcijos, naudosime operatorių :: tokiu stiliumi: paketas::funkcija(). Pvz., remotes::install_github(). Dalis šio skyriaus medžiagos kol kas yra paslėpta. –&gt; 5.6 Plačiau apie paketus Išsamesnė informacija apie „R“ paketus pradedantiesiems pateikta straipsnyje „R Packages: A Beginner’s Guide“ . Apie paketų kūrimą rašoma knygoje „R packages“ . Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["teorija-skaitines-suvestines.html", "6. Skaitinės suvestinės (teorija) 6.1 Aprašomoji statistika 6.2 GA parametrai ir imties statistikos 6.3 Aprašomosios statistikos 6.4 Imties dydis – jį privaloma pateikti ataskaitoje 6.5 Kaip statistiškai aprašyti vieno kintamojo reikšmes? 6.6 Kaip pasirinkti tolydiesiems duomenims tinkamas suvestines? 6.7 Kvantiliai ir kvartiliai 6.8 Statistinis dažnis ir dažnių lentelės Klausimai ir komentarai", " 6. Skaitinės suvestinės (teorija) 6.1 Aprašomoji statistika Aprašomoji statistika – yra statistikos mokslo dalis. Jos esmė – atlikti skaitines bei grafines duomenų suvestines, kurios glaustai perteikia esminius duomenų bruožus. 6.2 GA parametrai ir imties statistikos Jeigu atliekant statistinius skaičiavimus naudojami visos generalinės aibės (GA) duomenys, tada rezultatą – apskaičiuotąją GA charakteristiką – vadiname generalinės aibės parametru (pvz., GA vidurkis). Jei analogiškiems skaičiavimams naudojami imties duomenys, tada rezultatą – imties charakteristiką – vadiname imties statistika (pvz., imties vidurkis). Generalinė aibė → parametras. Imtis → statistika. 6.3 Aprašomosios statistikos Imties statistikas galima skirstyti į kelias sąlygines grupes (pav. 6.1): Pav. 6.1: Imties statistikų rūšys. Šiame skyriuje nagrinėsime aprašomąsias statistikas. Aprašomosios statistikos – charakteristikos, skirtos glaustai apibūdinti imties duomenis. Aprašomųjų statistikų pavyzdžių pateikta pav. 6.2. Įverčiai – tai, pagal turimus imties duomenis, geriausias spėjimas, koks yra tikrasis GA parametras (pvz., tikrasis vidurkis). Būna 2 rūšių: taškiniai įverčiai; intervaliniai įverčiai (pvz., pasikliauties intervalai). Statistinių kriterijų statistikos – tai dydžiai, kurių pagalba tikrinamos statistinės hipotezės ir daromos statistinės išvados (pvz., t statistika Stjudento t teste). Pav. 6.2: Aprašomųjų statistikų ir kitų skaitinių suvestinių pavyzdžiai. * – kitos suvestinės. 6.4 Imties dydis – jį privaloma pateikti ataskaitoje Imties dydis – tai statistika, kurią privaloma nurodyti kiekvienoje duomenų analizės ataskaitoje. 6.5 Kaip statistiškai aprašyti vieno kintamojo reikšmes? Prieš atliekant vieno kintamojo suvestines, reikia nustatyti kintamojo duomenų tipą. Panagrinėkime du kraštutinumus – nominaliuosius ir tolydžiuosius duomenis. Šiais atvejais – įprasti tokie pasirinkimai: Kategoriniams nominaliesiems duomenims nurodoma: imties dydis; dažnių lentelės. Tolydiesiems duomenims: imties dydis; duomenų centras (įprastai vidurkis arba mediana); duomenų sklaida (įprastai SD, kvantiliai, MAD arba IQR). Jei duomenys ranginiai arba skaitiniai diskretieji, jiems gali tikti ir tolydžiųjų, ir diskrečiųjų duomenų aprašymo metodai. Įvertinus, į ką – tolydžiuosius ar diskrečiuosius duomenis – konkretus kintamasis panašesnis, parenkamas aprašomosios statistikos metodas. Įprasti pasirinkimai: Ranginiams duomenims: imties dydis; dažnių lentelė; mediana; kiti centrą (pvz., vidurkis) ir sklaidą (pvz., SD) aprašantys dydžiai naudojami tik tada, jei jie turi prasmę. Diskretiesiems skaitiniams duomenims: imties dydis; duomenų centras; duomenų sklaida; dažnių lentelė (įprasta, kai skirtingų reikšmių mažai). 6.6 Kaip pasirinkti tolydiesiems duomenims tinkamas suvestines? Kai jau nustatėme, kad duomenys tolydieji, toliau žiūrime į duomenų pasiskirstymo formą ir įvertiname, ar yra išskirčių. Tokiu būdu nustatome, kokios statistikos geriausiai apibūdina duomenų centrą ir sklaidą (išsidėstymą apie tą centrą): Jei duomenys simetriški ir be ryškių išskirčių, įprastai centrui apibūdinti naudojamas aritmetinis vidurkis ir sklaidai – standartinis nuokrypis (SD). Jei duomenys smarkiai asimetriški arba turi ryškių išskirčių, labiau tinka išskirtims ir nukrypimams atsparios (robastiškos) statistikos: centrui – mediana, sklaidai – kvartiliai, MAD (medianinis absoliutusis nuokrypis nuo medianos), IQR (tarpkvartilinis plotis). Galutinėje ataskaitoje tyrėjo nuožiūra pasirenkamas vienas labiausiai tinkantis centro padėties ir vienas sklaidos aprašymo būdas. Taip pat nurodomas ir imties dydis. Statistiškai aprašant tolydžiuosius duomenis įprasta apibūdinti imties dydį, duomenų centro padėtį ir sklaidą. 6.7 Kvantiliai ir kvartiliai Kvantilis (pažymėkime raide \\(q\\)) – \\(\\beta\\)-tosios eilės kvantilis yra reikšmė, kuri variacinę eilutę dalina į \\(\\beta \\times 100\\) ir \\((1-\\beta) \\times 100\\) procentinių dalių. Čia \\(\\beta\\) yra dalis – skaičius tarp 0 ir 1 \\((0 &lt; \\beta &lt; 1)\\). Atkreipkite dėmesį, kad kvantilis matuojamas tais pačiais matavimo vienetais, kaip ir tiriamieji duomenys: jei matuojame ilgį centimetrais, tai kvantilis yra tam tikras ilgis centimetrais, jei masę kilogramais, tai ir kvantilis bus tam tikra masė kilogramais. Pvz., jei kvantilis \\(q_{\\beta=0.2} = 35 \\mu m\\) (įprastai bus žymimas tiesiog \\(q_{0.2} = 35 \\mu m\\)), tai reiškia, kad 20% mūsų imtyje esančių tiriamųjų yra mažesni už \\(35 \\mu m\\) ir 80% didesni už šį kvantilį. Tai pat pastebėkite, jog skaičius \\(\\beta\\) šalia kvantilio nurodo, kuri imties narių dalis yra mažesnė už kvantilio reikšmę. Kvantilis \\(q_{0.5}\\) yra plačiausiai naudojamas ir turi specialų pavadinimą – mediana \\((Md)\\). Tai skaičius, variacinę eilutę dalinantis į dvi lygias dalis santykiu 50%:50%. Kvartiliai – tai kvantiliai, dalijantys variacinę duomenų eilutę į 4 lygias dalis. Įprastai žymimi \\(Q_1\\), \\(Md\\), \\(Q_3\\). 6.8 Statistinis dažnis ir dažnių lentelės Kintamojo reikšmės dažnis \\(f_i\\) – tai skaičius, nurodantis, kiek kartų reikšmė \\(x_i\\) pasikartojo duomenų eilutėje kinta intervale nuo 0 iki \\(+\\infty\\). Kintamojo reikšmės santykinis dažnis \\(\\frac {f_i}{n}\\) – tai skaičius, nurodantis, kurią duomenų eilutės dalį sudaro reikšmė \\(x_i\\). Įprastai tai skaičius tarp 0 ir 1 \\(\\left(0 \\le \\frac{f_i}{n} \\le 1 \\right)\\). Gali būti išreikštas ir procentais. Čia \\(n\\) – visas elementų skaičius (imties dydis). Kintamojo reikšmių dažnių lentelėse nurodoma, kiek kartų kiekviena diskrečiojo ar kategorinio kintamojo reikšmė pasikartojo. Dažnių lentelės – tai pagrindinės kategorinių duomenų suvestinės. Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["r-vektoriai.html", "7. Darbas su duomenų sekomis 7.1 Specialiosios paskirties žodžiai 7.2 Bendrieji darbo su vektoriais principai 7.3 Darbas su tekstiniais kintamaisiais 7.4 Darbas su kategoriniais kintamaisiais 7.5 Darbas su skaitiniais kintamaisiais 7.6 Darbas su loginiais kintamaisiais Klausimai ir komentarai", " 7. Darbas su duomenų sekomis Skyriaus video medžiaga ir komentarai dėl užduočių („YouTube“ grojaraštis) . Daugelyje situacijų duomenis galima užrašyti ir nagrinėti kaip reikšmių sekas, kurios padeda atsakyti į mums rūpimus duomenų analizės klausimus. Žiūrint griežtai, programoje „R“ yra dviejų rūšių vektoriai: to paties duomenų tipo elementų sekos, vadinamos atominiais vektoriais, ir sąrašai, kurie gali būti sudaryti iš skirtingų tipų elementų. Mūsų kursas orientuotas į pradedančiųjų lygio duomenų analizę, todėl, paprastumo dėlei, vartodami terminą „vektorius“, turėsime omenyje to paties duomenų tipo elementų sekas. Atominis vektorius yra ir pati mažiausia duomenų struktūra programoje: netgi viena reikšmė, tarkim 234, programoje „R“ yra laikoma vektoriumi, susidedančiu iš vieno elemento. Tad šiame skyriuje panagrinėsime darbo su skaitinių, tekstinių ir kitokių duomenų tipų sekomis specifiką: kaip jas sukurti, apibendrinti, atvaizduoti grafiškai, perskaičiuoti ar transformuoti. Tikslas – išmokti parengti analizei ir statistiškai apibendrinti duomenis, pateiktus kaip duomenų sekos. Šio skyriaus uždavinius reikia atlikti iš eilės: dalis uždavinių yra tęstiniai. Reikiami paketai: DescTools, tidyverse (dplyr, tibble, ggplot2, stringr ir kiti). 7.1 Specialiosios paskirties žodžiai „R“ kalboje yra žodžių, kurie atlieka specialiosios paskirties reikšmių vaidmenį (žr. lentelėje 7.1). Programa „RStudio“ juos atpažįsta ir netgi nudažo kita spalva. Lentelė 7.1: „R“ kalbos žodžiai, naudojami kaip specialiosios paskirties reikšmės. Paaiškinimas Žodis Rezultatas „R“ komandų lange Tuščias narys; tam tikrame kontekste reiškia „ištrinti“ NULL NULL Trūkstama reikšmė (trumpinys nuo angl., NA – not available, t.p., missing value) NA NA Negalima skaitinė reikšmė, skaitinė neapibrėžtis (angl., NaN – not a number) NaN NaN (Teigiama) begalybė Inf Inf Neigiama begalybė -Inf -Inf Loginė reikšmė „netiesa“ FALSE FALSE Loginė reikšmė „netiesa“ (sutrumpintai) F FALSE Loginė reikšmė „tiesa“ TRUE TRUE Loginė reikšmė „tiesa“ (sutrumpintai) T TRUE Pavyzdžiai, kaip gaunamos arba užrašomos šios reikšmės: 0/0 # neapibrėžtas skaičius (NaN - not a number) ## [1] NaN log(0) # neapibrėžtumas: labai mažas skaičius ## [1] -Inf 2 &gt; 10 # „2 daugiau už 10“; atsakymas – loginė reikšmė „netiesa“ ## [1] FALSE F # loginė reikšmė „netiesa“ (sutrumpintai) ## [1] FALSE 6 != 7 # „6 nelygu 7“; atsakymas – loginė reikšmė „tiesa“ ## [1] TRUE T # loginė reikšmė „tiesa“ (sutrumpintai) ## [1] TRUE NULL ## NULL Užduotis 7.1 Funkcijos, kurios prasideda žodžiu is, įprastai atlieka patikrinimą ir pateikia atsakymą TRUE arba FALSE. Pvz., is.na() tikrina, ar reikšmė yra trūkstama, is.nan() – ar tai negalima skaitinė reikšmė. Įvykdykite komandas is.na(NA), is.na(NaN), is.nan(NA), is.nan(NaN) ir padarykite išvadas: ar NaN yra praleistos reikšmės tipas; ar NA yra negalimos skaitinės reikšmės tipas. 7.2 Bendrieji darbo su vektoriais principai 7.2.1 Vektoriaus kūrimas „R“ vektorius statistikoje atitinka duomenų seką, dar vadinamą duomenų eilute. Kelios reikšmės į vektorių (t. y., į seką) sujungiamos naudojant komandą c() (c nuo žodžio combine arba concatenate). Reikšmės rašomos komandos skliausteliuose ir atskiriamos kableliais (,), pvz.: c(6, 23, 33, 19) ## [1] 6 23 33 19 Jei tuos pačius skaičius parašysime „R“ konsolėje be komandos c(), „R“ pamanys, kad tai atskiri niekaip nesusiję elementai, nesupras, ką su jais norime daryti, ir praneš, kad tai klaida (Error): 6, 23, 33, 19 ## Error: &lt;text&gt;:1:2: unexpected &#39;,&#39; ## 1: 6, ## ^ Komanda c() į vektorių gali sujungti ne tik skaičius, bet ir kitokios rūšies duomenų reikšmes: tekstinius kintamuosius: c(&quot;Man&quot;, &quot;puikiai&quot;, &quot;sekasi&quot;, &quot;.&quot;) ## [1] &quot;Man&quot; &quot;puikiai&quot; &quot;sekasi&quot; &quot;.&quot; logines reikšmes (angliškai vadinamos „logical“ arba „boolean“): c(TRUE, FALSE, FALSE, TRUE, TRUE) ## [1] TRUE FALSE FALSE TRUE TRUE ir kitus. Programoje „R“ kuriant vektorius, skirtingi skaičiai ar kitokio tipo reikšmės atskiriamos kableliu. O skaičių sveikoji ir dešimtoji dalys – tašku. Vektorių galime išsaugoti „R“ atmintyje kaip objektą, naudodami priskyrimo operatorių. vektorius &lt;- c(11, 20, 33, 45) Tada jį atspausdinti neišreikštuoju būdu (angl. implicit printing) – tiesiog parašomas objekto pavadinimas: vektorius ## [1] 11 20 33 45 Jei visą kodo eilutę papildomai apskliaudžiame, rezultatas įprastai taip pat būna atspausdinamas: (vektorius &lt;- c(11, 20, 33, 45)) ## [1] 11 20 33 45 Arba išreikštai (angl. explicit printing) – naudojama funkcija print()): print(vektorius) ## [1] 11 20 33 45 Yra ir kitų būdų kurti vektorius. Jie įprastai yra specifiški tam tikram duomenų tipui. Juos aptarsime vėliau. Užduotis 7.2 Sukurkite vektorių iš pateiktų skaičių ir pavadinkite jį seka_1: 1; 10; 100; 1000; 10000. Vektorių atspausdinkite. Duoti kelių merginų ūgiai metrais. Pateikite juos kaip duomenų seką merginu_ugiai ir atspausdinkite neišreikštuoju būdu. Merginų ūgiai (m). 1,67 1,56 1,66 1,59 1,77 1,71 1,69 1,66 1,68 1,55 1,70 1,72 Skirtingų tipų duomenys vienoje sekoje? Kas atsitiks, jei į vieną seką bandysime sudėti kelių tipų duomenis? „R“ visus elementus pavers į tokį tipą, kuriuo gali būti reprezentuojamos visos reikšmės. Deja, įprastai rezultatas bus netikėtas (ir tikrai ne maloniąja prasme). Atsargiai – į vieną seką sujungus skirtingus duomenų tipus rezultatas bus netikėtas! Imkime loginę reikšmę TRUE. Šiame pavyzdyje visos reikšmės bus paverstos į skaičius (TRUE → 1): c(TRUE, 1, 0, 1) ## [1] 1 1 0 1 O šiame – į tekstą (TRUE → &quot;TRUE&quot;): c(TRUE, 15, .30, &quot;mama&quot;) ## [1] &quot;TRUE&quot; &quot;15&quot; &quot;0.3&quot; &quot;mama&quot; Dar keistesnių dalykų įvyksta dirbant su sudėtiniais duomenų tipais, pvz., faktoriais. Yra tam tikros taisyklės, ką ir kokiais atvejais „R“ padaro. Tačiau pradedantiesiems, nežinantiems šių taisyklių, skirtingų tipų duomenų jungimo į vektorių rekomenduoju vengti. Užduotis 7.3 Naudodami funkciją class(), patikrinkite, kokiam duomenų tipui („R“ klasei) priklauso sekos c(TRUE, 1, 0, 1) bei c(TRUE, 15, .30, &quot;mama&quot;). 7.2.2 Vektoriaus savybių tikrinimas Aptarsime tik kelias funkcijas, skirtas vektoriaus savybių tikrinimui: length() – elementų skaičius; class() – „R“ klasė; str() ir tibble::glimpse() – struktūra; attributes() – atributai. Funkcija length() pateikia vektoriaus ilgį, t. y., suskaičiuoja, iš kelių elementų sudarytas vektorius. Ji bus naudinga, kai turėdami į vektorių surašytas reikšmes norėsime apskaičiuoti imties dydį, įprastai žymimą raide „n“: vektorius_2 &lt;- c(11, NA, 33, 45) n &lt;- length(vektorius_2) # Apskaičiuojame ir priskiriame n # Atspausdiname ## [1] 4 Atkreipkite dėmesį į tai, kad skaičiuojamos ir trūkstamos reikšmės. Bet kokio „R“ objekto, taip pat ir vektoriaus, klasę parodo funkcija class(): class(vektorius_2) ## [1] &quot;numeric&quot; Mums reiktų žinoti svarbiausius duomenų tipus atitinkančias klases: numeric; integer; character; factor; ordered; logical. Apie statistikoje naudojamus duomenų tipus rašoma skyriuje „2.5 Kintamųjų tipai statistikoje“. Apie programoje „R“ naudojamus – skyriuje „4.4 Svarbiausi R duomenų tipai“. Vektoriaus struktūrą galime peržiūrėti naudodami funkciją str(): str(vektorius_2) ## num [1:4] 11 NA 33 45 Arba glimpse() iš paketo tibble() (apie šią funkciją plačiau bus rašoma temoje apie duomenų lenteles): tibble::glimpse(vektorius_2) ## num [1:4] 11 NA 33 45 Vektoriams ši funkcija pateikia sutrumpintą „R“ duomenų tipo („R“ klasės) pavadinimą, vektoriaus ilgį (elementų skaičių) ir kelias pirmąsias reikšmes. Pavyzdyje tai: num – numeric – skaitinis duomenų tipas; [1:4] – 4 elementai (nuo 1 iki 4); toliau – 11 NA 33 ir t.t. – kelios pirmosios reikšmės. Vektoriaus savybes, vadinamas atributais, galima peržiūrėti naudojant funkciją attributes(). Atsakymas NULL rodo, kad objektas atributų neturi: attributes(vektorius_2) ## NULL Kategoriniai kintamieji turi atributą, pavadinimu levels – kategorijų pavadinimus. Užduotis 7.4 Apskaičiuokite anksčiau sukurto vektoriaus seka_1 ilgį. Programoje „R“ yra apibrėžtas kintamasis letters, kuriame surašytos mažosios angliškos abėcėlės raidės. Konsolėje atspausdinkite šį kintamąjį, parašydami letters; Naudodami komandas length() ir str() ištirkite: kiek raidžių yra angliškoje abėcėlėje? koks kintamojo tipas – skaitinis (num) ar kitoks? Ištirtos 5 gėlės ir duomenys apie jas pateikti po šio uždavinio sąlyga duomenų sekų pavidalu. Kiekvieną iš gėlės savybių (lapu_ilgis ir kt.) ištirkite naudodami funkcijas class(), str() ir attributes() (įvertinkite kiek ir kokių atributų yra). # Duomenys apie gėles lapu_ilgis &lt;- c(1.3, NA, 2.2, 1.1, 1.6) lapu_skaicius &lt;- c(24L, 22L, 28L, 25L, 25L) ziedu_spalva &lt;- factor(c(&quot;raudona&quot;, &quot;geltona&quot;, &quot;geltona&quot;, &quot;balta&quot;, &quot;balta&quot;)) kvapo_stiprumas &lt;- ordered(c(&quot;silpnas&quot;, &quot;vidutinis&quot;, &quot;stiprus&quot;, &quot;stiprus&quot;, NA)) ar_augo_lauke &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) komentaras &lt;- c(&quot;-&quot;, &quot;-&quot;, &quot;tirta ryte&quot;, &quot;-&quot;, &quot;-&quot;) 7.2.3 Vektoriaus elementų pasirinkimas Ši potemė yra susijusi su skyriumi „Elementų eilės numerių žymėjimas: [ ]“, nes norėdami pasirinkti tam tikrus vektoriaus elementus (sukurti elementų poaibį, angl. subset), galime naudoti viengubų laužtinių skliaustų operatorių []. Skliaustuose nurodomas teigiamas arba neigiamas skaitinis elemento indeksas (eilės numeris), loginis indeksas arba pavadinimas (jei elementas jį turi). Pasirinkimas pagal elemento pavadinimą Iliustracijai naudokime vektorių merginu_ugiai: merginu_ugiai ## [1] 1.67 1.56 1.66 1.59 1.77 1.71 1.69 1.66 1.68 1.55 1.70 1.72 Jei elementai turi pavadinimus, juos galime pasirinkti kabutėse nurodydami šiuos pavadinimus. Naudojant [], elementų pavadinimus reikia pateikti kabutėse. Sakykime, turime seką su merginų vardais. Naudodamiesi jais, suteikiame reikšmėms pavadinimus. O prieš tai nusistatykime lietuviškąją lokalę, kad galėtume naudoti lietuviškas raides: Sys.setlocale(locale = &quot;Lithuanian&quot;) # Lietuviška lokalė Windows sistemai vardai &lt;- c(&quot;Inga&quot;, &quot;Greta&quot;, &quot;Jonė&quot;, &quot;Justė&quot;, &quot;Raimonda&quot;, &quot;Laura&quot;, &quot;Žaneta&quot;, &quot;Ingrida&quot;, &quot;Kristina&quot;, &quot;Toma&quot;, &quot;Rima&quot;, &quot;Sandra&quot;) names(merginu_ugiai) &lt;- vardai # Suteikiami pavadinimai merginu_ugiai ## Inga Greta Jonė Justė Raimonda Laura Žaneta Ingrida ## 1.67 1.56 1.66 1.59 1.77 1.71 1.69 1.66 ## Kristina Toma Rima Sandra ## 1.68 1.55 1.70 1.72 Vienoje eilutėje pateiktas elemento pavadinimas (šiuo atveju, merginos vardas), kitoje – elemento reikšmė (šiuo atveju, ūgis). Dabar ūgius galime sužinoti pagal vardus: merginu_ugiai[&quot;Jonė&quot;] ## Jonė ## 1.66 merginu_ugiai[c(&quot;Jonė&quot;, &quot;Laura&quot;, &quot;Toma&quot;)] ## Jonė Laura Toma ## 1.66 1.71 1.55 Užduotis 7.5 Programoje „R“ yra pavyzdiniai duomenys state.name ir state.area. Pirmajame vektoriuje – JAV valstijų pavadinimai, antrajame – tų valstijų užimamas plotas kvadratinėmis myliomis. Parašykite kodą, kuris atsakytų į klausimus: Atspausdinkite state.area ir state.name reikšmes. Kelių valstijų duomenys pateikti? Pagal pavyzdį, valstijų plotams suteikite pavadinimus. Tada sudarykite vektorių, kuriame būtų tik šių 4 valstijų plotai: Arizona, New Jersey, Texas, Utah. Teigiami skaitiniai indeksai Norėdami pasirinkti elementą, nurodome teigiamą jo indeksą. Programoje „R“ elementų numeravimas (indeksavimas) prasideda nuo 1. Tarkime, mus domina antrasis elementas: merginu_ugiai[2] ## Greta ## 1.56 Pasirinkime antrą ir ketvirtą (atkreipkite dėmesį į tai, kad nurodant indeksus bus panaudota funkcija c()): merginu_ugiai[c(2, 4)] ## Greta Justė ## 1.56 1.59 Dar keli pavyzdžiai: (skaiciu_seka &lt;- 1:10) ## [1] 1 2 3 4 5 6 7 8 9 10 skaiciu_seka[2] ## [1] 2 skaiciu_seka[c(2, 4)] ## [1] 2 4 Užduotis 7.6 Naudodami kintamąjį letters atlikite užduotis (parašykite programos kodą): Nurodykite, kokia 16-toji abėcėlės raidė; Nurodykite, kokios yra 6, 11, 18 ir 20 abėcėlės raidės. Neigiami skaitiniai indeksai Neigiami skaitiniai indeksai panaikina nurodytuosius elementus. Prieš indeksą padedamas „minus“ (-) ženklas: merginu_ugiai[-2] ## Inga Jonė Justė Raimonda Laura Žaneta Ingrida Kristina ## 1.67 1.66 1.59 1.77 1.71 1.69 1.66 1.68 ## Toma Rima Sandra ## 1.55 1.70 1.72 merginu_ugiai[-c(2, 4, 9, 10, 11)] ## Inga Jonė Raimonda Laura Žaneta Ingrida Sandra ## 1.67 1.66 1.77 1.71 1.69 1.66 1.72 Norėdami panaikinti paskutinį elementą, galime naudoti tokį kodą: n &lt;- length(merginu_ugiai) merginu_ugiai[-n] ## Inga Greta Jonė Justė Raimonda Laura Žaneta Ingrida ## 1.67 1.56 1.66 1.59 1.77 1.71 1.69 1.66 ## Kristina Toma Rima ## 1.68 1.55 1.70 Čia n yra elementų skaičius, atitinkantis paskutinio elemento eilės numerį: 12. Dar keli pavyzdžiai: skaiciu_seka ## [1] 1 2 3 4 5 6 7 8 9 10 skaiciu_seka[-2] ## [1] 1 3 4 5 6 7 8 9 10 skaiciu_seka[-c(2, 4, 9, 10)] ## [1] 1 3 5 6 7 8 n2 &lt;- length(skaiciu_seka) skaiciu_seka[-n2] ## [1] 1 2 3 4 5 6 7 8 9 Užduotis 7.7 Naudodami kintamąjį letters atlikite užduotis (parašykite programos kodą): Pašalinkite 16-tąją abėcėlės raidę; Pašalinkite 6, 11, 18 ir 20 abėcėlės raides. Pasirinkimas pagal sąlygas (loginį indeksą) Kuriant poaibius pagal loginį indeksą pasirenkami tik tie elementai, kuriems loginis indeksas yra TRUE (pav. 7.1). Nagrinėjant šią temą naudinga žinoti, kaip atliekamos pagrindinės palyginimo operacijos (žr. skyriuje „7.6.1 Palyginimo operacijos“). Pav. 7.1: Loginiai indeksai poaibiams kurti: pasirenkami tik tie elementai, kuriems indeksas yra TRUE. Iliustracijos šaltinis: . Sakykime, mus domina tų gėlių, kurios augo lauke, lapų skaičius. ar_augo_lauke ## [1] FALSE TRUE TRUE FALSE TRUE lapu_skaicius ## [1] 24 22 28 25 25 Tada naudojame tokį užrašą: lapu_skaicius[ar_augo_lauke] ## [1] 22 28 25 Be to, abu vektoriai turi būti vienodo ilgio: length(ar_augo_lauke) == length(lapu_skaicius) # palyginimui naudojame ==, o ne = ## [1] TRUE Dabar sakykime, kad mus domina geltonų gėlių lapų skaičius. ziedu_spalva ## [1] raudona geltona geltona balta balta ## Levels: balta geltona raudona Atlikę palyginimo operaciją, sužinome, kurios gėlės yra geltonos: ziedu_spalva == &quot;geltona&quot; # TRUE, jei geltona ## [1] FALSE TRUE TRUE FALSE FALSE Palyginimo rezultatą galime išsaugoti kaip objektą, ir jį naudoti reikiamų elementų pasirinkimui net kelis kartus: ar_geltona &lt;- ziedu_spalva == &quot;geltona&quot; lapu_skaicius[ar_geltona] ## [1] 22 28 lapu_ilgis[ar_geltona] ## [1] NA 2.2 Arba palyginimo operaciją galime įrašyti tiesiai tarp laužtinių skliaustų: lapu_skaicius[ziedu_spalva == &quot;geltona&quot;] # palyginimui naudojame ==, o ne = ## [1] 22 28 Dar keli pavyzdžiai: skaiciu_seka[skaiciu_seka &lt; 5] ## [1] 1 2 3 4 skaiciu_seka[skaiciu_seka == 5] ## [1] 5 is.na(skaiciu_seka) # Tikrinimas kiekvienam elementui atskirai ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE !is.na(skaiciu_seka) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE Užduotis 7.8 Naudokite uždavinio 7.4 duomenis apie gėles. Parodykite, kiek lapų (lapu_skaicius) turėjo gėlės, kurių kvapas buvo stiprus (kvapo_stiprumas). Nenustebkite, jei atsakyme atsiras reikšmė NA. Funkcija !is.na() tikrina, kurios reikšmės yra netrūkstamos (! reiškia NE). Naudodami šią funkciją pasirinkite tik tas gėlių spalvas (ziedu_spalva), jei toms gėlėms yra žinomas lapų ilgis (lapu_ilgis). Naudodami duomenis state.name ir state.area parašykite kodą, kuris atsakytų į klausimus: Išvardinkite valstijas, kurių plotas mažesnis už 10000 kvadratinių mylių (pavadinkime jas „mažomis valstijomis“? Koks mažų valstijų skaičius? Kai kurie atsakymai pasitikrinimui (jums reikia pateikti sprendimus): ## [1] 28 25 NA ## [1] raudona geltona balta balta ## Levels: balta geltona raudona ## [1] &quot;Connecticut&quot; &quot;Delaware&quot; &quot;Hawaii&quot; &quot;Massachusetts&quot; ## [5] &quot;New Hampshire&quot; &quot;New Jersey&quot; &quot;Rhode Island&quot; &quot;Vermont&quot; Specializuotos funkcijos elementams pasirinkti Norėdami pasirinkti kelis pirmuosius elementus, galime naudoti funkciją head(), kurios argumentas n nurodo, kiek pirmųjų elementų pasirinkti: head(merginu_ugiai, n = 2) # palieka pirmus 2 elementus ## Inga Greta ## 1.67 1.56 Jei reikia pašalinti kelis paskutinius elementus (ir rodyti pirmuosius), naudojame neigiamą indeksą: head(merginu_ugiai, n = -8) # pašalina 8 paskutinius elementus ## Inga Greta Jonė Justė ## 1.67 1.56 1.66 1.59 Analogiškai funkcija tail() parodo paskutiniuosius elementus: tail(merginu_ugiai, n = 3) # palieka 3 paskutinius elementus ## Toma Rima Sandra ## 1.55 1.70 1.72 Arba pašalina pirmuosius (kad būtų rodomi tik paskutiniai): tail(merginu_ugiai, n = -7) # pašalina 7 pirmuosius elementus ## Ingrida Kristina Toma Rima Sandra ## 1.66 1.68 1.55 1.70 1.72 Jei pasirinktus elementus norėsime naudoti toliau, juos priskiriame naujam objektui, pvz.: ugiai2 &lt;- head(merginu_ugiai, n = 5) ugiai2_be_vardu &lt;- unname(ugiai2) # pašalina pavadinimus ugiai2_be_vardu ## [1] 1.67 1.56 1.66 1.59 1.77 Funkcijos head() ir tail() bus naudingos dirbant su duomenų lentelėmis: jos parodys pirmąsias ir paskutines lentelės eilutes. Dar keli pavyzdžiai: skaiciu_seka ## [1] 1 2 3 4 5 6 7 8 9 10 head(skaiciu_seka, n = 2) ## [1] 1 2 head(skaiciu_seka, n = -2) ## [1] 1 2 3 4 5 6 7 8 tail(skaiciu_seka, n = 2) ## [1] 9 10 tail(skaiciu_seka, n = -2) ## [1] 3 4 5 6 7 8 9 10 Užduotis 7.9 Naudodami kintamąjį letters atlikite užduotis (parašykite programos kodą): Atspausdinkite 10 paskutiniųjų angliškos abėcėlės raidžių; Pašalinkite 10 paskutiniųjų angliškos abėcėlės raidžių; Atspausdinkite visas raides, išskyrus pirmą ir paskutinę. 7.2.4 Vektoriaus elementų reikšmių pakeitimas Vektoriaus reikšmėms pakeisti naudojama operatorių [] ir &lt;- kombinacija. Pasidarykime objekto kopiją, su kuria dirbsime: ugiai3 &lt;- ugiai2 Galima keisti vieną ar kelias reikšmes naudojant indeksą (eilės numerį): ugiai3[1] &lt;- 1.90 ugiai3 ## Inga Greta Jonė Justė Raimonda ## 1.90 1.56 1.66 1.59 1.77 ugiai3[c(1, 3)] &lt;- c(2.00, 2.10) ugiai3 ## Inga Greta Jonė Justė Raimonda ## 2.00 1.56 2.10 1.59 1.77 Keitimas pagal loginę sąlygą: ugiai3[ugiai3 &lt; 1.60] &lt;- NA ugiai3 ## Inga Greta Jonė Justė Raimonda ## 2.00 NA 2.10 NA 1.77 Keitimas pagal pavadinimą: ugiai3[&quot;Raimonda&quot;] &lt;- 1.00 ugiai3 ## Inga Greta Jonė Justė Raimonda ## 2.0 NA 2.1 NA 1.0 Užduotis 7.10 Sudarykite „R“ vektorių, tada visas neigiamas reikšmes duomenų sekoje pakeiskite nuliais: -0.54 0.45 -1.07 0.75 0.88 -0.99 1.24 0.73 0.13 -0.10 7.2.5 Vektorizuotos operacijos Daugelis operacijų programoje „R“ yra vektorizuotos. T. y., parašius funkciją ar komandą, perskaičiavimas atliekamas kiekvienam elementui atskirai papildomai nerašant sudėtingesnio programos kodo, tokio kaip ciklas (angl., loop). Tai didelis privalumas, supaprastinantis darbą šia programa. Aritmetiniai (pvz., +, -), palyginimo (pvz., &lt;, &gt;) operatoriai veikia vektorizuotai. Iliustracijai imkime praeituose skyreliuose sukurtus objektus vektorius ir vektorius_2. vektorius ## [1] 11 20 33 45 vektorius_2 ## [1] 11 NA 33 45 Prie kiekvieno vektoriaus elemento pridėkime po 100: vektorius + 100 # atitinka c(11 + 100, 20 + 100, 33 + 100, 45 + 100) ## [1] 111 120 133 145 Palyginkime, ar reikšmės mažesnės už 21: vektorius &lt; 21 # atitinka c(11 &lt; 21, 20 &lt; 21, 33 &lt; 21, 45 &lt; 21) ## [1] TRUE TRUE FALSE FALSE Sudėkime kelių vienodo ilgio vektorių pirmuosius, antruosius, trečiuosius ir t.t. elementus: vektorius + vektorius_2 # atitinka c(11 + 11, 20 + NA, 33 + 33, 45 + 45) ## [1] 22 NA 66 90 Jei dirbame su keliais vektoriais ir vienas iš jų yra trumpesnis, trumpesniojo reikšmės cikliškai naudojamos iš naujo: vektorius + c(0, 10000) # atitinka c(11 + 0, 20 + 10000, 33 + 0, 45 + 10000) ## [1] 11 10020 33 10045 Toks elgesys dažnai yra nepageidautinas, tad būkite atidūs. Laimei, kai kurios funkcijos, kurias naudosime dirbdami su duomenų lentelėmis kitų užsiėmimų metu, apskritai stabdo skaičiavimus, jei keli vektoriai yra skirtingo ilgio, ir taip apsaugo nuo netikėtų rezultatų. Kai kurios funkcijos taip pat atlieka veiksmus su kiekvienu elementu atskirai, pvz., logaritmuoja: log(vektorius) # atitinka c(log(11), log(20), log(33), log(45)) ## [1] 2.397895 2.995732 3.496508 3.806662 Arba tikrina, kurios reikšmės yra trūkstamos (žymimos simboliu NA): is.na(vektorius_2) ## [1] FALSE TRUE FALSE FALSE Jei galite rinktis tarp vektorizuotos ir nevektorizuotos (pvz., savo pačių parašytos) funkcijos, žinokite, kad didelė tikimybė, jog pirmoji veiks efektyviau, nes yra kruopščiai parašyta, išbandyta ir optimizuota. Užduotis 7.11 Uždaviniuose 7.2 ir 7.3 buvo sukurti keli vektoriai, kuriuos dabar ir panaudosime. Vektorius merginu_ugiai: Apskaičiuokite, kiek merginų dalyvavo apklausoje. Pasirodo, visos merginos buvo apsiavusios aukštakulniais, ūgį padidinančiais 4 cm. Perskaičiuokite, koks tikrasis kiekvienos merginos ūgis. Rezultatą priskirkite kintamajam tikrieji_merginu_ugiai. Programoje „R“ dešimtainį logaritmą skaičiuoja funkcija log10(), pvz., log10(16). Šio tipo logaritmavimą atlikite kiekvienam vektoriaus seka_1 elementui. 7.3 Darbas su tekstiniais kintamaisiais Tekstiniai kintamieji – tai ne statistinis duomenų tipas. Jis reikalingas, pvz., užrašyti grafikų pavadinimus. Programoje „R“ tekstinius duomenis atitinka klasė „character“ (sutrumpintai chr). Darbui su tekstiniais kintamaisiais galime naudoti bazines arba paketo stringr funkcijas. Darbui su tekstiniais kintamaisiais skirtas specializuotas paketas stringr . Visos svarbiausios paketo stringr funkcijos prasideda str_, todėl paprasta prisiminti. str yra trumpinys nuo kompiuterinio termino „string“ – teksto eilutė. Duomenyse bus lietuviškų simbolių, todėl įsijunkime lietuviškąją lokalę. Sys.setlocale(locale = &quot;Lithuanian&quot;) # Lietuviška lokalė Windows sistemai Tekstinės reikšmės sudaromos naudojant funkciją c() ir kabutes. Skirtingos reikšmės atskiriamos kableliais. miestai &lt;- c(&quot;Vilnius&quot;, &quot;Kaunas&quot;, &quot;Klaipėda&quot;) miestai ## [1] &quot;Vilnius&quot; &quot;Kaunas&quot; &quot;Klaipėda&quot; Naudodami is.character() patikriname, ar vektorius yra tekstinis, o as.character() vektorių paverčia į tekstinį: is.character(miestai) ## [1] TRUE skaiciai &lt;- 1:5 skaiciai ## [1] 1 2 3 4 5 is.character(skaiciai) ## [1] FALSE skaiciai_chr &lt;- as.character(skaiciai) skaiciai_chr ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; is.character(skaiciai_chr) ## [1] TRUE Žodžiu is prasidedančios funkcijos tikrina, o žodžiu as – keičia duomenų tipą ar kitą savybę. Galime palyginti, ar kelios reikšmės yra vienodos: &quot;A&quot; == &quot;B&quot; ## [1] FALSE &quot;A&quot; == &quot;a&quot; ## [1] FALSE Taip pat ar reikšmė priklauso pogrupiui: &quot;Vilnius&quot; %in% miestai ## [1] TRUE &quot;A&quot; %in% miestai ## [1] FALSE Funkcijos paste() ir paste0() sujungia kelias reikšmes į vieną. paste(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) ## [1] &quot;A B C&quot; paste0(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) ## [1] &quot;ABC&quot; Gali būti pasirenkamas norimas skirtumas nurodant sep: paste(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, sep = &quot;, &quot;) ## [1] &quot;A, B, C&quot; Funkcija paste0() atitinka paste(sep = &quot;&quot;). Veikia vektorizuotai: vardas &lt;- c(&quot;Jonas&quot;, &quot;Ona&quot;, &quot;Gytis&quot;) kreipinys &lt;- c(&quot;ponas&quot;, &quot;panelė&quot;, &quot;ponaitis&quot;) vardas_ir_kreipinys &lt;- paste(kreipinys, vardas) vardas_ir_kreipinys ## [1] &quot;ponas Jonas&quot; &quot;panelė Ona&quot; &quot;ponaitis Gytis&quot; Jei visas reikšmes norime sujungti į vieną eilutę, papildomai naudojama collapse ir nurodome skirtuką: paste(kreipinys, vardas, collapse = &quot;, &quot;) ## [1] &quot;ponas Jonas, panelė Ona, ponaitis Gytis&quot; Kaip alternatyva funkcijai paste(), gali būti naudojama stringr::str_c() (reikalingas paketas stringr). Įprastai str_c() duoda labiau prognozuojamus rezultatus, kai tekstinių reikšmių vektoriuje yra praleistų reikšmių (NA). stringr::str_c(kreipinys, vardas) ## [1] &quot;ponasJonas&quot; &quot;panelėOna&quot; &quot;ponaitisGytis&quot; stringr::str_c(kreipinys, vardas, sep = &quot; &quot;) ## [1] &quot;ponas Jonas&quot; &quot;panelė Ona&quot; &quot;ponaitis Gytis&quot; stringr::str_c(kreipinys, vardas, collapse = &quot;, &quot;) ## [1] &quot;ponasJonas, panelėOna, ponaitisGytis&quot; stringr::str_c(kreipinys, vardas, sep = &quot; &quot;, collapse = &quot;, &quot;) ## [1] &quot;ponas Jonas, panelė Ona, ponaitis Gytis&quot; Kiekvienos tekstinės reikšmės simbolių skaičių pasako nchar() arba stringr::str_length(): nchar(vardas_ir_kreipinys) ## [1] 11 10 14 stringr::str_length(vardas_ir_kreipinys) ## [1] 11 10 14 Naudojant stringr::str_sort() tekstines reikšmes galima išdėlioti eilės tvarka: Nurodant locale ir dviženklį kalbos kodą (pvz., &quot;lt&quot;) galima išdėlioti abėcėlės tvarka. Nurodant numeric = TRUE – kaip skaičius. raidės &lt;- c(&quot;Z&quot;, &quot;J&quot;, &quot;Y&quot;, &quot;K&quot;) stringr::str_sort(raidės, locale = &quot;lt&quot;) ## [1] &quot;Y&quot; &quot;J&quot; &quot;K&quot; &quot;Z&quot; stringr::str_sort(raidės, locale = &quot;en&quot;) ## [1] &quot;J&quot; &quot;K&quot; &quot;Y&quot; &quot;Z&quot; skaiciai_chr_2 &lt;- c(&quot;20&quot;, &quot;5&quot;, &quot;10&quot;, &quot;150&quot;, &quot;12&quot;, &quot;1&quot;) stringr::str_sort(skaiciai_chr_2) ## [1] &quot;1&quot; &quot;10&quot; &quot;12&quot; &quot;150&quot; &quot;20&quot; &quot;5&quot; stringr::str_sort(skaiciai_chr_2, numeric = TRUE) ## [1] &quot;1&quot; &quot;5&quot; &quot;10&quot; &quot;12&quot; &quot;20&quot; &quot;150&quot; Funkcija stringr::str_order() parodo išdėliojimo eilės tvarką (naudojama analogiškai kaip str_sort()): stringr::str_order(raidės, locale = &quot;en&quot;) ## [1] 2 4 3 1 Funkcija dplyr::recode() perkoduoja reikšmes pagal šabloną senoji_reikšmė = naujoji_reikšmė: dplyr::recode(kreipinys, &quot;ponas&quot; = &quot;Mr.&quot;, &quot;panelė&quot; = &quot;Miss.&quot;) ## [1] &quot;Mr.&quot; &quot;Miss.&quot; &quot;ponaitis&quot; Taip pat gali būti naudingos funkcijos: stringr::str_to_lower(vardas_ir_kreipinys) # visos mažosios ## [1] &quot;ponas jonas&quot; &quot;panelė ona&quot; &quot;ponaitis gytis&quot; stringr::str_to_upper(vardas_ir_kreipinys) # visos didžiosios ## [1] &quot;PONAS JONAS&quot; &quot;PANELĖ ONA&quot; &quot;PONAITIS GYTIS&quot; stringr::str_to_title(vardas_ir_kreipinys) # pirma didžioji ## [1] &quot;Ponas Jonas&quot; &quot;Panelė Ona&quot; &quot;Ponaitis Gytis&quot; make.names(vardas_ir_kreipinys) # paverčia į leistinus „R“ objektų pavadinimus ## [1] &quot;ponas.Jonas&quot; &quot;panelė.Ona&quot; &quot;ponaitis.Gytis&quot; Kitus duomenų tipus galime paversti į tekstą naudodami as.character(), norimu pavidalu suformatuodami skaičius (žr. „7.5.5 Skaičių formatavimas“) ar kitaip sudarydami teksto eilutes. Įprastai į tekstą paverstus duomenis galima tvarkingiau pateikti lentelėse bei ataskaitose, nei, pvz., suapvalintus, bet nesuformatuotus skaičius. Visgi tekstiniams kintamiesiems statistinė analizė neatliekama. Prieš tai jie turi būti paversti į kategorinius. Kai kurios funkcijos tekstą automatiškai atpažįsta kaip faktorius (tik kategorijas gali išrikiuoti nelogiška tvarka). Kitais atvejais pakeitimą privalu atlikti „rankiniu būdu“ naudojant as.factor() ar analogiškas funkcijas (žr., „7.4.1 Faktorių kūrimas“). Praktinis patarimas: dirbdami prisiminkite, kad jei norite pakeisti/atnaujinti objekto reikšmes, reikia naudoti &lt;- arba =: raidės ## [1] &quot;Z&quot; &quot;J&quot; &quot;Y&quot; &quot;K&quot; (raidės &lt;- stringr::str_sort(raidės, locale = &quot;lt&quot;)) ## [1] &quot;Y&quot; &quot;J&quot; &quot;K&quot; &quot;Z&quot; (raidės &lt;- dplyr::recode(raidės, &quot;Y&quot; = &quot;i&quot;, &quot;K&quot; = &quot;25&quot;)) ## [1] &quot;i&quot; &quot;J&quot; &quot;25&quot; &quot;Z&quot; raidės &lt;- stringr::str_c(raidės, collapse = &quot; + &quot;) raidės ## [1] &quot;i + J + 25 + Z&quot; Užduotis 7.12 Duota seka vardai_2 &lt;- c(&quot;G&quot;, &quot;J&quot;, &quot;G&quot;, &quot;A&quot;, &quot;Y&quot;, &quot;G&quot;). Tai pirmosios vardų „Gytis“, „Jonas“ ir „Aistis“ raidės. Atlikite užduotis: atsakymai, kurių tikimasi, pateikti žemiau. Išrikiuokite raides pagal lietuvių kalbos abėcėlę. Pašalinkite raidę „Y“. Perkoduokite į vardus. Suskaičiuokite, kokio ilgio kiekvienas vardas. Prieš kiekvieną vardą pridėkite „p. “. Kiekvieną pirmąją raidę paverskite į didžiąją. Visus vardus (su prierašu „p. “) atskyrę kableliais sujunkite į vieną eilutę. Suskaičiuokite, kokio ilgio galutinė eilutė. Atsakymai pasitikrinimui: ## [1] &quot;A&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;Y&quot; &quot;J&quot; ## [1] &quot;A&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;J&quot; ## [1] &quot;Aistis&quot; &quot;Gytis&quot; &quot;Gytis&quot; &quot;Gytis&quot; &quot;Jonas&quot; ## [1] 6 5 5 5 5 ## [1] &quot;p. Aistis&quot; &quot;p. Gytis&quot; &quot;p. Gytis&quot; &quot;p. Gytis&quot; &quot;p. Jonas&quot; ## [1] &quot;P. Aistis&quot; &quot;P. Gytis&quot; &quot;P. Gytis&quot; &quot;P. Gytis&quot; &quot;P. Jonas&quot; ## [1] &quot;P. Aistis, P. Gytis, P. Gytis, P. Gytis, P. Jonas&quot; ## [1] 49 7.4 Darbas su kategoriniais kintamaisiais Kategoriniai kintamieji (faktoriai) – tai iš anksto žinomą galimų skirtingų reikšmių (kategorijų) skaičių turintys kintamieji. Sutrumpintai žymimi fct. Darbui su faktoriais yra sukurtas specializuotas paketas forcats . Svarbiausios jo funkcijos prasideda užrašu fct_. 7.4.1 Faktorių kūrimas Faktoriai sukuriami naudojant funkciją factor(). fct_1 &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;, &quot;D&quot;)) fct_2 &lt;- factor(c(&quot;A&quot;, &quot;T&quot;, &quot;T&quot;, &quot;T&quot;, &quot;C&quot;, &quot;T&quot;)) miestai &lt;- c(&quot;Vilnius&quot;, &quot;Vilnius&quot;, &quot;Kaunas&quot;, &quot;Vilnius&quot;, &quot;Klaipėda&quot;, &quot;Kaunas&quot;, &quot;Alytus&quot;) (miestai_fct &lt;- factor(miestai)) ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Alytus Kaunas Klaipėda Vilnius Taip pat kategorinius kintamuosius galime gauti keisdami duomenų klasę funkcijomis as.factor() (kategorijas išrikiuoja abėcėliškai), forcats::as_factor() (kategorijas išrikiuoja pagal jų eilės tvarką vektoriuje), factor() (kategorijas galime nurodyti patys naudodami levels = c(…)) ir panašias funkcijas. miestai &lt;- c(&quot;Vilnius&quot;, &quot;Vilnius&quot;, &quot;Kaunas&quot;, &quot;Vilnius&quot;, &quot;Klaipėda&quot;, &quot;Kaunas&quot;, &quot;Alytus&quot;) # Kategorijos išdėliojamos pagal abėcėlę. # Rezultatas skirsis priklausomai nuo nustatytos „R“ lokalės. as.factor(miestai) ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Alytus Kaunas Klaipėda Vilnius # Kategorijos išdėliojamos pagal eilės tvarką vektoriuje. # Pirma sutinkamas „Vilnius“, po to „Kaunas“ ir t.t. forcats::as_factor(miestai) ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Vilnius Kaunas Klaipėda Alytus # Kategorijos išdėliojamos nurodyta eilės tvarka. factor(miestai, levels = c(&quot;Kaunas&quot;, &quot;Alytus&quot;, &quot;Vilnius&quot;, &quot;Klaipėda&quot;)) ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Kaunas Alytus Vilnius Klaipėda Norint duomenis paversti į ranginius, naudojamos funkcijos ordered(), as.ordered() arba factor(..., ordered = TRUE): vietos &lt;- c(&quot;pirma&quot;, &quot;antra&quot;, &quot;trečia&quot;) as.ordered(vietos) # kategorijos išdėliotos neteisingai ## [1] pirma antra trečia ## Levels: antra &lt; pirma &lt; trečia ordered(vietos, levels = c(&quot;pirma&quot;, &quot;antra&quot;, &quot;trečia&quot;)) ## [1] pirma antra trečia ## Levels: pirma &lt; antra &lt; trečia factor(vietos, levels = c(&quot;pirma&quot;, &quot;antra&quot;, &quot;trečia&quot;), ordered = TRUE) ## [1] pirma antra trečia ## Levels: pirma &lt; antra &lt; trečia Ranginius duomenis versti į nominaliuosius naudojama funkcija factor(..., ordered = FALSE). Turint tekstinius kintamuosius, funkcija type.convert() tinkamą duomenų tipą bando atspėti automatiškai, tad ji taip pat gali duomenis paversti į nominaliuosius faktorius (kategorijos nebūtinai bus išrikiuotos logiška tvarka). type.convert(miestai) # Automatinis kintamojo tipo parinkimas → factor ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Alytus Kaunas Klaipėda Vilnius type.convert(skaiciai_chr_2) # Automatinis kintamojo tipo parinkimas → numeric ## [1] 20 5 10 150 12 1 Įvykdę automatinį duomenų tipo parinkimą būtinai patikrinkite, ar rezultatas yra toks, kokio tikėjotės. Naudodami funkciją cut() į kategorijas galime padalinti skaitinių kintamųjų reikšmes (apie tai bus rašoma skyriuje „7.5.4 Skaitinio kintamojo reikšmių kategorizavimas“). Užduotis 7.13 Duota duomenų eilutė budejimo_dienos &lt;- c(&quot;Pirmadienis&quot;, &quot;Antradienis&quot;, &quot;Ketvirtadienis&quot;, &quot;Sekmadienis&quot;). Paverskite ją į faktorių. Kategorijos turi būti išrikiuotos logiška tvarka. 7.4.2 Faktorių pertvarkymas ir analizė Toliau šio skyriaus pavyzdžiuose bus naudojami duomenys apie kates. Duomenų įkėlimo kodo suprasti nebūtina. Duomenų aprašymas: help(cats, package = &quot;MASS&quot;). lytis &lt;- dplyr::recode_factor(MASS::cats$Sex, &quot;M&quot; = &quot;Patinas&quot;, &quot;F&quot; = &quot;Patelė&quot;) kunas &lt;- cut(MASS::cats$Bwt, breaks = 3, labels = c(&quot;Smulkus&quot;, &quot;Vidutinis&quot;, &quot;Didelis&quot;), ordered_result = TRUE) sirdis &lt;- cut(MASS::cats$Hwt, breaks = 2, labels = c(&quot;Lengva&quot;, &quot;Sunki&quot;), ordered_result = TRUE) head(lytis) ## [1] Patelė Patelė Patelė Patelė Patelė Patelė ## Levels: Patinas Patelė head(kunas) ## [1] Smulkus Smulkus Smulkus Smulkus Smulkus Smulkus ## Levels: Smulkus &lt; Vidutinis &lt; Didelis head(sirdis) ## [1] Lengva Lengva Lengva Lengva Lengva Lengva ## Levels: Lengva &lt; Sunki Norint patikrinti ar kintamasis yra kategorinis, naudojama funkcija is.factor(), o is.ordered() tikrina, ar kategorijos turi eilės tvarką (t. y., ar kintamasis yra ranginis). Funkcija levels() išvardija kategorijas: levels(lytis) ## [1] &quot;Patinas&quot; &quot;Patelė&quot; levels(miestai_fct) ## [1] &quot;Alytus&quot; &quot;Kaunas&quot; &quot;Klaipėda&quot; &quot;Vilnius&quot; Funkcija summary() automatinę suvestinę atlieka pagal kintamojo tipą („R“ klasę). Kategoriniams kintamiesiems sudaro dažnių lentelę. summary(lytis) ## Patinas Patelė ## 97 47 summary(miestai_fct) ## Alytus Kaunas Klaipėda Vilnius ## 1 2 1 3 Dažnių lentelėms sudaryti naudojama funkcija table() arba ftable(). table(lytis) ## lytis ## Patinas Patelė ## 97 47 table(miestai_fct) ## miestai_fct ## Alytus Kaunas Klaipėda Vilnius ## 1 2 1 3 „R“ rezultatuose: miestai_fct – kintamojo pavadinimas (gali ir nebūti); Alytus Kaunas ... – reikšmių (grupių) pavadinimai; 1 2 1 3 – reikšmių pasikartojimo dažnis (grupių dydžiai). Funkciją table() galima naudoti ne tik faktoriams, bet ir kitų tipų kintamiesiems, kai norima sudaryti dažnių lentelę. Taip pat galima sudaryti kryžmines (kelių kintamųjų) dažnių lenteles, kurios rodo, kiek kartų pasikartoja kiekviena kelių kintamųjų reikšmių kombinacija. dazn_lentele &lt;- table(lytis, kunas) dazn_lentele ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 31 42 24 ## Patelė 39 8 0 „R“ rezultatuose matome, kad, pvz., kombinacija „Patinas“ ir „Smulkus“ pasikartoja 31 kartą, o „Patelė“ ir „Didelis“ – apskritai nepasitaikė. Funkcija addmargins() prideda eilučių ir stulpelių sumas addmargins(dazn_lentele) ## kunas ## lytis Smulkus Vidutinis Didelis Sum ## Patinas 31 42 24 97 ## Patelė 39 8 0 47 ## Sum 70 50 24 144 addmargins(dazn_lentele, margin = 1) # tik eilutėms ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 31 42 24 ## Patelė 39 8 0 ## Sum 70 50 24 addmargins(dazn_lentele, margin = 2) # tik stulpeliams ## kunas ## lytis Smulkus Vidutinis Didelis Sum ## Patinas 31 42 24 97 ## Patelė 39 8 0 47 ES taisyklė: pirma (1) – eilutės; antra (2) – stulpeliai. Funkcija prop.table() apskaičiuoja procentines dalis: bendra, pagal eilutes arba pagal stulpelius. prop.table(dazn_lentele) # bendra suma lygi 1 ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 0.21527778 0.29166667 0.16666667 ## Patelė 0.27083333 0.05555556 0.00000000 prop.table(dazn_lentele, margin = 1) # eilučių suma lygi 1 ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 0.3195876 0.4329897 0.2474227 ## Patelė 0.8297872 0.1702128 0.0000000 prop.table(dazn_lentele, margin = 2) # stulpelių suma lygi 1 ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 0.4428571 0.8400000 1.0000000 ## Patelė 0.5571429 0.1600000 0.0000000 Kiekvienam lentelės elementui galima atlikti matematinius veiksmus (plačiau apie skaičiavimus skyriuje „7.5.2 R kaip kalkuliatorius“): (rez_1 &lt;- 100 * prop.table(dazn_lentele)) ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 21.527778 29.166667 16.666667 ## Patelė 27.083333 5.555556 0.000000 round(rez_1, digits = 1) ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 21.5 29.2 16.7 ## Patelė 27.1 5.6 0.0 Dar vienas būdas sudaryti dažnių lentelę – funkcija ftable(). Ji patogesnė tada, kai turime daugiau nei 2 kategorinius kintamuosius. table(lytis, sirdis, kunas) ## , , kunas = Smulkus ## ## sirdis ## lytis Lengva Sunki ## Patinas 31 0 ## Patelė 39 0 ## ## , , kunas = Vidutinis ## ## sirdis ## lytis Lengva Sunki ## Patinas 37 5 ## Patelė 8 0 ## ## , , kunas = Didelis ## ## sirdis ## lytis Lengva Sunki ## Patinas 11 13 ## Patelė 0 0 ftable(lytis, sirdis, kunas) ## kunas Smulkus Vidutinis Didelis ## lytis sirdis ## Patinas Lengva 31 37 11 ## Sunki 0 5 13 ## Patelė Lengva 39 8 0 ## Sunki 0 0 0 Automatinę grafinę suvestinę atlieka funkcija plot() – nubraižo stulpelinę diagramą: plot(lytis) Arba: ggplot2::qplot(lytis) Y ašyje atidedamas reikšmių pasikartojimo dažnumas (grupės narių skaičius). Norėdami sujungti kelis kategorinius kintamuosius (ir jų kategorijas), naudojame forcats::fct_c(). fct_3 &lt;- forcats::fct_c(fct_1, fct_2) fct_3 ## [1] A A D C C D A T T T C T ## Levels: A C D T Nebenaudojamas kategorijas galime pašalinti naudodami droplevels() arba forcats::fct_drop(): # Didelių patelių kūnų nėra, bet kategorija liko. # Ji bus atvaizduojama tiek grafikuose, tiek lentelėse. kates_kunas &lt;- kunas[lytis == &quot;Patelė&quot;] levels(kates_kunas) ## [1] &quot;Smulkus&quot; &quot;Vidutinis&quot; &quot;Didelis&quot; # Pašalinama nebenaudojama kategorija. kates_kunas_drop &lt;- forcats::fct_drop(kates_kunas) levels(kates_kunas_drop) ## [1] &quot;Smulkus&quot; &quot;Vidutinis&quot; table(kates_kunas) ## kates_kunas ## Smulkus Vidutinis Didelis ## 39 8 0 table(kates_kunas_drop) ## kates_kunas_drop ## Smulkus Vidutinis ## 39 8 plot(kates_kunas) plot(kates_kunas_drop) Funkcija dplyr::recode_factor() skirta perkoduoti kategorinio kintamojo reikšmes. Kaip ir dplyr::recode(), veikia pagal šabloną senoji_reikšmė = naujoji_reikšmė. Skirtumas toks, kad perkoduojamų reikšmių eiliškumas nurodo naujųjų kategorijų eiliškumą. Reikšmių eiliškumas išlieka tas pats, tik grafikuose ir lentelėse kategorijos bus atvaizduojamos kitokia tvarka. dplyr::recode_factor(fct_1, &quot;A&quot; = &quot;Arklas&quot;, &quot;D&quot; = &quot;Deimantas&quot;) ## [1] Arklas Arklas Deimantas C C Deimantas ## Levels: Arklas Deimantas C dplyr::recode_factor(fct_1, &quot;D&quot; = &quot;Deimantas&quot;, &quot;A&quot; = &quot;Arklas&quot;) ## [1] Arklas Arklas Deimantas C C Deimantas ## Levels: Deimantas Arklas C Užduotis 7.14 Paskutinio pavyzdžio kategorijų perkodavimo procedūrą papildykite raidę „C“ perkoduodami į žodį „Citrina“ (t. y., parašykite kodą, kuris perkoduoja visas tris raides į pilnus žodžius). Rezultatus atvaizduokite grafiškai ir dažnių lentele. Kodas geliu_rusys &lt;- iris$Species sugeneruos duomenų seką geliu_rusys. Kodo suprasti nereikia, bet konsolėje parašę kodą ?iris, „Help“ lange rasite pradinių duomenų aprašymą. Užduotis – ištirti seką geliu_rusys (kiekvienam punktui parašykite kodą): Kokia duomenų „R“ klasė? Kokį statistinį duomenų tipą atitinka šie duomenys? Kiek reikšmių iš viso? (Koks imties dydis?) Kiek yra skirtingų reikšmių? Kokie jų pavadinimai? Sudarykite dažnių lentelę. Duomenis atvaizduokite grafiškai. Įvardinkite, kaip vadinasi diagrama. Kodas pasaras &lt;- chickwts$feed sugeneruos duomenų seką pasaras. Pradinių duomenų aprašymas: ?chickwts. Ištirkite seką pasaras taip, kaip darėte duomenims geliu_rusys. 7.5 Darbas su skaitiniais kintamaisiais Programoje „R“ skaičiai visada užrašomi angliškai. Tai reiškia, kad tarp sveikosios ir dešimtosios dalies dedamas taškas (nors lietuviškai sakome „kablelis“). Jei sveikąją dalį sudaro tik nulis, jo galime nerašyti. O kablelis naudojamas atskirti kelias skirtingas reikšmes (t. y., kelis skaičius, o ne skaitmenis), kaip matėte ankstesniuose pavyzdžiuose. x &lt;- c(1.2, .6, .2200, 3.31) x ## [1] 1.20 0.60 0.22 3.31 Taip pat „R“ turi kelias matematines konstantas, kurios gali būti panaudotos skaičiavimuose 7.2. Lentelė 7.2: Matematinės konstantos Konstanta Reikšmė Pastaba pi skaičius \\(\\pi = 3.14159...\\) exp(1) skaičius \\(e = 2.71828...\\) Atitinka išraišką \\(e^1\\). 7.5.1 Skaičių sekų kūrimas Įprastai reikšmių sekos kuriamos naudojant operatorių c(). Tačiau dirbant su skaitiniais duomenimis yra specializuotų būdų skaičių sekoms kurti. Operatorius : Naudojant vieno dvitaškio operatorių : sukuriama seka nuo:iki kas 1. Pvz., sukuria didėjančių skaičių seką nuo 3 iki 21 kas 1: 3:21 ## [1] 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Ar mažėjančių skaičių seką nuo 3 iki -11 kas 1: 3:-11 ## [1] 3 2 1 0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 Užduotis 7.15 Naudodami : operatorių: Sukurkite seką a nuo 20 iki 200 kas 1 ir ją atspausdinkite. Sukurkite seką b nuo 0,3 iki - 6,6 kas 1 ir ją atspausdinkite. Abi sekas sudėkite ir rezultatą pavadinkite c. Kokį įspėjimą parašo „R“? Funkcija seq() Jei nepakanka operatoriaus :, galime naudoti funkciją seq() (nuo angliško žodžio sequence). Jos argumentai yra: from – (nuo) pirmoji reikšmė, to – (iki) paskutinė galima reikšmė, jei ji įeina į seką. Bei vienas iš: by – (kas) sekos reikšmių keitimosi žingsnis, length.out – bendras sekos ilgis, along.width – kitas vektorius: šio ir naujojo vektorių ilgiai bus vienodi. Pvz., seka nuo 1 iki 27 kas 5 (reikšmė 27 neįtraukta): seq(from = 1, to = 27, by = 5) ## [1] 1 6 11 16 21 26 Seka nuo 1 iki 21, kurią sudaro 4 elementai (atstumai tarp reikšmių vienodi): seq(from = 1, to = 21, length.out = 4) ## [1] 1.000000 7.666667 14.333333 21.000000 Seka nuo 1 iki 20, kurią sudaro tiek pat elementų, kiek yra sekoje 2:7: seka_a &lt;- 2:7 seq(from = 1, to = 20, along.with = seka_a) ## [1] 1.0 4.8 8.6 12.4 16.2 20.0 Taip pat dažnai naudojama funkcija seq_along(), kuri išvardija vektoriaus elementų eilės numerius. T. y., sukuria seką nuo 1 iki length(x), jei turime objektą x. Pvz.: seq_along(seka_a) ## [1] 1 2 3 4 5 6 Toks funkcionalumas naudojamas braižant grafikus, kuriant for ciklus (apie juos kol kas plačiau nesimokysime), ar kitais atvejais, kai reikia vienodo ilgio sekų. Užduotis 7.16 Sukurkite sekas: seka_s1: nuo 2 iki \\(\\pi\\) kas 0,2; seka_s2: nuo \\(e\\) iki \\(\\pi\\), kurioje yra 10 reikšmių; seka_s3, kurioje išvardinti seka_s2 elementų eilės numeriai. Atsitiktinės sekos iš galimų reikšmių aibės Jei norime pasirinkti atsitiktinių skaičių seką iš žinomos reikšmių aibės, naudojame funkciją sample() (angl. sample – imties sudarymas). Svarbiausi funkcijos parametrai: x – galimų reikšmių vektorius; size – būsimos imties (vektoriaus) dydis; replace (loginė reikšmė) – jei TRUE, tada ta pati reikšmė gali būti ištraukta kelis kartus (grąžintinis imties sudarymo būdas). Jei FALSE – kiekviena reikšmė gali būti pasirinkta ne daugiau kaip vieną kartą (negrąžintinis imties sudarymas). prob – kiekvienos x reikšmės pasirinkimo tikimybė. Jei nenurodyta, tada tikimybės yra lygios. galimos_reikšmės &lt;- c(1, 5, 7) sample(galimos_reikšmės) ## [1] 7 5 1 sample(galimos_reikšmės, size = 1) ## [1] 5 sample(galimos_reikšmės, size = 20, replace = TRUE) ## [1] 7 1 1 7 1 7 1 7 1 5 1 1 5 7 5 7 7 7 5 5 Užduotis 7.17 Sudarykite sveikųjų skaičių seką nuo 1 iki 10 ir pavadinkite seka_int_1. Sekos seka_int_1 narius išdėliokite atsitiktine tvarka. Atsitiktiniu negrąžintiniu būdu iš sekos seka_int_1 ištraukite 5 reikšmes. Ar ištrauktos reikšmės gali būti vienodos? Atsitiktiniu grąžintiniu būdu iš sekos seka_int_1 ištraukite 25 reikšmes. Ar ištrauktos reikšmės gali būti vienodos? Ar pakartojus ketvirto punkto eksperimentą kiekvieną kartą bus gautas toks pats atsakymas? Atsitiktinių skaičių sekos: statistiniai dėsniai Atsitiktinių skaičių sekų, kurių nariai skirstosi pagal įvairius statistinius dėsnius, kūrimui naudojamos funkcijos, prasidedančios raide r (ang. random), po kurios eina sutrumpintas dėsnio pavadinimas, toks kaip norm – normalusis, arba Gauso, dėsnis, pois – Puasono (prancūzų mokslininko pavardė Poisson), unif tolygusis (angl. uniform) ir kiti. Kiekvienam iš šių dėsnių būdingi tam tikri parametrai. Pvz., rnorm(10, mean = 1, sd = 0.2) sukurs atsitiktinę seką iš 10 skaičių, paimtų iš generalinės aibės, pasiskirsčiusios pagal normalųjį skirstinį, kurio vidurkis (angl. mean) lygus 1, o standartinis nuokrypis (sd angl. standard deviation) – 0,2: rnorm(10, mean = 1, sd = 0.2) ## [1] 1.1667466 0.9447904 0.9289996 1.0174975 1.4504511 1.1668920 1.2624831 ## [8] 1.5005291 1.2336463 0.9147669 Funkcija rpois(6, lambda = 3) sukurs atsitiktinę seką iš 6 skaičių, paimtų iš pagal Puasono (Poisson) skirstinį, kurio parametras \\(\\lambda = 3\\), pasiskirsčiusios aibės. Funkcija runif(5, min = 2, max = 14) sukurs seką, paimtą iš generalinės aibės, kurios reikšmės pasiskirsčiusios tolygiai intervale nuo 2 iki 14: runif(5, min = 2, max = 14) ## [1] 3.915123 2.967743 3.591804 4.062865 7.733334 Plačiau šiuos dėsnius nagrinėsime temoje apie tikimybes. Atkreipkite dėmesį, kad tolydusis ir tolygusis (skirstinys) yra du skirtingi terminai. Užduotis 7.18 Simuliuokite eksperimentą, kurio metu paimama 9 narių imtis iš pagal normalųjį skirstinį pasiskirsčiusios generalinės aibės su parametrais \\(\\mu\\) = 1.82 (vidurkis) ir \\(\\sigma\\) = 0.18 (standartinis nuokrypis). Atkartojamas atsitiktinumas Visgi dirbant kompiuteriu reikia žinoti, kad kompiuteryje atsitiktinumas nėra tikras. Jis yra simuliuojamas algoritmais, kuriais sugeneruotų reikšmių pasikartojimo periodas yra labai didelis, tarkim \\(2^{19937}-1\\). Daugeliui praktinių problemų spręsti to pakanka. Algoritmo rezultatas priklauso nuo pradinių sąlygų. Šias pradines sąlygas nustato funkcija set.seed(), kurios skliaustuose nurodomas teigiamas arba neigiamas sveikasis skaičius. Kiekvieną kartą pieš atsitiktinių skaičių kūrimą naudojant šią funkciją gaunami vienodi rezultatai. Todėl „atsitiktinai“ sugeneruoti skaičiai iš tiesų yra pseudoatsitiktiniai. rnorm(10) # Variantas A ## [1] -0.96193342 -0.29252572 0.25878822 -1.15213189 0.19578283 ## [6] 0.03012394 0.08541773 1.11661021 -1.21885742 1.26736872 rnorm(10) # Variantas B ## [1] -0.7447816 -1.1312186 -0.7163585 0.2526524 0.1520457 -0.3076564 ## [7] -0.9530173 -0.6482428 1.2243136 0.1998116 set.seed(201809) rnorm(10) # Variantas C ## [1] 0.9991890 -1.2069877 0.5160472 0.4601108 -0.5160344 0.2357106 ## [7] -0.6072210 -0.7666150 1.0941386 0.7102374 set.seed(201809) rnorm(10) # Variantas D identiškas variantui C ## [1] 0.9991890 -1.2069877 0.5160472 0.4601108 -0.5160344 0.2357106 ## [7] -0.6072210 -0.7666150 1.0941386 0.7102374 set.seed(201809) rnorm(10) # Variantas E identiškas variantui C ## [1] 0.9991890 -1.2069877 0.5160472 0.4601108 -0.5160344 0.2357106 ## [7] -0.6072210 -0.7666150 1.0941386 0.7102374 Kaip matote, trys paskutinės sekos yra identiškos, nes naudotos tos pačios pradinės sąlygos. Prieš atliekant analizę, programos kodo pradžioje rekomenduojama nurodyti pradines pseudoatsitiktinių skaičių generatoriaus vertes. Taip kelis kartus vykdant tą pačią analizę bus gaunami identiški rezultatai, jei analizės metu naudojami atsitiktinumą simuliuojantys analizės metodai. Užduotis 7.19 Simuliuokite eksperimentą, kurio metu iš tolygiojo skirstinio (mažiausia reikšmė -100, didžiausia – 100) sudaroma 65 narių imtis. Kodą parašykite taip, kad ir jūsų, ir kolegos kompiuteryje būtų gauti identiški rezultatai. 7.5.2 R kaip kalkuliatorius Programoje „R“ matematinius (ir kitokius) veiksmus atlieka simboliai, vadinami operatoriais (pvz., lentelėje 7.3), arba komandos, vadinamos funkcijomis (pvz., lentelėse 7.4, 7.5). Taip pat galima panaudoti ir konstantas, tokias kaip skaičius \\(\\pi\\) (lentelė 7.2). „R“ operatoriai – tai funkcijos, užrašomos ne žodžiais, o specialiaisiais simboliais, tokiais kaip +, &lt;-, == ar %&gt;%. Lentelė 7.3: Matematinius veiksmus atliekantys „R“ operatoriai Simbolis (operatorius) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas + Sudėtis 5 + 8 13 - Atimtis 5 - 7 -2 * Daugyba 3 * 4 12 / Dalyba 6 / 3 2 ^ Kėlimas laipsniu 3^2 9 ** Kėlimas laipsniu 3**2 9 %/% Sveikoji dalis (po dalybos) 7 %/% 3 2 %% Liekana (po dalybos) 7 %% 3 1 Veiksmai atliekami eilės tvarka, panašiai, kaip matematikoje: pirma veiksmai skliausteliuose; tada kėlimas laipsniu; tada daugyba, dalyba; tada sudėtis, atimtis. 2 * 3^2 # 2 * 9 ## [1] 18 (3 + 6)^2 - 9/3 # 9^2 - 3 ## [1] 78 21 %/% 2^2 # 21 %/% 4 ## [1] 5 Jei nesate tikri, kokia tvarka bus atlikti veiksmai – naudokite papildomus skliaustus. Tada tikrai bus aišku: (5 %/% 2)^2 ## [1] 4 5 %/% (2^2) ## [1] 1 Jei yra pradžios skliaustai (, būtinai turi būti ir pabaigos skliaustai ). Lentelė 7.4: „R“ komandos, atliekančios dažnas matematines operacijas Funkcija (komanda) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas sqrt() Kvadratinė šaknis sqrt(4) 2 abs() Modulis (absoliučioji vertė) abs(-2) 2 sin(), cos(), tan(), Trigonometrinės funkcijos (skliaustuose radianai; daugiau informacijos suvedus komandą ?Trig). sin(pi/6) 0.5 exp() Eksponentė \\((e^x)\\) exp(0) 1 log(), log2(), log10() Natūrinis \\((\\ln{x})\\), dvejetainis \\((\\log_2{x})\\) ir dešimtainis \\((\\lg{x})\\) logaritmai. log10(100) 2 factorial() Faktorialas \\((4! = 4\\cdot3\\cdot2\\cdot1)\\) factorial(4) 24 choose() Binominis koeficientas \\(C^k_n\\).Taip pat žymimas \\(\\binom{n}{k} = {n! \\over k!(n-k)!}\\). choose(n = 5, k = 2) 10 Lentelė 7.5: „R“ komandos, atliekančios apvalinimą. Funkcija (komanda) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas round() Įprastinis apvalinimas (iki n skaičių po kablelio) round(8.275, digits = 2) 8.28 round(-8.275, digits = 2) -8.28 signif() Įprastinis apvalinimas (iki n reikšmingų skaičių) signif(8.275, digits = 2) 8.3 signif(0.0275, digits = 2) 0.028 ceiling() Apvalinimas¹ į didesnę pusę ceiling(8.275) 9 ceiling(-8.275) -8 floor() Apvalinimas¹ į mažesnę pusę floor(8.975) 8 floor(-8.975) -9 trunc() Apvalinimas¹ į nulio pusę trunc(9.99) 9 trunc(-9.99) -9 ¹Apvalinimas iki artimiausio sveikojo skaičiaus. Pavyzdžiai Komandų, atliekančių matematinius veiksmus, naudojimo pavyzdžiai. sqrt(125) ## [1] 11.18034 abs(-4) ## [1] 4 cos(4 * pi) ## [1] 1 exp(2) # Skaičius e pakeltas kvadratu ## [1] 7.389056 log(2.718282) # logaritmas pagrindu e ## [1] 1 factorial(6) # 6! ## [1] 720 choose(52, 5) # skaičiuojama 52!/(47! × 5!) ## [1] 2598960 arba choose(n = 52, k = 5) # nurodyti argumentai suteikia aiškumo ## [1] 2598960 Užduotis 7.20 Naudodamiesi „R“ parašykite ir apskaičiuokite šias išraiškas: \\((2+3.3)^7 + \\ln{6} + cos(\\pi\\sqrt{2})\\); \\(|2^5 - 3^4|\\); \\(e^{\\left(-\\frac{1}{2}\\right)}\\); \\(e^e\\); \\(\\pi r\\ ^2\\), kai \\(r = 2.5\\); Konstantą \\(\\pi\\) suapvalinkite: iki 3 skaičių po kablelio; iki 5 reikšmingų skaitmenų. 7.5.3 Skaitinių kintamųjų suvestinės Skaitines suvestines galima skaičiuoti automatiškai („greituoju būdu“) arba išreikštai nurodant norimą funkciją. Pavyzdžiuose bus naudojamas vektorius x. Kai tirsite savo duomenis, naudokite savojo vektoriaus pavadinimą. set.seed(951753) x &lt;- round(rnorm(30), digits = 1) # suapvalinta iki 1 skaičiaus po kablelio. Automatines suvestines atlieka funkcija summary(x). Skaitiniams kintamiesiems tai mažiausia reikšmė, 1 kvartilis, mediana, vidurkis, 3 kvartilis ir didžiausia reikšmė. Jei yra trūkstamų reikšmių, nurodomas jų skaičius. summary(x) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -2.200 -0.875 -0.100 -0.090 0.575 2.400 Vietoje x reikia įrašyti kintamojo pavadinimą: Duomenų centras: mean(x) – vidurkis; mean(x, trim = .10) – 10% nupjautinis vidurkis. Skaičių trim galima keisti nuo 0 iki 0.5, tai atitinka nuo 0% iki 50% nupjautinį vidurkį; median(x) – mediana; DescTools::Hmean(x) – harmoninis vidurkis; DescTools::Gmean(x) – geometrinis vidurkis. Sklaida: sd(x) – standartinis nuokrypis; var(x) – dispersija; IQR(x) – IQR, tarpkvartilinis plotis, arba kvartinių skirtumas (angl. interquartile range); mad(x) – MAD, absoliučiojo nuokrypio nuo medianos mediana, padauginta iš 1,4826 (angl. median absolute deviation). Kitos padėties statistikos: min(x) – mažiausia reikšmė; max(x) – didžiausia reikšmė; quantile(x, probs = 0.25), quantile(x, probs = 0.75) – 25% ir 75% procentiliai. Skaičių probs galima keisti nuo 0 iki 1. Pozicija: dplyr::first(x) – pirmoji reikšmė pagal eilę; dplyr::last(x) – paskutinė reikšmė pagal eilę; dplyr::nth(x, n = 2) – n-toji reikšmė pagal eilę (šiuo atveju – antroji reikšmė). Skaičius, dydis: sum(x) – visų reikšmių suma (atitinka matematinį užrašą \\(\\sum x_i\\)); length(x) – imties arba grupės dydis; dplyr::n_distinct(x) arba length(unique(x)) – unikalių (nepasikartojančių) reikšmių skaičius; sum(is.na(x)) – trūkstamų reikšmių skaičius; sum(!is.na(x)) – netrūkstamų reikšmių skaičius. Skirstinio forma: DescTools::Kurt(x) – eksceso koeficientas (angl., excess kurtosis). Parametras method (galimos reikšmės yra 1, 2, 3) kontroliuoja, kuris eksceso skaičiavimo metodas naudojamas; DescTools::Skew() – asimetrijos koeficientas (angl., skewness). Parametras method (galimos reikšmės yra 1, 2, 3) kontroliuoja, kuris asimetrijos koeficiento skaičiavimo metodas naudojamas. Paz.: median(x) ## [1] -0.1 DescTools::Kurt(x) ## [1] -0.7198677 quantile(x, probs = 0.25) ## 25% ## -0.875 min(x) ## [1] -2.2 Jei duomenyse yra trūkstamų reikšmių, tada daugumos iš šių funkcijų atsakymas bus NA. x_na &lt;- x x_na[25] &lt;- NA x_na ## [1] -1.9 -1.7 2.4 0.0 2.0 -0.1 -1.5 -0.8 -2.2 0.6 0.0 -0.3 -0.9 -0.3 ## [15] -0.1 -0.1 0.5 1.9 -0.9 0.0 -0.8 1.4 -0.1 0.3 NA 1.0 -1.8 -1.1 ## [29] 1.4 -0.6 mean(x_na) ## [1] NA Tokiu atveju įprastai galima nurodyti parametrą na.rm = TRUE. Taip bus daromos suvestinės prieš tai pašalinus trūkstamas reikšmes. mean(x_na, na.rm = TRUE) ## [1] -0.1275862 Alternatyva, jei funkcija neturi parametro na.rm – papildomai naudoti funkciją na.omit(): mean(na.omit(x_na)) ## [1] -0.1275862 Arba x_be_na &lt;- na.omit(x_na) sd(x_be_na) ## [1] 1.195795 „Greitam“ grafiniam atvaizdavimui galime naudoti šias funkcijas: hist(x) plot(density(x)) boxplot(x) ggplot2::qplot(x = x, geom = &quot;histogram&quot;, bins = 5, # bins - stulpelių skaičius xlab = &quot;Pavadinimas X&quot;, ylab = &quot;Pavadinimas Y&quot;, color = I(&quot;black&quot;)) ggplot2::qplot(x = x, geom = &quot;density&quot;, adjust = 1) # adjust - glotninimo parametro daugiklis ggplot2::qplot(y = x, geom = &quot;boxplot&quot;) Išsamiau apie grafikus mokysimės atskiro užsiėmimo metu. Užduotis 7.21 Šio skyriaus pavyzdžiuose sukurtai duomenų eilutei x apskaičiuokite visas poskyryje nurodytas aprašomąsias statistikas. Įvertinkite: duomenų centro padėtį; sklaidą; simetriją; išskirčių buvimą/nebuvimą. Sukurkite duomenų eilutę y &lt;- rexp(30) (pagal eksponentinį dėsnį pasiskirstę duomenys). Apskaičiuokite poskyryje nurodytas aprašomąsias statistikas bei atvaizduokite grafiškai. Įvertinkite: duomenų centro padėtį; sklaidą; simetriją; išskirčių buvimą/nebuvimą. Apskaičiuokite, koks imties set.seed(12); x_3 &lt;- rnorm(30) standartinis nuokrypis, kuris skaičiuojamas pagal formulę: \\[s_x = \\sqrt{\\frac{\\sum^n_{i=1}(x_i-\\overline{x})^2}{n-1}}\\] Funkcijų sd() bei var() naudoti negalima. Funkcija set.seed(12) nustato pradines sąlygas kompiuterio pseudoatsitiktinių skaičių generatoriui, todėl kiekvieno iš mūsų skaičiavimuose sugeneruojama ta pati skaičių seka (gaunami atkartojami rezultatai, o tai šiuolaikinėje duomenų analizėje labai svarbu). Apskaičiuokite, koks imties set.seed(12); x_4 &lt;- rnorm(30) medianinis absoliutusis nuokrypis nuo medianos, kuris skaičiuojamas pagal formulę: \\[mad_x = 1.4826 \\cdot median( |x_i - median(x)|)\\] Funkcijos mad() naudoti negalima; Sakykime, kad set.seed(-121258); x_5 &lt;- rnorm(1e5) yra visa mūsų tiriama generalinė aibė (GA). Apskaičiuokite jai GA eksceso koeficientą (angl. excess kurtosis) pagal formulę: \\[ekscesas = N \\cdot \\frac{\\sum^N_{i=1}{(x_i - \\overline{x}})^4}{\\left(\\sum^N_{i=1}{(x_i - \\overline{x}})^2\\right)^2} - 3\\] kur \\(N\\) – GA dydis, \\(\\overline{x}\\) – GA vidurkis. Formulė gali būti išskaidyta į kelias eilutes. 7.5.4 Skaitinio kintamojo reikšmių kategorizavimas Kartais skaitinio kintamojo reikšmes, pvz., amžių, reikia suskirstyti į kategorijas „jaunas“, „vidutinio amžiaus“, „pagyvenęs“. Tam naudinga funkcija cut(). set.seed(654852) amžius &lt;- sample(1:80, size = 100, replace = TRUE) summary(amžius) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 23.50 40.50 41.22 61.50 80.00 Funkcijoje nurodomos ribos, kaip „supjaustyti“ kintamojo reikšmes. Kiekvienam pogrupiui galime suteikti pavadinimus. amžiaus_gr &lt;- cut(amžius, breaks = c(0, 30, 60, 100), labels = c(&quot;jaunas&quot;, &quot;suaugęs&quot;, &quot;pagyvenęs&quot;)) summary(amžiaus_gr) ## jaunas suaugęs pagyvenęs ## 35 38 27 Jei mažiausios ar didžiausios galimos reikšmės nežinome, galime nurodyti -Inf arba Inf Neturint rimto pagrindo, tolydiuosius dydžius kategorizuoti ir analizuoti kaip kategorinis yra nekorektiška. amžiaus_gr_2 &lt;- cut(amžius, breaks = c(-Inf, 30, 60, Inf), labels = c(&quot;jaunas&quot;, &quot;suaugęs&quot;, &quot;pagyvenęs&quot;)) summary(amžiaus_gr_2) ## jaunas suaugęs pagyvenęs ## 35 38 27 Jei norite suskirstyti į 4 grupes nenurodydami ribų, galite, kiek intervalų turėtų būti. Parametras breaks yra viena konkreti reikšmė: amžiaus_gr_3 &lt;- cut(amžius, breaks = 4) summary(amžiaus_gr_3) ## (0.921,20.8] (20.8,40.5] (40.5,60.2] (60.2,80.1] ## 22 28 23 27 Mantome, kad reikšmės pateiktos kaip itervavai. Pastaba: neturint rimto pagrindo, tolydiuosius dydžius kategorizuoti ir analizuoti kaip kategorinius kintamuosius yra nekorektiška, nes skirstant į kategorijas prarandama dalis informacijos. Pradinių duomenų reikšmių atstatyti iš kategorijų nebeįmanoma. Užduotis 7.22 Sugeneruokite duomenis duom &lt;- rnorm(62, 180, 20). Reikšmes susirstykite į grupes „didelis“ ir „mažas“. Pirmoje grupėje turi būti reikšmės didesnės už medianą, antroje – mažesnės. Tą pačią duomenų eilutę suskirstykite į 5 reikšmių grupes. Kokia duomenų „R“ klasė (duomenų tipas)? 7.5.5 Skaičių formatavimas Šio poskyrio medžiaga dar nepateikta. Šią savaitę jos neanalizuosime. Šiame skyriuje bus kalbama apie funkcijas, tokias kaip format() ar formatC(), kurios skaičius suapvalina ir pateikia norimu „gražiu“ formatu, skirtu ataskaitoms. Užduotis 7.23 (Užduotis dar nepateikta) 7.6 Darbas su loginiais kintamaisiais Loginiai kintamieji – tai „R“ duomenų tipas, kuris atsiranda atlikus palyginimo arba loginio patikrinimo operacijas, kai atsakymas būna TRUE (loginė reikšmė „taip“, „tiesa“) arba FALSE („ne“, „netiesa“). Trumpieji reikšmių variantai pademonstruoti lentelėje 7.1. Įprastai loginiai kintamieji trumpinami lgl. Susikurkime loginių reikšmių vektorių: lgl_seka &lt;- c(T, T, T, F, F, F, F, T, F, T, F, F) lgl_seka ## [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE ## [12] FALSE Kiek elementų iš viso? n &lt;- length(lgl_seka) n ## [1] 12 Norint statistiškai apdoroti pačias logines reikšmes, jos įprastai verčiamos į kategorinius kintamuosius, kaip tai daroma su tekstiniais kintamaisiais (žr. skyriuje „7.4.1 Faktorių kūrimas“). 7.6.1 Palyginimo operacijos Palyginimo operacijos, kurių rezultatas yra loginės reikšmės, pateiktos lentelėje 7.6. Lentelė 7.6: Palyginimą atliekantys „R“ operatoriai. TRUE yra loginė reikšmė „taip“, „tiesa“, FALSE – „ne“, „netiesa“. Operatorius Atliekamas palyginimas Pavyzdys Pavyzdžio atsakymas &lt; Ar mažiau 5 &lt; 8 TRUE &gt; Ar daugiau 5 &gt; 7 FALSE &lt;= Ar mažiau arba lygu 3 &lt;= 4 TRUE &gt;= Ar daugiau arba lygu 6 &gt;= 3 TRUE == Ar lygu 3 == 2 FALSE != Ar nelygu 3 != 2 TRUE %in% Ar tai vienas iš … &quot;C&quot; %in% c(&quot;G&quot;, &quot;M&quot;, &quot;C&quot;) TRUE Užduotis 7.24 7.6.2 Loginės operacijos Palyginimo operacijos rezultatą modifikuojantys operatoriai: ! – neiginys (loginė operacija „NE“): iš FALSE („ne“) padaro TRUE („taip“), iš TRUE → FALSE; !(amžius &lt; 22): „amžius nemažesnis už 22“. Operatoriai, skirti sujungti kelias palyginimo sąlygas: | – jungtukas „ARBA“ (loginė operacija „ARBA“): pvz., kai tikriname, ar diena ne darbo, jei nedirbame per šventes ir sekmadieniais; diena == &quot;šventinė&quot; | savaitės_diena == &quot;sekmadienis&quot;: „diena yra arba šventinė, arba savaitės diena yra sekmadienis“. &amp; – jungtukas „IR“ (loginė operacija „IR“): pvz., kai tikriname, ar tai vyras, jaunesnis nei 35 metai; lytis == &quot;vyras&quot; &amp; amžius &lt; 35: „ir vyras, ir jaunesnis nei 35“. Kitos sąlygų patikrinimui naudingos funkcijos: is.na() – tikrina, ar eilutėje esanti reikšmė yra praleista (NA): is.na(NA); !is.na() – tikrina, ar eilutėje esanti reikšmė nėra praleista: !is.na(NA); between(), t. y., dplyr::between(),– tikrina, ar skaičius yra tam tikrame intervale imtinai: between(10, left = 11, right = 20). Įvykdę komandas ?Comparison bei ??base::logic daugiau informacijos rasite „R“ dokumentacijoje. Užduotis 7.25 7.6.3 Loginiai kintamieji kaip skaičiai Vykdant analizę dažnai panaudojama tokia savybė – atliekant matematinius veiksmus, „R“ loginius kintamuosius automatiškai paverčia į skaičius: TRUE → 1; FALSE → 0. Todėl sum() apskaičiuoja, keli elementai, o mean() parodo, kuri dalis (skaičius nuo 0 iki 1) tenkina sąlygą (yra TRUE). sum(lgl_seka) # Sekoje yra 5 TRUE reikšmės ## [1] 5 mean(lgl_seka) # Sekoje yra 41,7% TRUE reikšmių ## [1] 0.4166667 Taikymo pavyzdžiai: Kiek kartų pasikartoja žodis „Vilnius“ ir kurią reikšmių dalį jis užima duomenų eilutėje? miestai &lt;- c(&quot;Vilnius&quot;, &quot;Vilnius&quot;, &quot;Kaunas&quot;, &quot;Vilnius&quot;, &quot;Klaipėda&quot;, &quot;Kaunas&quot;, &quot;Alytus&quot;) sum(miestai == &quot;Vilnius&quot;) ## [1] 3 mean(miestai == &quot;Vilnius&quot;) ## [1] 0.4285714 Kiek kartų pasikartoja žodžiai „Vilnius“ bei „Alytus“ ir kurią reikšmių dalį jie užima duomenų eilutėje? sum(miestai %in% c(&quot;Vilnius&quot;, &quot;Alytus&quot;)) ## [1] 4 mean(miestai %in% c(&quot;Vilnius&quot;, &quot;Alytus&quot;)) ## [1] 0.5714286 Kurią procentinę duomenų eilutės reikšmių dalį sudaro praleistos reikšmės? Atsakymą pateikti dešimtosios dalies tikslumu. eilute &lt;- c(1:3, NA, 1:14, NA, NA, NA, 22:25, NA, NA, 1:6, NA, NA, NA, NA) ar_trukstama &lt;- is.na(eilute) (ats1 &lt;- mean(ar_trukstama) * 100) # dalis procentais ## [1] 27.02703 # Pašalins paskutinius skaičius, jei jie yra nuliai (ats2a &lt;- round(ats1, digits = 1)) ## [1] 27 paste(&quot;Trūkstamų reikšmių dalis yra&quot;, ats2a, &quot;%.&quot;) ## [1] &quot;Trūkstamų reikšmių dalis yra 27 %.&quot; # Paliks paskutinius skaičius, net jei jie yra nuliai (ats2b &lt;- formatC(ats1, digits = 1, format = &quot;f&quot;)) ## [1] &quot;27.0&quot; paste(&quot;Trūkstamų reikšmių dalis yra&quot;, ats2b, &quot;%.&quot;) ## [1] &quot;Trūkstamų reikšmių dalis yra 27.0 %.&quot; Užduotis 7.26 Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["teorija-grafikai.html", "8. Grafikai (teorija) 8.1 Grafikai vieno kintamojo apibendrinimui 8.2 Diagramų palyginimas Klausimai ir komentarai", " 8. Grafikai (teorija) Šioje dalyje pateikta teorinė medžiaga apie dažnai statistinėms suvestinėms atlikti naudojamus grafikus. Peržiūrėkite šioje dalyje pateiktą video medžiagą, išnagrinėkite grafikus. Bet pirmiausia keletas svarbių sąvokų: Kintamojo reikšmių pasiskirstymas, arba skirstinys (angl. distribution), – tai būdas arba taisyklė, kaip išsidėsto mūsų tiriamo kintamojo reikšmės: kai kurios reikšmės pasitaiko dažniau, kai kurios rečiau, kai kurių gali apskritai nebūti. Statistinis dažnis (angl. frequency) parodo, kaip dažnai reikšmė pasitaiko duomenų eilutėje. Dažnių lentelė (angl. frequency table) parodo, kaip dažnai kiekviena iš reikšmių pasitaiko arba kaip dažnai patenka į tam tikrą reikšmių intervalą. Reikšmių grupavimas į intervalus angliškai vadinamas binning, o tokio tipo intervalas – bin. Mediana (žymėsime Md) – tai reikšmė, duomenų eilutę dalinanti į 2 lygias dalis. Įprastai tai vidurinė duomenų eilutės reikšmė arba dviejų vidurinių reikšmių vidurkis. Moda (žymėsime Mo) – dažniausiai pasitaikanti duomenų eilutės reikšmė. Taip pat moda galima vadinti dažniausiai pasitaikančių reikšmių intervalą, jei duomenys grupuoti. Duomenų sklaidos matai parodo, ar duomenys nuo centro nutolę daug, ar nedaug. 8.1 Grafikai vieno kintamojo apibendrinimui 8.1.1 Kategoriniams duomenims Šie grafikai tinkami nominaliesiems, ranginiams ir kiekybiniams diskretiesiems duomenims. Video epizodas 8.1 Stulpelinė diagrama. 8.1.2 Tolydiesiems duomenims Šie grafikai tinkami kiekybiniams tolydiesiems ir kokybiniams diskretiesiems duomenims. Video epizodas 8.2 Histograma. Pav. 8.1: Pavyzdys, kaip analizuoti histogramą. Pav. 8.2: Histogramos grupavimo intervalo pločio parinkimas. A – per siauras intervalas (per didelis intervalų skaičius) išryškina triukšmą ir paslepia tendenciją. D – per platūs intervalai (per mažas intervalų skaičius) taip pat paslepia tikrąją tendenciją. B, C – tinkamai parinktas intervalų skaičius, matoma tendencija. B – geriausias variantas. Įprastai reikia tarp 5 ir 15 intervalų. Video epizodas 8.3 Branduolinio tankio diagrama. Pav. 8.3: Vienas duomenų taškas atvaizduotas branduoline kreive. Branduolinio tankio diagramoje vienas taškas aprašomas kreive, vadinama branduoliu, kuri ties centru aukščiausia, o į kraštus mažėja. Pavyzdyje (A, B, C, D) tai Gauso kreivės, kurios gali skirtis savo pločiu. Branduolio formą ir plotį pasirenka tyrėjas, visgi kiekvienam grafiko taškui aprašyti naudojami identiški branduoliai. Pav. 8.4: Branduolinio tankio diagramoje (BTD) atvaizduoti visi duomenų eilutės taškai. Svarbu pasirinkti tinkamą branduolio plotį. A – per siauri branduoliai ne pakankamai gerai suglotnina kreivę, matosi triukšmas, sunku įžiūrėti tendenciją. D – per platūs branduoliai per daug suglotnina duomenis, BTD smarkiai išeina už realių duomenų ribų, taip pat nesimato tikrosios tendencijos. B, C – pakankamai gerai parinktas branduolio plotis C – geriausias variantas. Pav. 8.5: Informacijos branduolinio tankio (BTD) ir stačiakampėje diagramoje palyginimas. Abiejų tipų diagramose atvaizduoti tie patys duomenys. \\(Md\\) – mediana, \\(Q_1\\), \\(Q_3\\) – pirmasis ir trečiasis kvartiliai. Pav. 8.6: Branduolinio tankio diagramos (BTD) naudojimas grupių lyginimui. Iš grafiko matosi, kad S. pratensis augalai turėjo santykinai daugiau ilgesnių stiebų nei S. officinalis (nes mėlynas grafikas pasislinkęs į didesnių reikšmių pusę). Video epizodas 8.4 Stačiakampė diagrama (J.W. Tukey stiliaus). Video epizodas 8.5 Stačiakampė, smuikinė ir pasklaidytų taškų diagramos. 8.2 Diagramų palyginimas Grafiniam informacijos palyginimui, pateiktam šio poskyrio grafikuose 8.7, 8.8, 8.9, 8.10, 8.11, 8.12, buvo dirbtinai sugeneruoti duomenys. Kintamasis „Reikšmė“ padalintas į 8 duomenų grupes (nuo A iki H). Grupė A yra kontrolinė. Visos kitos nuo jos skiriasi pagal vieną konkretų požymį: imties dydį (n): A grupėje n = 250 (didesnė grupė), B – n = 63 (keturis kartus mažesnė grupė); centro padėtį: A vidurkis yra 50 (vidutiniškai didesnės reikšmės), C – 40 (vidutiniškai mažesnės reikšmės); sklaidą: A standartinis nuokrypis (SD) yra 5 (mažesnė sklaida), D – 10 (didesnė sklaida); viršūnių skaičių: A viena viršūnė, E – dvi viršūnės; simetriją: A pasiskirstymas simetriškas, F – dešinioji asimetrija (skirstinio „uodega“ nutįsusi į didelių reikšmių pusę); simetriją: A pasiskirstymas simetriškas, G – kairioji asimetrija (skirstinio „uodega“ nutįsusi į mažų reikšmių pusę); išskirtis: A ryškių išskirčių nėra, H – yra du labai smarkiai nuo centro nutolę taškai. Peržvelkite žemiau pateiktus grafikus ir įvertinkite, kaip ši informacija juose matoma. Pav. 8.7: Grupių palyginimas duomenis atvaizduojant taškais. Visi taškai išsidėstę į vieną liniją. Kai taškai persidengia, grafikas tampa mažai informatyvus. Pav. 8.8: Grupių palyginimas duomenis atvaizduojant pasklaidytų taškų diagrama. Siekiant išvengti persidengimo, taškai pasklaidyti x ašiai lygiagrečia kryptimi. Pav. 8.9: Grupių palyginimas duomenis atvaizduojant histograma. Pav. 8.10: Grupių palyginimas duomenis atvaizduojant branduolinio tankio diagrama (BTD). Pav. 8.11: Grupių palyginimas duomenis atvaizduojant stačiakampe diagrama. Pav. 8.12: Grupių palyginimas duomenis atvaizduojant smuikine diagrama. Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["zodynai.html", "A Žodynėliai A.1 Kompiuterijos terminai A.2 Programavimo ir matematikos terminai (anglų-lietuvių) A.3 Simbolių pavadinimai (anglų-lietuvių) A.4 Statistikos terminai (aiškinamasis žodynas) A.5 Statistikos terminai (anglų-lietuvių) Klausimai ir komentarai", " A Žodynėliai A.1 Kompiuterijos terminai Anglų–lietuvių kalbų kompiuterijos žodynas Enciklopedinis kompiuterijos žodynas A.2 Programavimo ir matematikos terminai (anglų-lietuvių) A.3 Simbolių pavadinimai (anglų-lietuvių) A.4 Statistikos terminai (aiškinamasis žodynas) Žodynėlis (statistikos terminai) A.5 Statistikos terminai (anglų-lietuvių) Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["priedas-r-sesijos-info.html", "B R sesijos informacija", " B R sesijos informacija „R“ ir šios programos paketų versijos bei kita techninė darbo programa „R“ sesijos informacija šios svetainės kūrimo metu. devtools::session_info() ## - Session info ----------------------------------------------------------------------------------- ## setting value ## version R version 3.5.2 (2018-12-20) ## os Windows 10 x64 ## system x86_64, mingw32 ## ui RStudio ## language (EN) ## collate Lithuanian_Lithuania.1257 ## ctype Lithuanian_Lithuania.1257 ## tz Europe/Helsinki ## date 2019-02-18 ## ## - Packages --------------------------------------------------------------------------------------- ## ! package * version date lib source ## assertthat 0.2.0 2017-04-11 [1] CRAN (R 3.5.0) ## backports 1.1.3 2018-12-14 [1] CRAN (R 3.5.1) ## bookdown 0.9 2018-12-21 [1] CRAN (R 3.5.2) ## boot 1.3-20 2017-08-06 [2] CRAN (R 3.5.2) ## broom 0.5.1.9000 2019-02-05 [1] Github (tidymodels/broom@66411c4) ## callr 3.1.1 2018-12-21 [1] CRAN (R 3.5.2) ## cellranger 1.1.0.9000 2018-05-21 [1] Github (rsheets/cellranger@7ecde54) ## cli 1.0.1 2018-09-25 [1] CRAN (R 3.5.1) ## colorspace 1.4-0 2019-01-13 [1] CRAN (R 3.5.2) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 3.5.1) ## crosstalk 1.0.0 2016-12-21 [1] CRAN (R 3.5.0) ## desc 1.2.0 2018-05-01 [1] CRAN (R 3.5.0) ## DescTools 0.99.27 2019-01-19 [1] CRAN (R 3.5.2) ## devtools 2.0.1 2018-10-26 [1] CRAN (R 3.5.1) ## digest 0.6.18 2018-10-10 [1] CRAN (R 3.5.1) ## dplyr 0.8.0.1 2019-02-15 [1] CRAN (R 3.5.2) ## evaluate 0.13 2019-02-12 [1] CRAN (R 3.5.2) ## expm 0.999-3 2018-09-22 [1] CRAN (R 3.5.1) ## forcats 0.3.0 2018-02-19 [1] CRAN (R 3.5.0) ## foreign 0.8-71 2018-07-20 [1] CRAN (R 3.5.1) ## fs 1.2.6 2018-08-23 [1] CRAN (R 3.5.1) ## generics 0.0.2 2018-12-09 [1] Github (r-lib/generics@d59e6b4) ## ggplot2 3.1.0 2018-10-25 [1] CRAN (R 3.5.1) ## glue 1.3.0 2018-07-17 [1] CRAN (R 3.5.1) ## gtable 0.2.0 2016-02-26 [1] CRAN (R 3.5.0) ## haven 2.0.0 2018-11-22 [1] CRAN (R 3.5.1) ## highr 0.7 2018-06-09 [1] CRAN (R 3.5.0) ## hms 0.4.2.9001 2019-02-05 [1] Github (tidyverse/hms@cb175bb) ## htmltools 0.3.6 2017-04-28 [1] CRAN (R 3.5.0) ## htmlwidgets 1.3 2018-09-30 [1] CRAN (R 3.5.1) ## httpuv 1.4.5.1 2018-12-18 [1] CRAN (R 3.5.2) ## httr 1.4.0 2018-12-11 [1] CRAN (R 3.5.1) ## icon 0.1.0 2018-09-18 [1] Github (ropenscilabs/icon@a510f88) ## jpeg 0.1-8 2014-01-23 [1] CRAN (R 3.5.0) ## jsonlite 1.6 2018-12-07 [1] CRAN (R 3.5.1) ## knitr 1.21.7 2019-02-05 [1] Github (yihui/knitr@57cee67) ## labeling 0.3 2014-08-23 [1] CRAN (R 3.5.0) ## later 0.8.0 2019-02-11 [1] CRAN (R 3.5.2) ## lattice 0.20-38 2018-11-04 [2] CRAN (R 3.5.2) ## lazyeval 0.2.1 2017-10-29 [1] CRAN (R 3.5.0) ## lubridate 1.7.4 2018-04-11 [1] CRAN (R 3.5.0) ## magrittr 1.5 2014-11-22 [1] CRAN (R 3.5.0) ## manipulate 1.0.1 2014-12-24 [1] CRAN (R 3.5.0) ## MASS 7.3-51.1 2018-11-01 [2] CRAN (R 3.5.2) ## Matrix 1.2-15 2018-11-01 [2] CRAN (R 3.5.2) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 3.5.0) ## mime 0.6 2018-10-05 [1] CRAN (R 3.5.1) ## modelr 0.1.3 2019-02-05 [1] CRAN (R 3.5.2) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 3.5.0) ## mvtnorm 1.0-8 2018-05-31 [1] CRAN (R 3.5.0) ## packrat 0.5.0 2018-11-14 [1] CRAN (R 3.5.1) ## pillar 1.3.1 2018-12-15 [1] CRAN (R 3.5.1) ## pkgbuild 1.0.2 2018-10-16 [1] CRAN (R 3.5.1) ## pkgconfig 2.0.2 2018-08-16 [1] CRAN (R 3.5.1) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 3.5.1) ## plyr 1.8.4 2016-06-08 [1] CRAN (R 3.5.0) ## png 0.1-7 2013-12-03 [1] CRAN (R 3.5.0) ## prettyunits 1.0.2 2015-07-13 [1] CRAN (R 3.5.0) ## processx 3.2.1 2018-12-05 [1] CRAN (R 3.5.1) ## promises 1.0.1 2018-04-13 [1] CRAN (R 3.5.0) ## ps 1.3.0 2018-12-21 [1] CRAN (R 3.5.2) ## purrr 0.3.0 2019-01-27 [1] CRAN (R 3.5.2) ## R.methodsS3 1.7.1 2016-02-16 [1] CRAN (R 3.5.0) ## R.oo 1.22.0 2018-04-22 [1] CRAN (R 3.5.0) ## R.utils 2.8.0 2019-02-14 [1] CRAN (R 3.5.2) ## R6 2.4.0 2019-02-14 [1] CRAN (R 3.5.2) ## Rcpp 1.0.0 2018-11-07 [1] CRAN (R 3.5.1) ## readr 1.3.1 2018-12-21 [1] CRAN (R 3.5.2) ## readxl 1.3.0 2019-02-15 [1] CRAN (R 3.5.2) ## remotes 2.0.2 2018-10-30 [1] CRAN (R 3.5.1) ## D rJava 0.9-10 2018-05-29 [1] CRAN (R 3.5.0) ## rlang 0.3.1 2019-01-08 [1] CRAN (R 3.5.2) ## rmarkdown 1.11.3 2019-02-05 [1] Github (rstudio/rmarkdown@c6b361f) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.5.0) ## rstudioapi 0.9.0 2019-01-09 [1] CRAN (R 3.5.2) ## rvest 0.3.2 2016-06-17 [1] CRAN (R 3.5.0) ## scales 1.0.0 2018-08-09 [1] CRAN (R 3.5.1) ## sessioninfo 1.1.1.9000 2018-12-01 [1] Github (r-lib/sessioninfo@ac8fcc1) ## shiny 1.2.0 2018-11-02 [1] CRAN (R 3.5.1) ## stringi 1.3.1 2019-02-13 [1] CRAN (R 3.5.2) ## stringr 1.4.0 2019-02-10 [1] CRAN (R 3.5.2) ## testthat 2.0.1 2018-10-13 [1] CRAN (R 3.5.1) ## tibble 2.0.1 2019-01-12 [1] CRAN (R 3.5.2) ## tidyr 0.8.2 2018-10-28 [1] CRAN (R 3.5.1) ## tidyselect 0.2.5 2018-10-11 [1] CRAN (R 3.5.1) ## usethis 1.4.0 2018-08-14 [1] CRAN (R 3.5.1) ## withr 2.1.2 2018-03-15 [1] CRAN (R 3.5.1) ## xfun 0.4 2018-10-23 [1] CRAN (R 3.5.1) ## xlsx 0.6.1 2018-06-11 [1] CRAN (R 3.5.0) ## xlsxjars 0.6.1 2014-08-22 [1] CRAN (R 3.5.0) ## xml2 1.2.0.9000 2018-11-20 [1] Github (hadley/xml2@de9781d) ## xtable 1.8-3 2018-08-29 [1] CRAN (R 3.5.1) ## yaml 2.2.0 2018-07-25 [1] CRAN (R 3.5.1) ## ## [1] D:/Dokumentai/R/win-library/3.5 ## [2] C:/Program Files/R/R-3.5.2/library ## ## D -- DLL MD5 mismatch, broken installation. "],
["saltiniai.html", "Informacijos šaltiniai", " Informacijos šaltiniai "]
]
