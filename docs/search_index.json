[
["index.html", "Biostatistika Kurso svetainė Pradžia", " Biostatistika Kurso svetainė Vilmantas Gėgžna Pradžia Medžiaga atnaujinta: 2019-05-04 Šios svetainės turiniui taikoma tarptautinė Creative Commons 4.0 (Priskyrimas – Nekomercinis platinimas – Analogiškas platinimas) licencija, nebent šalia konkretaus elemento nenurodyta kitaip. Jei konkretus elementas (pvz., paveikslas) yra paimtas iš kito šaltinio (parašyta šalia elemento arba pateikta nuoroda), tada jam taikoma pradiniame šaltinyje apibrėžta licencija. "],
["apie.html", "Apie Apie šią svetainę Reikalavimai studentui", " Apie Apie šią svetainę Šioje svetainėje pateikiama pagalbinė medžiaga kurso „Biostatistika“ (2019) bei „Biometrija“ (2019) pratyboms. Šio kurso metu susipažinsime su statistinei duomenų analizei naudojamais įrankiais, tokiais kaip: Programa „R“; Patogesniam darbui su „R“ skirta aplinka (programa) „RStudio“: \\(R \\neq RStudio\\)! Ataskaitų rengimui skirtomis „R“ galimybėmis, pvz., „R Markdown“ dokumentais. Svetainės valdymas klavišais Šios svetainės valdymas klaviatūra: Norėdami paslėpti (ar vėl rodyti) turinį, paspauskite klavišą S. Naudodami rodykles ← ar →, galite pereiti į kitą temą. Norėdami atlikti paiešką visoje svetainėje, paspauskite klavišą F. Funkcija veikia ne visose naršyklėse. Pastabos Pastaba 1. Kiekvieno skyriaus gale yra vieta (DISQUS forumas), kurioje galite pateikti komentarą, patarimą, pastabą ar klausimą. Būkite mandagūs, tolerantiški, supratingi, laikykitės raštvedybos ir kitų universiteto studentams prideramų taisyklių. Pastaba 2. Svetainėje esanti mokomoji medžiaga yra orientuota į operacinės sistemos „Windows“ naudotojus. Kitų sistemų naudotojams kai kurios instrukcijos gali šiek tiek skirtis. Pastaba 3. Lokalė – kompiuteryje ir jo programinėje įrangoje naudojamų elementų, priklausančių nuo kalbos ir kultūros normų, visuma (šaltinis: ). Paprasčiau sakant – tai nuo kalbos ir vietovės priklausančios programų bei dokumentų savybės, pvz., mėnesių pavadinimai skirtingomis kalbomis. Detalesnį paaiškinimą galite rasti enciklopediniame kompiuterijos žodyne . Daugelis šioje svetainėje rodomų pavyzdžių pateikti darant prielaidą, kad programoje „R“ pasirinkta lietuviškoji lokalė, kurią nustatyti galite naudodami programos „R“ komandą: # „Windows“ naudotojams Sys.setlocale(locale = &quot;Lithuanian&quot;) # „Mac OS“ ir kai kurioms „Linux“ versijoms Sys.setlocale(locale = &quot;lt_LT.UTF-8&quot;) Sys.setlocale(locale = &quot;lt_LT.utf8&quot;) „Linux“ sistemų naudotojai visas įdiegtas lokales gali sužinoti parašę komandą system(&quot;locale -a&quot;). Įprastai lokalę reikia pakeisti kiekvieną kartą perkrovus programą „R“. Jei programoje „R“ nustatyta lokalė veikia neteisingai, įsitikinkite, kad jūsų kompiuterio operacinės sistemos lokalė taip pat lietuviška (kai kuriais atvejais, operacinės sistemos lokalė gali užgožti programoje „R“ nustatytąją). Dėžučių reikšmės Knygoje naudojamų spalvotų dėžučių reikšmės: Informacija. Užduotys. Rekomendacija arba pastaba. Pastaba. Įspėjimas ir vengtini dalykai. Reikalavimai studentui Įgūdžiai Anglų kalba (gebėjimas analizuoti literatūrą, audio ir video šaltinius). Darbo kompiuteriu įgūdžiai: elementaraus kompiuterinio raštingumo įgūdžiai; gebėjimas internete susirasti reikiamą informaciją: „Google Search“, „YouTube“, t.t.; gebėjimas pagal instrukcijas parsisiųsti ir įsidiegti reikiamas programas. Reikmenys pratyboms Nuosavos ausinės pratybų metu (privaloma). Kompiuteris su „Windows“, „Linux“ arba „Mac OS“ operacine sistema. Arba prieiga prie tokio kompiuterio namų darbams atlikti. Reikmenys paskaitoms (Rekomenduojama) Išmanusis įrenginys (telefonas, planšetė, …) arba kompiuteris: turintis prieigą prie interneto, pvz.,galintis prisijungti prie tinklalapių quizizz.com/join ir kahoot.it ; kurio baterija įkrauta pakankamai arba turėti krovimo laidą. "],
["diegimas.html", "1. Programų diegimas ir nustatymai 1.1 Apie programą R 1.2 Pastabos prieš diegiant 1.3 Pagrindinės programos 1.4 R paketų diegimas 1.5 Programų konfigūravimas 1.6 Papildomos instrukcijos 1.7 Paskyros Klausimai ir komentarai", " 1. Programų diegimas ir nustatymai 1.1 Apie programą R „R“ – tai duomenų analizei skirta kompiuterinė programa (pav. 1.1), turinti ir interaktyvios duomenų analizės, ir programavimo galimybes. Pagal savo paskirtį „R“ orientuota į (statistinę) duomenų analizę ir duomenų vaizdinimą. Tačiau programos funkcionalumą smarkiai išplečia daugybė (virš 14000!) papildinių, dar vadinamų paketais, kurie leidžia spręsti įvairioms mokslo šakoms aktualius skaičiavimo, duomenų pertvarkymo, parengimo analizei bei vaizdinimo uždavinius, kurti automatizuotas ataskaitas ir pateikti jas įvairiomis formomis, pvz., internetinio tinklalapio ar „Microsoft Word“ formatu, rašyti mokslinius straipsnius, net knygas! Ši mokomoji medžiaga taip pat sukurta naudojantis „R“. Pav. 1.1: Programos „R“ logotipas . Programa „R“ – GNU projekto dalis, yra visiškai nemokama ir laisvai platinama. Jos vystymu rūpinasi „R“ fondas (The R Foundation). Daugiau informacijos apie programą rasite svetainėje www.r-project.org. Jei programos ir jai skirtų papildinių dar neturite, toliau bus rašoma, kaip juos parsisiųsti ir įsidiegti į savo kompiuterį. Įspėjimas: programa „R“ nėra pakaitalas jūsų smegenų darbui. Tikslas – atsisiųsti, įsidiegti ir susikonfigūruoti programas „R“, „RStudio“ ir bei svarbiausius „R“ papildinius, vadinamus paketais. 1.2 Pastabos prieš diegiant Kelios bendrosios pastabos prieš diegiantis programas. Pastaba 1. Šiame skyriuje nurodytos programos yra visiškai nemokamos naudoti akademiniais tikslais. Pastaba 2. Ši svetainė (ir joje esančios instrukcijos) orientuota į operacinės sistemos „Windows“ vartotojus. Kitų sistemų vartotojams kai kurios instrukcijos gali skirtis. Pastaba 3. Diegiantis programas procesai vyks greičiau, jei bus įjungtas sparčiojo veikimo režimas (angl., high performance), išjungtas kompiuterio energijos taupymas bei įjungtas kompiuterio krovimo laidas (žr. skyriuje „Sparčiojo veikimo režimas“). Ši pastaba galios ir tada, kai programa „R“ atliksite skaičiavimus. Tad pratybų metu naudodami savo kompiuterį naudokite ir krovimo laidą. Pastaba 4. Aplanko, į kurį bus įdiegtos programos „R“, „RStudio“ bei jų papildiniai, pavadinimuose esančios raidės gali būti tik angliškos, t. y., nei vienoje pavadinimo dalyje negali būti nei lietuviškų, nei rusiškų, nei kiniškų ar kitokių neangliškų simbolių: BLOGAI: C:/ĄĄĄĄČĘ C:/žurnalas/programos/R C:/dokumentai/Žygimantas/R D:/biostatistiką/R TINKA: C:/AAAACE C:/zurnalas/programos/R C:/dokumentai/Zygimantas/R D:/biostatistika/R Įsidiegti pavyks, bet kils problemų dirbant. Tad pasirinkite tinkamą aplanko pavadinimą. Kita pastaba taikytina tik tada, jei paketus diegiate pakartotinai. Pastaba 5. Jei programos „R“ paketus diegti nusprendėte darbo metu, perkraukite programą „R“, kad neliktų užkrautų paketų, kurie trukdytų diegimui ar atnaujinimui. Rekomenduojama apskritai uždaryti „RStudio“ projektą, jei jį buvote atidarę. Pastaba 6. Jei diegiant paketus įvyko klaida, perskaitykite, ką programa „R“ parašė. Jei nesuprantate žinutės esmės ar nežinote sprendimo, naudokite „Copy-Paste-Google“ metodą (nukopijuokite klaidos žinutės esmę į „Google“ internetinės paieškos sistemą ir atsakymą raskite internete). Tai bene greičiausias būdas rasti sprendimą. 1.3 Pagrindinės programos Video medžiagoje 1.1 pateikti pavyzdžiai, kaip atsisiųsti, įsidiegti ir atsidaryti reikiamas programas. Epizodas buvo skirtas ankstesnių metų kursui, todėl rodoma, kaip įsidiegti šiek tiek senesnes programų versijas. Tačiau esmė liko ta pati. Epizodo pabaigoje (po 9:58 min.) esanti informacija jau nebeaktuali. Nuorodos į reikiamus tinklalapius pateiktos kituose skyriuose. Jei kyla neaiškumų, naudingos nuorodos pateiktos skyriuje 1.6. Video medžiagą žiūrėdami pagreitintai – bent ×1,5 greičiu – taupysite laiką. Rekomenduojamas peržiūros greitis – ×2. Video epizodas 1.1 Video instrukcijos: „R“, „RStudio“, „Pandoc“ atsisiuntimas ir diegimas. Programos „Pandoc“ kol kas diegtis nereikia, nes ji yra „RStudio“ dalis. 1.3.1 Programa R Pirmiausia parsisiųsite programą „R“. Be jos negalėsite atlikti analizės. Programą rasite svetainėje https://cloud.r-project.org/ Pav. 1.2: Programos „R“ parsisiuntimas. Nueikite į svetainę https://cloud.r-project.org/. Atsidarys langas, kurio fragmentą matote A dalyje. Pasirinktie nuorodą pagal savo kompiuterio operacinę sistemą („Linux“, „Mac“ ar „Windows“). Naujai atsidariusiame lange (B) rinkitės „base“ (bazinis „R“ paketas). Kitame lange (C) bus rodoma naujausia „R“ versija (tarkim, 3.5.2). Spauskite „Download“ ir pradėkite siųstis programą. Pastaba: dabartinė programos versija yra naujesnė nei 3.4.1. Diegdami „R“ atkreipkite dėmesį į du dalykus: Pasirinkite aplanką, kurio pavadinime esančios raidės yra tik angliškos, t. y., nėra nei lietuviškų, nei rusiškų, nei kiniškų simbolių. Į aplanką, kurio pavadinime yra ne angliškų raidžių, programas įdiegti pavyks, bet vėliau dirbant kils problemų ir net neatrodys, kad jos kyla dėl aplanke esančių raidžių. Pasirinkite jūsų kompiuteriui tinkamas programos 32 ar 64 bitų bylų versijas, kaip pavaizduota paveiksle 1.3. Pav. 1.3: Programos „R“ diegimas. Programos branduolio („Core“) bylas įdiegti būtina. Taupantiems vietą kietajame diske: pasirinkite įsidiegti arba vien tik 64 bitų (A), arba 32 bitų (B) versiją, kuri labiau tinkama jūsų kompiuteriui. Jei jūsų kompiuteris naujesnis nei 3 metų senumo, rinkitės 64 bitų versiją. Jei dvejojate, kurią rinktis, rinkitės abi. Užduotis 1.1 Atsisiųskite ir įsidiekite programą „R“. 1.3.2 Programa RStudio Programa „RStudio“ yra darbui su „R“ skirta aplinka (angl. integrated development environment, IDE), skirta programai „R“. Trumpai tariant, tai kita programa, kuri palengvina darbą su „R“. Yra 2 „RStudio“ tipai: Desktop (skirtas asmeniniam kompiuteriui) ir Server (skirtas serveriui). Mums reikalingas pirmasis. Parsisiųsti galime iš: https://www.rstudio.com/products/rstudio/download/ (pav. 1.4). Pav. 1.4: Programos RStudio parsisiuntimui skirto tinklalapio fragmentas. Tinklalapio apačioje yra skiltis „RStudio Desktop“, kurioje išvardintos asmeniniam kompiuteriui skirtos versijos: pasirinkite tą, kuri pritaikyta jūsų kompiuterio operacinei sistemai („Linux“, „Mac“ ar „Windows“). Pastaba: dabartinė programos versija yra naujesnė nei 1.1.419. Užduotis 1.2 Atsisiųskite ir įsidiekite naujausią programos „RStudio“ versiją. 1.3.3 Mac naudotojams Sistemos Mac naudotojams papildomai reikia atsisiųsti ir įsidiegti programą XQuartz, nes be jos neveiks papildinys R Commander. Daugiau instrukcijų galite rasti šiame tinklalapyje: nuoroda . Įsidiegę šią programą perkraukite kompiuterį ir tik tada tęskite darbą. 1.4 R paketų diegimas Paketas, tai standartizuotas „R“ papildinys, praplečiantis programos galimybes. Apie šiuos papildinius plačiau bus rašoma skyriuje „5 R paketai“. Dabar išmoksite atsisiųsti labiausiai reikalingus. Atsidarykite programą „RStudio“ ir į langą, pavadintą „Console“, nukopijuokite iš karto visas žemiau parašytas „R“ paketų diegimo komandas ir paspauskite Enter klavišą. Bus įdiegti nurodyti „R“ paketai. Įprasta, jei parsisiuntimo ir diegimo procesas užtruks iki 20-40 minučių ir prireiks apie 1 GB vietos kietajame diske. Jei interneto ryšys arba kompiuterio veikimas yra lėti, diegimas gali užtrukti ilgiau. Paketų diegimą tęskite iki galo, neišjunkite programos viduryje nebaigto proceso. Pavyzdys, kaip įdiegiamas paketas devtools, pateiktas pav. 1.5. Pav. 1.5: R paketo devtools diegimas programiškai. Lange „Console“ \\((A)\\) parašomas/įklijuojamas programos kodas \\((B)\\) ir paspaudžiamas klavišas Enter. Atsiranda „STOP“ ženkliukas \\((C)\\), užrašai, rodantys, kad paketai parsiunčiami ir diegiami \\((D)\\) bei atsisiuntimo progreso juosta, kuri iššoka daugybę kartų (čia neparodyta). Sėkmingai įsidiegus paketui, atsiranda apie tai pranešantys užrašai \\((E)\\), išnyksta „STOP“ ikona bei atsiranda „&gt;“ ženkliukas \\((F)\\), rodantis, kad „R“ laukia naujos komandos. Jei paketas nebūtų įdiegtas sėkmingai, „R“ taip pat parašytų priežastį. Jei dega „STOP“ ženkliukas, bet atrodo, kad diegimas nevyksta, įsitikinkite, kad nėra lentelės, pavaizduotos pav. 1.6 (ši lentelė gali būti „pasislėpusi“ už kitų langų) bei kad programa nelaukia jūsų sprendimo (pav. 1.7). Pav. 1.6: „R“ siūlo paketus įdiegti į asmeninę biblioteką. Pamatę analogišką lentelę, įsitikinkite, kad aplanko pavadinime nėra neangliškų (pvz., lietuviškų) raidžių ir spauskite „Yes“. Pav. 1.7: R klausia, ar įdiegti paketus, kuriuos reikia kompiliuoti (atlikti procedūrą, kurios pagalba paketai pritaikomi veikti jūsų kompiuteryje). Jei pasirodys analogiškas klausimas, įrašykite raidę „y“ ir paspauskite „Enter“. Naudojant naujausią „R“ versiją, vietoje 1.7 pav. vaizduojamų komandų iššoks lentelė panaši į pavaizduotąją pav. 1.6. Paketus diegiantis pirmą kartą tokio tipo lentelė įprastai iššoka 2 kartus. Kodas reikiamiems paketams diegti (visas kita spalva pažymėtas blokas): # R paketų diegimo komandos # Paketų diegimas iš saugyklos CRAN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ # Paketų parsisiuntimui install.packages(c(&quot;remotes&quot;, &quot;devtools&quot;, &quot;ctv&quot;)) # Rekomenduojami R paketai list_of_packages &lt;- c( # Vizualizavimui/Grafikams &quot;ggplot2&quot;, &quot;ggpubr&quot;, &quot;ggrepel&quot;, &quot;ggthemes&quot;, &quot;plotly&quot;, &quot;cowplot&quot;, &quot;qqplotr&quot;, # Kiti &quot;data.table&quot;, &quot;BBmisc&quot;, &quot;checkmate&quot;, &quot;infer&quot;, &quot;aplpack&quot;, &quot;arm&quot;, &quot;coda&quot;, &quot;leaps&quot;, &quot;lmtest&quot;, &quot;matrixcalc&quot;, &quot;sem&quot;, &quot;TH.data&quot;, &quot;rgl&quot;, &quot;mi&quot;, &quot;multcomp&quot;, &quot;mvtnorm&quot;, &quot;car&quot;, &quot;carData&quot;, &quot;RCurl&quot;, &quot;openxlsx&quot;, &quot;tidyselect&quot;, &quot;readxl&quot;, &quot;forcats&quot;, &quot;dplyr&quot;, &quot;stringi&quot;, &quot;stringr&quot;, &quot;tidyr&quot;, &quot;broom&quot;, &quot;tidyverse&quot;, &quot;skimr&quot;, &quot;rcompanion&quot;, &quot;sigr&quot;, &quot;fs&quot;, &quot;DescTools&quot;, &quot;shiny&quot;, &quot;PMCMR&quot;, &quot;PMCMRplus&quot;, &quot;officer&quot;, &quot;flextable&quot;, &quot;pander&quot;, &quot;descriptr&quot;, &quot;vcd&quot;, &quot;vcdExtra&quot;, &quot;fitdistrplus&quot;, &quot;Rcmdr&quot;, &quot;RcmdrMisc&quot;, &quot;RcmdrPlugin.EZR&quot;, &quot;RcmdrPlugin.KMggplot2&quot; ) # Rekomenduojamų paketų diegimas install.packages(list_of_packages, dependencies = c(&quot;Depends&quot;, &quot;Imports&quot;)) # Paketų diegimas pagal temas ctv::update.views(c(&quot;ReproducibleResearch&quot;, &quot;Graphics&quot;)) # Paketų diegimas iš GitHub saugyklų ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ remotes::install_github(&quot;GegznaV/RcmdrPlugin.EZR@ezr_as_menu&quot;, upgrade = TRUE) remotes::install_github(&#39;stefano-meschiari/latex2exp&#39;, upgrade = TRUE) remotes::install_github(&quot;ropenscilabs/skimr&quot;, ref = &quot;v2&quot;, upgrade = TRUE) remotes::install_github(&quot;GegznaV/addin.tools&quot;, upgrade = TRUE) remotes::install_github(&quot;GegznaV/addins.rmd&quot;, upgrade = TRUE) remotes::install_github(&quot;GegznaV/addins.rs&quot;, upgrade = TRUE) remotes::install_github(&quot;Rapporter/pander&quot;, upgrade = TRUE) # Pranešimas baigus diegti ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ message(&quot;Atlikta!&quot;) Paketus rvg ir ggstatsplot bandykite diegti po vieną. „Linux“ ir „Mac“ naudotojams gali reikti papildomų programų ar leidimų. Gali padėti informacija, esanti šiuose tinklalapiuose: https://indrajeetpatil.github.io/ggstatsplot/ https://github.com/davidgohel/rvg install.packages(&quot;rvg&quot;) install.packages(&quot;ggstatsplot&quot;) Jei kils neaiškumų ar nesklandumų peržiūrėkite skyriuose 1.4.1 ir 1.6 pateiktą informaciją. Taip pat padarykite ekrano nuotraukas (angl. print screen), nukopijuokite kitą svarbią informaciją, kurią galėtumėte pratybų metu parodyti dėstytojui. Užduotis 1.3 Įsidiekite nurodytus programos „R“ paketus. Jei kils problemų, skaitykite skyrių žemiau. 1.4.1 Kilus problemų dėl paketų diegimo… Jei jums neleidžiama diegti „R“ paketų dėl to, kad „R“ rekomenduojamos bibliotekos (aplanko) pavadinime yra lietuviškų raidžių, gali padėti pav. 1.8 esanti informacija, kaip nurodyti kitą aplanką diegimui. ATSARGIAI: tai pažengusiųjų lygio modifikacijos sistemai „Windows“. Atidarytuose languose nieko papildomai nekeiskite ir neištrinkite, nebent suprantate, ką darote. Pav. 1.8: Numatytojo aplanko „R“ paketams (bibliotekos) keitimas. Jums paieškos lange reikia rasti ir atsidaryti „Advanced system settings“ kortelę, o joje pasirinkti „Environment variables“ (aplinkos kintamieji). Aplinkos kintamųjų kortelėje pasirinkti naują vartotojo aplinkos kintamąjį. Naudotojo naujo aplinkos kintamojo kortelėje („New user variable“) esančiame laukelyje „Variable name“ \\((A)\\) reikia įrašyti „R_LIBS_USER“, o laukelyje „Variable value“ \\((B)\\) – aplanko, į kurį turi būti diegiami paketai, pavadinimą. Pavadinimą galima įrašyti, įkopijuoti arba susirasti naudojant „Browse Directory“ (naršyti aplankuose) mygtuką. Tai – pažengusiųjų lygio modifikacijos, tad būkite atidūs ir keiskite tik tai, ką keisti būtina. Išsaugoję nustatymus, kompiuterį perkraukite. PASTABA. Pakeitus šiuos nustatymus būtina perkrauti (angl. restart) kompiuterį ir tik tada tikrinti, ar jie išsprendė problemą. 1.5 Programų konfigūravimas 1.5.1 Sparčiojo veikimo režimas Dirbant duomenų analizės programomis kai kurie veiksmai reikalauja didelių skaičiuojamųjų kompiuterio resursų. Jei įjungtas energijos taupymo režimas, skaičiavimai užtruks ilgiau nei reikėtų. Todėl atliekant analizę siūlau: Įsijungti sparčiojo veikimo (angl. high-performance) režimą ir išjungti energijos taupymą. Taip skaičiavimai, paveikslų braižymas, didelių duomenų lentelių išsaugojimas bei panašūs veiksmai bus atlikti greičiau. Visgi žinokit, kad šiuo režimu kompiuteris vartoja daugiau energijos, ir dirbant „iš baterijos“ – greičiau išsikraus. Dirbti prisijungus kompiuterio krovimo laidą. Galima nustatyti, kad prisijungus laidą automatiškai būtų aktyvuojamas sparčiojo veikimo režimas. Windows 10 Pavyzdys, kaip operacinėje sistemoje „Windows 10“ pasirinkti sparčiojo veikimo režimą (planą), pateiktas pav. 1.9 bei šioje video medžiagoje: . Pav. 1.9: Pavyzdys, kaip sistemoje „Windows 10“ įsijungti sparčiojo veikimo režimą. Susiraskite baterijos ikoną darbalaukio meniu juostoje (1) ir paspauskite ją dešiniuoju pelės klavišu (2). Atsidariusiame meniu pasirinkite „Power Options“ arba atitikmenį kita kalba (3). Atsidarys langas, kuriame susiraskite ir pasirinkite sparčiojo veikimo režimą (planą), pvz., (A). Mano kompiuteryje yra 2 šio tipo planai (A, B). Jei rodomi ne visi – spauskite (C). Jei nėra reikiamo plano, jį susikurkite. Video pavyzdys: . 1.5.2 RStudio: UTF-8 koduotė dokumentams Parsisiuntę programą „R Studio“, ją susikonfigūruokite. Vienintelis privalomas nustatymas yra UTF-8 koduotės pasirinkimas dokumentams. (Jei nenustatysite UTF-8, dokumentuose negalėsite matyti lietuviškų, rusiškų ar kitokių anglų kalboje nenaudojamų simbolių.) Visi kiti nustatymai – tik rekomenduojami dėl patogumo. Detalios instrukcijos video medžiagoje, santrauka – paveiksle žemiau. Tam, kad išvengtume kai kurių problemų, susijusių su lietuvių kalbos atpažinimu, parinktį RStudio → Tools → Global Options → Code → Saving → Default text encoding nustatykite į UTF-8. Pav. 1.10: Schema, demonstruojanti, kaip pasirinkti, kad bylos RStudio aplinkoje būtų nuskaitomos naudojant UTF-8 standartą. 1.5.3 RStudio: kiti nustatymai Visos kitos šiame skyriuje siūlomos parinktys yra rekomendacinio pobūdžio. Video epizode 1.2 rodoma, kaip sukonfigūruoti RStudio, kurios versija 1.0.x (x – versijos papildymo numeris). Todėl naudojant naujausią 1.1.x ar 1.2.x versiją, nustatymų išdėstymas ir ikonų paveikslai skiriasi, tačiau principai liko tie patys. Video medžiagą žiūrėdami pagreitintai – bent ×1,5 greičiu – taupysite laiką. Rekomenduojamas peržiūros greitis – ×2. Video epizodas 1.2 Programos „RStudio“ parengimas darbui (konfigūravimas). Pav. 1.11: Priedas prie video medžiagos: rekomenduojama programos „R Studio“ (versija 1.2) konfigūracija. Geltonai pažymėti nustatymai, kurie skiriasi nuo numatytųjų. (Dėkoju Stepan Avdevič už pagalbą rengiant iliustraciją.) Norintys daugiau paaiškinimų, ką reiškia konkretūs nustatymai, juos gali rasti straipsnyje „Customizing RStudio“ . Užduotis 1.4 „RStudio“ nustatykite UTF-8 koduotę atidaromoms byloms. Pagal rekomendacijas atlikite kitus „RStudio“ konfigūracijos veiksmus. 1.6 Papildomos instrukcijos Papildomų programų diegimo instrukcijų, kurios gali būti naudingos visų operacinių sistemų naudotojams, galite rasti: straipsnyje „Installing R and RStudio - Easy R Programming“ – bendrieji „R“ ir „RStudio“ diegimo klausimai „Windows“, „Linux“ ir „Mac“ sistemoms; tinklalapyje „R Commander Installation Notes“ – su papildinio „R Commander“ (paketas Rcmdr) diegimu susiję klausimai. 1.7 Paskyros 1.7.1 „Emokymai“ sistema Jūs vasario 4 d. automatiškai būsite prijungti prie kurso „Biostatistika ir biometrija“ VU „Emokymai“ sistemoje. Iš šios sistemos į VU studento el. pašto dėžutę bus siunčiami pranešimai, todėl dėžutę tikrinkite reguliariai. 1.7.2 „Data Camp“ paskyra Jums į VU studento el. pašto dėžutę bus atsiųstas pakvietimas nemokamai prisijungti prie mokomosios medžiagos „DataCamp“ sistemoje. Pakvietimą privalote priimti per 2 savaites nuo kurso pradžios. Jei laiško negausite per 1 savaitę nuo kurso pradžios, kreipkitės į teorinės dalies dėstytoją. 1.7.3 „GitHub“ paskyra Norint atlikti kai kurias papildomas užduotis, reikės paskyros svetainėje https://github.com. Pastaba: paskyra šioje svetainėje yra tarsi jūsų, kaip profesionalo, vizitinė kortelė. Žmonės, norintys parodyti savo programavimo ir duomenų analizės žinias, susikuria savo demonstracinių ar realių projektų portfelį. Užduotis 1.5 Susikurkite „GitHub“ paskyrą. Įsiminkite naudotojo vardą ir slaptažodį. Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["pradines-savokos.html", "2. Pradinės duomenų analizės sąvokos (teorija) 2.1 Statistinio tyrimo ciklas 2.2 Svarbiausia analizės dalis – klausimas 2.3 Generalinė aibė, imtis ir duomenys 2.4 Statistikos mokslas ir jo dalys 2.5 Kintamųjų tipai statistikoje 2.6 Duomenų saugojimo formos 2.7 Duomenų eilutės 2.8 Duomenų lentelės Klausimai ir komentarai", " 2. Pradinės duomenų analizės sąvokos (teorija) Šiame skyriuje susipažinsime su svarbiausiomis duomenų analizės sąvokomis. 2.1 Statistinio tyrimo ciklas Statistinio tyrimo eigą galime suskirstyti į 5 sąlygines dalis (pav. 2.1). Pav. 2.1: Statistinio tyrimo ciklas. Glaustas kiekvienos ciklo dalies apibūdinimas: Klausimas. Pirmiausia, iškeliame klausimą, susiformuluojame mokslinę problemą, kad žinotume, ką norime padaryti, į kokį klausimą atsakyti, kokią problemą išspręsti savo analize. (Žiūrėkite kitame poskyryje). Be klausimo nėra ir analizės tikslo. Planas. Kai jau žinome klausimą, galime susiplanuoti, kaip į jį atsakysime. Vėlesni tyrimo etapai negali atsverti ir ištaisyti prastai suplanuoto bei nekorektiškai atlikto tyrimo pasekmių. Duomenys. Surenkame duomenis, kurie yra tinkami atsakyti į išsikeltą klausimą. Duomenis parengiame analizei. Analizė. Padarome duomenų suvestines. Pagal klausimą ir duomenų savybes pasirenkame tinkamą tolimesnės analizės metodą. Atliekame šią analizę. Išvados. Grįsdami analizės rezultatais, padarome išvadas – atsakome į iškeltą klausimą. Įprastai gavus atsakymą į vieną klausimą, kyla dar keletas naujų klausimų. Tad toliau bandant atsakyti į naujuosius klausimus susidaro ciklas. Jei reikėtų pasirinkti, kas svarbiau atliekant tyrimą – analizės metodas, tinkami duomenys, tyrimo planas ar klausimas,– jūs turėtumėte aiškiai žinoti, kad pagal svarbą šie dalykai išsirikiuoja šitaip: klausimas (ir tikslas) → tyrimo planas → tinkami duomenys → analizės metodas. Jei neaišku kodėl – tada dar kartą perskaitykite kiekvienos statistinio tyrimo ciklo dalies apibūdinimą. 2.2 Svarbiausia analizės dalis – klausimas Prieš pradedant duomenų analizę, reikia aiškiai žinoti, kokiu tikslu ji yra daroma. Ir pagrindinis analizės tikslas – spręsti tam tikrą mokslinę, socialinę, verslo, medicininę, gamtinę ar kitokią realaus gyvenimo problemą bei atsakyti į tam tikrą specifinį klausimą, kuris buvo suformuluotas prieš atliekant analizę. Pvz., kuris šokoladas Lietuvos žmonėms labiau patinka (juodasis, pieniškas ar baltasis); kokią įtaką vienas papildomas euras, išleistas ledų reklamai, darytų įmonės pelnui; ar GMC studentai greičiau įsisavina kurso medžiagą, jei prie įprastos rašytinės medžiagos papildomai pateikiama video medžiaga; kurioje terpėje dumbliai greičiau auga; ar naujai kuriamas vaistas gali pailginti miego trukmę; ar pagal fenotipinius požymius galima atpažinti bakterijos genotipinius Gardnerella vaginalis pogrupius; ar kovų baidymas padeda reikšmingai sumažinti paukščių keliamą triukšmą Panevėžio mieste? Analizė, neturinti klausimo ir nesprendžianti problemos yra bevertė, nes neturi tikslo („analizė dėl analizės“). Tad tinkamas aiškiai ir konkrečiai suformuluotas klausimas – pati svarbiausia visos analizės dalis. Pav. 2.2: Klausimas – pati svarbiausia duomenų analizės dalis, nes suteikia analizei tikslą. Tinkamas aiškiai ir konkrečiai suformuluotas klausimas – pati svarbiausia tyrimo dalis. 2.3 Generalinė aibė, imtis ir duomenys Statistikoje yra keli svarbūs pradiniai terminai: generalinė aibė (populiacija), imtis bei duomenys (pav. 2.3). Pav. 2.3: Generalinė aibė, imtis ir duomenys. Iš visos tyrimo metu analizuojamos objektų visumos (generalinės aibės, GA) visiškai atsitiktinai arba kitu tikimybiniu būdu sudarome tiriamųjų imtį (paimame dalį GA). Tada išmatuojame ar užregistruojame vieną arba kelis mus dominančius tiriamųjų požymius ir taip gauname duomenis (duomenų imtį). Generalinė aibė (GA), arba populiacija (statistikos prasme),– tai statistinio tyrimo metu nagrinėjama objektų (arba jų savybių) visuma. Imtis – tai į tyrimą patekusi GA dalis (į tyrimą patekę objektai). Duomenys – tai imties objektų savybių reikšmės. Savybės gali būti kokybinės (pvz., spalva) bei kiekybinės (pvz., svoris). Imties dydis – tai imtyje esančių elementų (objektų, tiriamųjų, stebėjimų) skaičius. Pavyzdys. GA – tai visi 4-5 m. amžiaus naminiai šunys, imtis – tai į tyrimą patekę 4-5 m. amžiaus naminiai šunys, duomenys – į tyrimą patekusių šunų kailio spalva: šviesi, tamsi, marga, … Statistiniam tyrimui tinkama imtis privalo būti pakankamo dydžio ir reprezentatyvi. Reprezentatyvi imtis yra tokia, kurioje pakankamai tiksliai atsispindi visos GA savybės. Tai tarsi maža GA kopija. Imtis turi būti reprezentatyvi tai GA, apie kurią daromos statistinės išvados. Kitu atveju išvados bus klaidingos. T. y., jei imtyje yra tik vyresni nei 60 m. amžiaus vyrai, tai didelis klausimas, ar ištyrę juos galime daryti išvadas apie visus žmones, tarp kurių yra ir moterys, vaikai, kūdikiai bei jaunimas. Per mažo dydžio imtys yra nereprezentatyvios ir iš jų padarytos išvados, tikėtina, bus klaidingos. Vien tik didelis imties dydis irgi negarantuoja reprezentatyvumo, jei imtis sudaryta netinkamu būdu. Kelios pastabos: Atkreipkite dėmesį į tai, kad terminas „populiacija“ statistikoje reiškia ne tą patį, ką biologijoje, todėl, vengiant dviprasmybės, lietuvių kalba yra aprobuotas kitas statistinis terminas („populiacijos“ sinonimas) – generalinė aibė (GA). Terminas „imtis“ gali reikšti ir tiriamųjų imtį (pvz., į tyrimą įtraukti 4-5 m. amžiaus naminiai šunys) ir duomenų imtį (pvz., tyrimo metu užregistruota kiekvieno iš šių šunų kailio spalva). 2.4 Statistikos mokslas ir jo dalys Statistikos mokslą galima apibūdinti kaip tikslųjį mokslą (matematikos šaką) apie tyrimo planavimą, duomenų rinkimą, sisteminimą, kiekybinę analizę bei rezultatų interpretavimą. Biostatistika ir biometrija yra taikomosios statistikos šakos, orientuotos į medicininių ir biologinių duomenų analizę. Statistikos metodus galima suskirstyti į 3-4 pagrindines dalis, tokias kaip: Tyrimo planavimas (angl. study/experimental design) – prieš vykdant tyrimą, visa eiga turi būti kruopščiai suplanuojama: suplanuojama tai, kaip bus sudaryta tiriamųjų imtis, kuri yra tinkama atsakyti į pagrindinį tyrimo klausimą, kokio dydžio ši imtis turėtų būti, kaip bus renkami duomenys, kokius metodus ar bent jau kokio tipo metodus naudosime analizei; Aprašomoji statistika (angl. descriptive statistics) – grafiniai ir skaitiniai duomenų sisteminimo metodai. Jais apibūdiname esmines surinktų duomenų savybes, o tai padeda pasirinkti tolimesnę analizės eigą; Statistinių išvadų darymas (angl. inferential statistics) bei prognozavimas (angl. prediction) – analizės ir interpretavimo metodai, pagal imties duomenis leidžiantys daryti išvadas apie visą GA ir/arba prognozuoti. Tyrimo eiga nuo imties sudarymo iki statistinių išvadų ir prognozavimo gali būti atvaizduojama paveikslu 2.4: tam, kad statistinės išvados būtų pagrįstos, imtis turi būti sudaryta tinkamai – būti pakankamo dydžio ir reprezentatyvi, t.y., pagal savo sudėtį ir savybes proporcinga visai generalinei aibei. Pav. 2.4: Sąsaja tarp imties sudarymo, aprašomosios statistikos bei statistinių išvadų darymo ir prognozavimo. „Statistikos uždavinys – aiškiai pasakyti tiesą: (pakankamai) tiksliai ir suprantamai.“ — Stephen McCurdy 2.5 Kintamųjų tipai statistikoje Statistikoje „kintamaisiais“ vadinamos tiriamųjų/objektų savybės. Duomenų analizės metodo pasirinkimas labai smarkiai priklausys nuo kintamojo prigimties. Pagal prigimtį statistiniai kintamieji skirstomi į 2 dideles grupes: kokybinius (kategorinius plačiąja prasme) ir kiekybinius. Šie, savo ruožtu, skaidomi į 4 pagrindinius tipus (pav. 2.5). Pav. 2.5: Pagrindiniai statistinių kintamųjų tipai. Kokybiniai (kategoriniai) kintamieji: nominalieji (angl. nominal variable) – tai tokie kintamieji, kurių reikšmių (vadinamos kategorijomis) išdėstymo tvarka nesvarbi, t. y., reikšmės natūralios eilės tvarkos neturi. Matavimo vienetų irgi neturi. Pvz., ląstelės spalva – violetinė, raudona, melsva, bespalvė, – ląstelės forma – apvali, kvadratinė, pailga, netaisyklinga. Kartais kategorijos užkoduojamos skaičiais, pvz., 0 – sveikas, 1 – serga, bet dėl to kintamasis netampa kiekybiniu. 0 ir 1 tai tik kategorijų kodai, kurių eilės tvarka nesvarbi. ranginiai (angl. ranked/ordered variable) – tai tokie kintamieji, kurių reikšmės (vadinamos kategorijomis) turi natūralią didėjimo ar mažėjimo tvarką, tačiau atstumas tarp gretimų reikšmių nėra pastovus ar tiksliai išmatuojamas. Įprastai matavimo vienetų neturi. Pvz., ląstelės dydžio kategorija – maža, vidutinė, didelė; savijauta – labai prasta, prasta, neutrali, gera, puiki. Ranginiams priklauso ir balais matuojami duomenys. Kiekybiniai kintamieji: kiekybiniai diskretieji (angl. discrete variable) – tai tokie skaitiniai kintamieji, kurie yra suskaičiuojami. Jie turi baigtinį (suskaičiuojamą) galimų reikšmių skaičių ir atstumas tarp dviejų galimų gretimų reikšmių yra pastovus ir gali būti tiksliai išmatuotas. Paprasčiau sakant, kiekybiniai diskretieji kintamieji išreiškiami teigiamais ir neigiamais sveikaisiais skaičiais bei nuliu. Įprastai aprašo kieno nors skaičių, pvz., ląstelių skaičių, dantų skaičių, kėdžių skaičių, į paskaitą atėjusių studentų skaičių, sėkmingų bandymų skaičių, raudonų mėgintuvėlių skaičių; tolydieji (angl. continuous variable) – tai skaitiniai kintamieji, kurie įprastai yra išmatuojami ar užregistruojami (bet ne suskaičiuojami). Gali įgyti ir trupmeniniais skaičiais užrašomas reikšmes (tarkim, 2,2354), teoriškai gali būti išmatuoti daugybės skaitmenų po kablelio tikslumu. Pasirinktame reikšmių intervale tarp dviejų skaičių (tarkim, tarp 2,2 ir 2,4) gali įgyti be galo daug reikšmių, nes skaičių po kablelio gali būti be galo daug. Įprastai turi konkrečius matavimo vienetus, nors gali būti išreikšti ir santykiniais vienetais ar būti bedimensiai dydžiai. Pvz., ląstelės svoris kilogramais, ilgis centimetrais, trukmė sekundėmis (kai skaičiuojamos ir sekundžių dalys), regėjimo aštrumas dioptrijomis, santykis tarp ilgio (metrais) ir pločio (metrais), šviesos intensyvumas santykiniais vienetais. Įprastai tokius skaičius suapvaliname iki tam tikro tikslumo tik dėl to, kad negalime išmatuoti be galo tiksliai arba praktiniam naudojimui užtenka ir mažesnio baigtinio tikslumo. Visgi teoriškai matuojamas kintamasis išlieka tolydusis. Kokius veiksmus galima atlikti su skirtingų tipų kintamųjų reikšmėmis? Nominaliąsias reikšmes galima tik suskaičiuoti: pasakyti, kiek kokių reikšmių yra. Ranginiais – galima suskaičiuoti, išdėstyti eilės tvarka ir palyginti, kuri didesnė/mažesnė. Su kiekybinių kintamųjų reikšmėmis – skaičiais – galima atlikti iš principo visus matematinius veiksmus (suskaičiuoti, palyginti, sudėti, atimti, padauginti, padalinti, apskaičiuoti vidurkį, …). Kokie kintamieji atrodo kaip skaitiniai (kiekybiniai), bet iš tiesų yra kategoriniai? Kategorijos, užkoduotos skaičiais, vis tiek yra kategorijos (tad joms skaičiuoti vidurkį nėra prasmės). Balais matuojami kintamieji iš tiesų yra ranginiai. Visgi, jei jie gali įgyti pakankamai daug reikšmių ir jų vidurkis turi prasmę (turbūt žinote, kas yra sesijos pažymių vidurkis), dažnai interpretuojami kaip skaitiniai. Visgi reikia prisiminti, kad pagal prigimtį – tai iš eilės išdėliotos kategorijos (rangai). Užduotis 2.1 Kuriam iš keturių tipų (nominalieji, ranginiai, diskretieji, tolydieji) priklauso šie duomenys: Šokolado svoris (g); Šokolado skonis (neskanus, skanus, labai skanus); Šokolado pakuotės spalva; Šokolado lydymosi temperatūra (°C); Šokolado plytelių skaičius; Šokolado porėtumas (porėtas/neporėtas); Šokolado rūšis (juodasis, baltasis, pieniškas, mėtinis); Šokolade esančių riešutų skaičius. 2.6 Duomenų saugojimo formos Atliekant tyrimą svarbus dalykas yra nuspręsti, kokia forma rinksime, organizuosime ir saugosime duomenis. Mūsų pasirinkimas priklauso nuo tyrimo srities, sprendžiamo uždavinio ir duomenų sudėtingumo. Šio kurso metu daugiausiai dirbsime su dviem formomis (duomenų struktūromis) – duomenų eilutėmis (duomenų sekomis) ir duomenų lentelėmis (duomenų sekomis, stulpeliais išdėliotomis į lentelės pavidalą) – tad siūlau skirti pakankamai daug laiko, kad tinkamai perprastumėte šias dvi struktūras. 2.7 Duomenų eilutės Duomenų eilutės – tai duomenų reikšmių seka. Joje įrašomos vienõs užregistruotos tiriamųjų savybės (tarkim, apklaustųjų ūgio) reikšmės. Duomenų eilutės pavyzdys – išmatuoti kurso kolegų ūgiai (centimetrais): 180, 168, 171, 173, 185, 179, 164. Duomenų eilutę taip pat galima pavadinti statistiniu kintamuoju, nes reikšmės nėra fiksuotos, bet kinta. (PASTABA: vėliau susipažinsime su kompiuteriniu terminu „kintamasis“, tad atskirkite, kad tai panašūs, bet skirtingi dalykai). Analizei svarbu atpažinti tokias duomenų eilutes: statistinė eilutė – duomenys surašyti eilės tvarka, pagal tai, kada buvo surinkti ir užregistruoti; variacinė eilutė – duomenys išrikiuoti didėjimo (arba nemažėjimo, jei yra vienodų reikšmių) tvarka. 2.8 Duomenų lentelės Duomenų lentelės – yra statistiniam tyrimui svarbiausia duomenų organizavimo forma. Ji yra standartizuota ir pritaikyta darbui statistinėmis programomis. Tvarkingos duomenų lentelės sudarymo principas: viena eilutė skirta vienam tiriamajam, vienas stulpelis – vienai savybei (kintamajam), o langeliuose – kiekvieno tiriamojo savybių reikšmės (žiūrėti pav. 2.6). Pav. 2.6: Duomenų lentelės struktūra. Atkreipkite dėmesį, kad stulpelių pavadinimai nurodo tiriamųjų savybes. Be to, įprastai lentelė turi pavadinimą, kuris turėtų būti prasmingas ir apibendrinti lentelėje surinktus duomenis. Duomenų lentelė gali būti gaunama vienos ar kelių duomenų eilučių reikšmes surašius kaip stulpelius. Tik svarbu, kad pirma kiekvienos duomenų eilutės reikšmė būtų iš pirmo tiriamojo, antra – iš antro ir t.t. T. y., kad eilės tvarka atitiktų teisingai. Visgi, vykdant tyrimą, duomenis rekomenduoju rinkti iš karto duomenų lentelės pavidalu, papildomai pasidarant duomenų lentelės aprašymą. Aprašymas reikalingas tam, kad jūsų kolegos, vadovas arba jūs pats/pati po 6 mėnesių tiksliai žinotumėte, kokie duomenys šioje lentelėje. Aprašyme bent trumpai apibūdinkite tyrimą, jo tikslą, nurodykite duomenų rinkimo metodus ir prietaisus, pateikite kintamųjų aprašymą, kuriame nurodyti matavimo vienetai. Rekomendacija: surinktus duomenis iš karto surašykite į duomenų lentelės pavidalą + būtinai pasidarykite duomenų lentelės kintamųjų aprašymą. Užduotis 2.2 Kas yra duomenų lentelė? Kas jos stulpeliuose ir kas - eilutėse? Išvardinkite 4 pagrindinius statistiniams skaičiavimams svarbius duomenų tipus ir nurodykite bent po 2-3 jiems būdingus požymius. Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["rstudio.html", "3. Programa RStudio 3.1 RStudio 3.2 RStudio langų išdėstymas 3.3 Komandų langas 3.4 Redaktoriaus langas 3.5 Paketų valdymo langas 3.6 Pagalbos langas 3.7 RStudio projektai Klausimai ir komentarai", " 3. Programa RStudio Šis skyrius skirtas susipažinti su programa „RStudio“. Jame nagrinėsime organizacinius ir pagalbinius duomenų analizės bei darbo programa „R“ aspektus. Išsamesnei pažinčiai su programos „R“ kodu bus skirtos kitos temos. Tikslas – įgyti darbo programa „RStudio“ pradmenis. Jūsų užduotys skaitant šį skyrių: Sužinoti ir mokėti paaiškinti, kas yra „RStudio“ ir kuo skiriasi nuo „R“; Išmokti atsidaryti programą „RStudio“; Sužinoti ir mokėti apibūdinti pagrindinių „RStudio“ langų paskirtį; Išmokti kompiuteriui pateikti komandas naudojantis „R“ komandų langu; Išmokti kompiuteriui pateikti komandas naudojantis „R“ redaktoriaus langu; Sužinoti, kas yra „R“ paketas ir naudojantis „RStudio“ išmokti parsisiųsti ir užsikrauti paketą; Išmokti informaciją apie „R“ komandą susirasti pagalbos ir dokumentacijos („Help“) lange; Išmokti susikurti „RStudio“ projektą. 3.1 RStudio Programa „RStudio“ (pav 3.1) yra patogesniam darbui su „R“ skirta aplinka (integruota kūrimo aplinka, angl. IDE – integrated development environment). Jei imtume automobilį kaip atitikmenį, tai jo variklis būtų „R“, o mašinos salonas – vairas, pedalai, spidometras, šviesų jungiklis, masažinės sėdynės ir borto kompiuteris – „RStudio“ (pav. 3.2). Pav. 3.1: „RStudio“ logotipas. Iliustracijos šaltinis: . „R“ – variklis „RStudio“ – patogiam valdymui skirtas salonas Pav. 3.2: Analogija tarp „R“, „RStudio“ bei automobilio. Iliustracijos šaltinis: Papildoma. Galite peržiūrėti šiuos du video epizodus (anglų kalba), kuriuose pristatoma programa „RStudio“: „RStudio“ tinklalapyje ir „DataCamp“ tinklalapyje . Užduotis 3.1 Atsidarykite programą „RStudio“. Jei programos ikonos nėra darbalaukyje, pasinaudokite savo operacinės sistemos programų paieškos sistema. 3.2 RStudio langų išdėstymas Standartinis programos „RStudio“ langų išdėstymas ir kiti elementai, į kuriuos rekomenduojama atkreipti dėmesį, pavaizduoti pav. 3.3. Pirmą kartą atsidarę programą galite matyti tik tris langų grupes, o ne keturias, kaip vaizduojama iliustracijoje. Pav. 3.3: Keturios pagrindinės programos „RStudio“ langų grupės (1-4), langų išdėstymą valdantis meniu (5A, 5B), pagrindinė programos meniu juosta viršuje (6) bei dabartinio projekto pavadinimas (7). Paveiksle vaizduojamas langų išdėstymas šioje svetainėje bus vadinamas standartiniu. 3.3 Komandų langas Svarbiausias pirmosios langų grupės (pav. 3.3) langas yra komandų langas (pultas, „konsolė“, angl. console). Tai pagrindinis bendravimo su programa langas: čia rašome komandas ir gauname skaitinius arba žodinius atsakymus iš programos „R“. Jei komandų lange dega „&gt;“ ženkliukas (angliškai vadinamas prompt), vadinasi, programa pasirengusi priimti jūsų komandas. Norėdami, kad jos būtų įvykdytos, įrašome programos kodą ir paspaudžiame Enter. Jei komandos vykdymas trunka ilgai, užsidega „Stop“ ženkliukas . Kai jis užgęsta – skaičiavimas baigtas. Jei norime nutraukti skaičiavimą anksčiau laiko, paspaudžiame šį ženkliuką. Jei norime išvalyti komandų langą, spaudžiame ikoną, kurioje vaizduojama šluota arba Ctrl+L. Jei lange vietoje &gt; dega +, vadinasi, nebaigta vesti komanda. Šiuo atveju yra 2 išeitys: arba įvesti komandą iki galo, arba spausti „Escape“ (Esc) klavišą, kol vėl atsiras &gt; (pav. 3.4). Pav. 3.4: Vienas iš galimų sprendimų, jei komandų lange vietoje &gt; dega +, yra kelis kartus paspausti Esc. Iliustracijos šaltinis: . Užduotis 3.2 Perskaitykite, kas parašyta komandų lange, kai vos tik paleidžiate programą. Kokia tai informacija? Išvalykite komandų langą. Naudodamiesi komandų langu įvykdykite komandą „trys minus dvidešimt“: 3 - 20. Rezultatas turėtų būti „[1] -17“. 3.4 Redaktoriaus langas Antrai langų grupei (pav. 3.3) priklauso redaktoriaus langas (angl. source code editor). Šiame lange atidaromi įvairūs tekstiniai dokumentai, kurie naudojami kaip užrašų knygutė programos kodui bei tekstui. Pvz., „R“ programos kodui skirtas „R Script“, o ataskaitoms ar kitokiems dokumentams rengti – „R Markdown“ formatai. Dokumentus galime išsaugoti paspaudę Ctrl+S (rekomenduoju šią kombinaciją spausti reguliariai). Jei programą atsidarote pirmą kartą, redaktoriaus lango galite ir nematyti. Tokiu atveju paspauskite Ctrl+Shift+N ir atsidarys „R“ programos kodui rašyti (ir išsaugoti) skirtas langas („R Script“). Taip pat galite naudoti pav. 3.5 pateiktas instrukcijas. Pav. 3.5: Žingsniai, kaip „RStudio“ redaktoriaus lange atsidaryti programos kodui skirtą „R Script“ dokumentą. Numeriais pažymėti punktai rodo vietas, kur reikia spausti pele. Norėdami įvykdyti redaktoriaus lange parašytas komandas, programos kodą pažymime pele ir spaudžiame mygtuką („Run“) arba klavišų kombinaciją Ctrl+Enter. Užduotis 3.3 Patikrinkite, ar matote visus keturis „RStudio“ langus, vaizduojamus pav. 3.3. Jei kurio nors trūksta, atsidarykite. Įsitikinkite, kad programoje „RStudio“ nustatyta UTF-8 koduotė. Jei nepamenate kaip, žiūrėkite skyriuje 1.5.2. Redaktoriaus lange padėkite grotelių simbolį # ir raštu glaustai apibūdinkite, kas yra „R“ ir kas yra „RStudio“? Kuo skiriasi? Kuri iš programų – svarbesnė (kuri be kurios kita neveiktų)? Redaktoriaus lange naujoje eilutėje (be grotelių) įrašykite 2 + 3, šią išraišką pažymėkite pele ir paspauskite Ctrl+Enter. Kuriame lange atsirado atsakymas „[1] 5“? 3.5 Paketų valdymo langas Apie šį langą plačiau kalbama skyriuje „5 R paketai“ bei poskyryje „5.2 RStudio langas Packages“. 3.6 Pagalbos langas Vienas iš centrinių „R“ kodo elementų yra funkcija (žr. skyriuje 4.2.1). Norint rasti kurios nors funkcijos aprašymą ar naudojimo pavyzdžių galime pasinaudoti pagalbos langu „Help“. Šį langą galime atsidaryti tokiais būdais: naudodamiesi pele (pav. 3.6), redaktoriaus lange pažymėję funkcijos pavadinimą ir paspaudę F1, naudodami specializuotas funkcijas, tokias kaip help(), ?, ??. Kaip naudotis langu, paaiškinta pav. 3.6. Pav. 3.6: Naudojimasis pagalbos ir dokumentacijos langu. Ketvirtoje „RStudio“ langų grupėje (pav. 3.3) atsidarome kortelę „Help“ (1), įvedame dominančios funkcijos pavadinimą (2) ir iš iššokusio sąrašo pasirenkame patikslintą temą (3) arba tiesiog paspaudžiame Enter. Raidėmis pažymėtos dalys paaiškintos tekste. Dažnai naudingiausia dalis yra pavyzdžiai (G). Funkcijos dokumentacijos dalys, kurias įprastai turi aprašymas pagalbos lange (atitinka raidinius pav. 3.6 žymėjimus): Pačiame viršuje – funkcijos ir paketo, iš kurio ta funkcija paimta, pavadinimai tokiu formatu funkcija {paketas}; Aprašo pavadinimas (kuriame įprastai atsispindi funkcijos esmė); Skiltis Description – trumpas aprašas, ką funkcija atlieka; Skiltis Usage – „R“ kalbos sintaksė, kaip naudoti tą funkciją; Skiltis Arguments – funkcijos argumentų aprašymas; Skiltis Value – rezultato, kurį sukuria funkcija, aprašymas; Skiltis Examples – tai turbūt pati naudingiausia skiltis, kurioje yra programos kodo pavyzdžiai, rodantys kaip naudoti šią funkciją; Paketo pavadinimas ir versija. Priklausomai nuo aprašo, jo dalių skaičius gali būti kitoks. Paprastoji paieška programiškai. Komandų lange parašome komandą help(), o jos skliaustuose – dominančios funkcijos pavadinimą. „R“ ieško funkcijos aprašymų šiuo metu užkrautuose paketuose, todėl šis paieškos būdas labai spartus. Sakykime, norime apskaičiuoti medianą, bet nežinome, kaip naudojama funkcija median(). Rašome komandą: help(median) Kaip alternatyva gali būti naudojamas klaustuko operatorius: ?median Išplėstinė paieška programiškai. Jei paprastoji paieška aprašymo neranda, galite mėginti dviejų klaustukų operatorių, kurio pagalba aprašo ieškoma visoje „R“ dokumentacijoje: ??median Šio tipo paieška žymiai lėtesnė, tad procesas gali užtrukti. Plačiau apie „R“ pagalbos sistemą ir kaip ja naudotis rašoma straipsnyje „Getting Help with R“ bei forumo temoje „How to get help in R?“ . Užduotis 3.4 Nustatykite, ką atlieka ir kaip naudojamos (peržiūrėkite pavyzdžius) funkcijos sd(), max(), matrix() bei kokiame pakete jos yra. 3.7 RStudio projektai Geras bruožas – duomenų analizę atlikti tvarkingai. „RStudio“ turi specializuotų šiam tikslui skirtų įrankių. Vienas iš jų – „RStudio“ projektai, kurių ikona vaizduojama pav. 3.7. „RStudio“ projektas – tai aplankas jūsų kompiuteryje, skirtas kokiam nors duomenų analizės projektui. Šį aplanką programa pasižymi įkeldama bylą plėtiniu „.Rproj“ (pvz., „projektas.Rproj“), tad atidarius šią bylą atidaroma ir programa „RStudio“. Tame aplanke saugoma dalis programos nustatymų, skirtų projektui, taip pat gali būti saugomi duomenys, programos kodai ar kiti su projektu susiję dokumentai. Projektai labai pravartūs, jei tuo pačiu laikotarpiu dirbame su keliomis užduotimis, kurioms atlikti naudojame „R“, pvz., biostatistikos pratybomis, kursiniu darbu ir praktikos laboratorijoje užduotimis. Įprastai projekto aplankas laikomas aktyviuoju (darbiniu) aplanku (angl. working directory) – programa „R“ duomenų ir kitų bylų ieško būtent šiame aplanke. Pav. 3.7: „RStudio“ projekto ikona (autorių teisės gali būti saugomos). Visos programos vietos, paženklintos šiuo simboliu, yra susijusios su projektais. Projekto aplanke esanti „.Rproj“ byla taip pat paženklinta šiuo simboliu. „RStudio“ projektų valdymo meniu bei naujo projekto kūrimas vaizduojami pav. 3.8 ir 3.9. Pav. 3.8: Darbo su „RStudio“ projektais pagrindai. Pav. 3.9: Naujo „RStudio“ projekto kūrimo žingsniai. Punktus 1-4, 7 ir 8 pasirenkame pele, nurodome naujo projekto (5) ir aplanko, kuriame jis bus sukurtas (6) pavadinimus. 7 – jei varnelė uždėta, dabartinis projektas liks atidarytas. Bangelė aplanko pavadinime nurodom jog tai „Dokumentai“/„My documents“ (sistemoje „Windows“) arba pradžios (Home) aplankas (sistemose „Linux“, „Mac“). Būsimų pratybų metu jums bus duodami „RStudio“ projektai, suarchyvuoti (.zip) formatu. Prieš juos atsidarant, archyvų turinį būtina išskleisti („iš’zip’inti“) į atskirą aplanką, projektą atsidaryti ir atkreipti dėmesį į tai, koks atsidariusio projekto pavadinimas (pav. 3.10). Jei pavadinime yra archyvo plėtinys, pvz., „.zip“, vadinasi projektas atsidarytas ne taip, kaip reikia, ir kils problemų dirbant. Sprendimas: projektą uždaryti, „zip“ archyvo turinį išarchyvuoti („iš’zip’inti“) į atskirą aplanką ir projektą atidaryti iš šio naujojo aplanko. Pav. 3.10: „RStudio“ projekto pavadinimas. Užkrovus „RStudio“ projektą, matomas aplanko, kuriame yra projektas, pavadinimas (tarkime „Pratybos-2“). Jei projektas neužkrautas, matome užrašą „Project: (none)“. Jei projektą užkrauname iš bylos, kuri yra suarchyvuota (t. y., užkrauname netinkamai), projekto pavadinime yra archyvo bylos plėtinio (.zip, .rar ar pan.) pavadinimas. Tinkamai užkrauto projekto pavadinimas – tai projekto aplanko (o ne „.Rproj“ bylos) pavadinimas. Kartais (pvz., diegiantis paketus) projektą reikia uždaryti. Taip pat programa „RStudio“ suteikia galimybę greituoju būdu atsidaryti iki 10 naujausių projektų. Kaip tai padaryti vaizduojama pav. 3.11. Pav. 3.11: Projekto uždarymas ir neseniai uždaryto projekto atvėrimas. Pasirenkame ikoną, ties kuria – dabartinio projekto pavadinimas (1). Norėdami užverti projektą, renkamės „Close Project“ (2). Iki 10 vėliausiai naudotų projektų matome sąraše žemiau (pavyzdyje tik vienas projektas, pavadintas „Pratybos-2“). Vėliau norėdami atverti vieną iš šių 10 projektų, galime spustelti arba patį projekto pavadinimą (3) arba ikoną ties juo (4): (3) projektą atvers dabartiniame lange, o (4) – naujame (dabartinis irgi liks atidarytas). Norėdami peržiūrėti dabartinio projekto aplanko turinį arba šį aplanką atsidaryti iš programos „RStudio“, naudokitės pav. 3.12 pateiktomis instrukcijomis. Pav. 3.12: Aplanko peržiūra ir atidarymas. Programos „RStudio“ 4 langų grupėje (pav. 3.3) pasirinkite „Files“ kortelę (1). Joje matysite šiuo metu peržiūrimo aplanko pavadinimą (2). Namuko simbolis ir užrašas „Home“ (analogiškai kaip ir bangelė) sistemoje „Windows“ žymi jūsų dokumentų aplanką. Paspaudę kortelėje esančią projekto ikoną (3), pamatysite bylas ir aplankus, esančius jūsų projekto aplanke. Jei dirbate ne projekte, ikonos nebus. Toliau dirbant langas privalo būti pakankamai didelis, kad matytųsi visi mygtukai. Jei nesimato, langą reikia praplatinti: užveskite pelės žymeklį ties riba tarp dviejų langų, kol žymeklio ikona pasikeis (4) ir paspaudę pele ribą patempkite iki tol, kol langas taps reikiamo dydžio. Norėdami peržiūrimą aplanką atidaryti, spauskite mygtuką „More“ (5). Atsidariusiame meniu pasirinkite komandą „Show Folder in New Window“ (6). Aplankas atsidarys įprastu būdu, t. y., pagrindine jūsų kompiuterio sistemos aplankų peržiūrėjimo programa. Papildoma. Plačiau apie „RStudio“ projektus galite skaityti „RStudio“ pagalbos tinklalapyje . Užduotis 3.5 Susikurkite naują „RStudio“ projektą pavadinimu „Pratybos-1“ . Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["r-pradmenys.html", "4. Programos R pradmenys 4.1 Pirmieji R kodo elementai 4.2 R funkcijos 4.3 R objektai 4.4 Svarbiausi R duomenų tipai 4.5 R duomenų struktūros 4.6 Klausimai savikontrolei Klausimai ir komentarai", " 4. Programos R pradmenys „R“ yra programa, specializuota duomenų analizei. Šiame skyriuje susipažinsime su „R“ kaip su kompiuterine duomenų analizės kalba. Tikslas – įgyti darbo programa „R“ pradmenis: susipažinti su pagrindiniais „R“ kodo elementais, svarbiausiais „R“ duomenų tipais bei „R“ duomenų struktūromis. Jūsų užduotys skaitant šį skyrių: Išmokti suprasti ir naudoti „R“ sintaksės elementus, tokius kaip komentarai ir funkcijos (komandos). Sužinoti, kas yra funkcijos argumentas; Išmokti sukurti „R“ objektą (atlikti priskyrimo operaciją) ir sužinoti, kokie pavadinimai objektams yra leistini; Išmokti apibūdinti svarbiausius šiam kursui kompiuterinius „R“ duomenų tipus (skaičius, faktorius, tekstinius ir loginius kintamuosius) ir sužinoti, kokius statistinius duomenų tipus (kategorinius nominaliuosius, kategorinius ranginius, kiekybinius diskrečiuosius, kiekybinius tolydžiuosius ar nei vienas) jie atitinka. Išmokti programoje „R“ kurti duomenų sekas („R“ vektorius) ir atlikti paprastus veiksmus su šiomis sekomis („DataCamp“ užduotis). Pagrindinė ir svarbiausia praktinė jūsų šios dienos užduotis pateikta sistemoje „DataCamp“. Jos aprašymas: Užduotis 4.1 Norėdami praktiškai susipažinti su šiame skyriuje išdėstyta medžiaga, atlikite pamokos „Introduction to R“ 1, 2 ir 4 skyrius (įvadas, vektoriai ir faktoriai) sistemoje „DataCamp“ (1-2 val.). Prie sistemos prisijunkite naudodami savo VU studento el.pašto adresą. Kitaip nebus galimybės patikrinti, ar užduotį tikrai atlikote. 4.1 Pirmieji R kodo elementai Turbūt pamenate lietuvių kalbos pamokas apie „sintaksę ir skyrybą“. Jų metu mokėtės rašyti sakinius, taisyklingai sujungti įvairias jų dalis, tokias kaip aplinkybės, bei taisyklingai jas atskirti tinkamais skyrybos ženklais. Kompiuterijoje taip pat yra terminas „sintaksė“, kuriuo nusakoma kompiuterinės kalbos rašymo taisyklių visuma. Sintaksė (kompiuterijoje) yra kompiuterinės kalbos rašymo taisyklių visuma. Jūsų uždavinys analizuojant šį poskyrį – išmokti atpažinti kelis pagrindinius „R“ programos kodo sintaksės elementus bei susipažinti su šioje mokomojoje medžiagoje (svetainėje) naudojamu jų spalviniu žymėjimu. 4.1.1 R kodo komentarai (#) Vienas iš „R“ kalbos elementų yra komentaras. Grotelių ženklas (#) šalia „R“ komandų reiškia, kad tai komentaro pradžia. To, kas yra parašyta po grotelių, programa „R“ neskaito. Šitokiu būdu galime rašyti pastabas patys sau: # Tai komentaras, kurio R neskaito Komentaro ženklas galioja iki eilutės pabaigos, o rašant iš naujos eilutės – nebegalioja, tad norint tęsti komentarą kitoje eilutėje reikia groteles rašyti iš naujo: # Tai komentaras, # kuris tęsiasi per # kelias eilutes Tam, kad būtų paprasčiau susigaudyti, modernios programos įprastai skirtingomis spalvomis paryškina įvairius „R“ kodo elementus. Konkrečios spalvos ir paryškinimo būdas priklauso nuo naudojamos programos ir pasirinktų nustatymų. Šioje elektroninėje knygoje komentarai bus išryškinami tamsiai mėlyna spalva (kaip matote pavyzdyje virš šios pastraipos). Dirbdami programa „RStudio“, komentarus galite uždėti ir nuimti naudodami sparčiųjų klavišų kombinaciją Ctrl+Shift+C. Užduotis 4.2 Atsidarykite „RStudio“ redaktoriaus langą, jame – „R Script“ dokumentą. Jei dokumentas jau buvo atidarytas, naujo galite nekurti. Pirmoje eilutėje užrašykite „Author:“ ir savo vardą. Antroje – „Date:“ ir šios dienos datą. Abi eilutes pažymėkite pele. Naudodami greitųjų klavišų kombinaciją, eilutę užkomentuokite. Naudodami tą pačią kombinaciją atkomentuokite ir vėl užkomentuokite (t. y., įsitikinkite, kad ta pati kombinacija atlieka du veiksmus ir veikia tinkamai). 4.1.2 Rezultatų ženklinimas (##) Šioje svetainėje prieš rezultatus, kuriuos apskaičiuoja programa „R“, bus padedami du grotelių (t.y., komentaro) simboliai iš eilės (##) ir rezultatų tekstas bus nuspalvinamas pilkai: ## tai rezultatas, kurį pateikė R Pavyzdys: sudėjus 2 ir 3 (šią komandą parašome mes) atsakymas yra 5 (atsakymą apskaičiuoja ir parašo programa „R“): 2 + 3 ## [1] 5 Jei rezultatas bus apskaičiuojamas dirbant programa „R“, tai šių dviejų grotelių nepamatysite, nes dirbant programa ir taip aišku, kur jūsų parašyta komanda, o kur kompiuterio atsakymas. Užduotis 4.3 Programos „RStudio“ komandų lange (konsolėje) parašykite matematinį veiksmą 3 + 2. Kokį rezultatą gavote? Ką jis reiškia? Ar matote grotelių simbolį (##)? 4.1.3 Elementų eilės numerių žymėjimas: [ ] Praeitame pavyzdyje pastebėjote, kad eilutės pradžioje laužtiniuose skliaustuose atsirado papildomas skaičius [1]. Jis nurodo tos eilutės pirmojo elemento eilės numerį (pavyzdyje jo reikšmė buvo 5, o eilės numeris – 1). Aišku, šiuo atveju užrašas [1] duoda mažai naudos. Tačiau yra labai patogus, kai atsakymo elementų yra daug ir jie netelpa į vieną eilutę. Tokiu atveju laužtiniuose skliaustuose nurodomas kiekvienos eilutės pirmojo elemento eilės numeris, pvz.: ## [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ## [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ## [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 ## [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 ## [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 ## [86] 95 96 97 98 99 100 Pavyzdyje matome, kad elemento, kurio eilės numeris yra [69] reikšmė yra 78. Programoje „R“ elementų numeravimas (indeksavimas) prasideda nuo 1. T. y., indeksas „1“ reiškia, kad elemento eilės numeris yra pirmas. Kai kuriuose kituose programose indeksai prasideda nuo 0, o tai nėra taip patogu. Užduotis 4.4 „RStudio“ konsolėje parašykite komandą 595:200, kuri sukurs mažėjančių skaičių seką nuo 595 iki 200. Kokios elementų, kurių eilės numeriai 20 ir 380 reikšmės? 4.1.4 Kitų elementų spalvinis žymėjimas Skaičiai, simbolių eilutės, loginiai kintamieji bus išryškinami jiems būdingomis spalvomis: # Šioje eilutėje komentaras objekto_pavadinimas 335 # Skaičius TRUE # Loginė reikšmė &quot;simbolių eilutė (tekstas) rašoma kabutėse&quot; Užduotis 4.5 Aukščiau esantį programos kodo pavyzdį nukopijuokite į „RStudio“ redaktoriaus langą („R script“ dokumentą). Kokiomis spalvomis nusidažė skirtingi „R“ sintaksės elementai? 4.1.5 Programos kodas: blokais ir tekste Didesni kodo pavyzdžiai bus pateikiami blokais su spalvomis išryškintais elementais, kaip matėte ankstesniuose pavyzdžiuose: # Sudedame 5 bei 4 ir ištraukiame šaknį. # Atsakymas bus 3: sqrt(5 + 4) ## [1] 3 Kodo pavyzdžiai gali būti pateikiami ir toje pačioje eilutėje su tekstu, pvz., sqrt(5 + 4). (Komanda sqrt() reiškia kvadratinė šaknis, angl. square root). Žinokite, kad tai programos kodas. 4.2 R funkcijos Viskas, kas vyksta programoje „R“ – sudėtis, lango atidarymas, paveikslo nubraižymas, duomenų išsaugojimas, spalvos pakeitimas – yra kokios nors komandos vykdymo rezultatas. Komandas galima suskirstyti į įprastines funkcijas ir operatorius. 4.2.1 Įprastinės funkcijos ir jų argumentai Funkcija – tai veiksmas ar komanda, kurią nurodome atlikti kompiuteriui. Jos rašomas kaip vienas žodis be tarpelių (susidedantis iš raidžių, skaičių, taškų ir/arba apatinių brūkšnių), kurio gale yra paprastieji apvalūs skliausteliai (). Atkreipkite dėmesį į tai, kad tarp komandos pavadinimo ir skliausto tarpų nepaliekame. Šioje svetainėje funkcijos bus paryškintos žydrai, pavyzdžiui: r_funkcija() Pastaba: jūsų kompiuteryje užrašas r_funkcija() neveiks, nes tai tik pavyzdys. Komandos skliausteliuose rašome taip vadinamus funkcijos argumentus (terminai „funkcijos“, „argumentai“ – visai tokie, kaip per matematikos paskaitą): r_funkcija(argumento_reikšmė) Argumentai gali turėti pavadinimus ir šie bus pabraukti (kol kas nesijaudinkite, jei neaišku, kas tie argumentai ir t.t. Dabar svarbiausia, kad suprastumėte tik jų spalvinį žymėjimą): r_funkcija(argumento_pavadinimas = argumento_reikšmė) Jei argumentas turi pavadinimą, jo reikšmė nurodoma naudojant = (bet ne operatorių &lt;-, apie kurį rašoma skyriuje „Objektų kūrimas“). Pavadinimą turinčio funkcijos argumento reikšmė nurodoma naudojant operatorių = (bet ne &lt;-). Pavyzdys, funkcija log(), kuri įprastai apskaičiuoja natūrinį logaritmą. Apskaičiuokime \\(ln(100)\\): log(100) ## [1] 4.60517 Funkcija log() turi argumentą x, tad galime užrašyti kitaip ir gauti tą patį rezultatą: log(x = 100) ## [1] 4.60517 Užduotis 4.6 Programos „RStudio“ konsolėje parašykite žodį „log(“ (programa automatiškai padės uždarantį skliaustelį). Tada paspauskite klavišą Tab. Programa parašys, kokie galimi funkcijos log() argumentų pavadinimai (juos galėsite pasirinkti pele). Įvardinkite šiuos argumentus. Analogiškai išsiaiškinkite, kokie galimi funkcijos data.frame() argumentų pavadinimai. Kol kas jų reikšmės suprasti nereikia. Atlikdami pratimą išsiaiškinome, kad iš tiesų funkcija log() turi kelis argumentus, ir kai argumentų daug, jų parašymas funkcijos viduje suteikia aiškumo: log(100, base = 10) ## [1] 2 Turbūt supratote, kad buvo pakeistas logaritmo pagrindas („base“) į 10 ir apskaičiuota išraiška \\(log_{10}(100)\\). Tuo tarpu užrašas be argumentų pavadinimų nėra toks aiškus: log(100, 10) ## [1] 2 Jei norite daugiau sužinoti apie funkciją log(), komandų lange įrašykite ?log (prieš funkcijos pavadinimą padėkite klaustuką) ir pagalbos bei dokumentacijos lange „Help“ (pav. 3.3 langas Nr. 4) pamatysite aprašymą. Jei naudojame kelis funkcijos argumentus, juos atskiriame kableliais (,), o po kablelio padedame tarpelį: r_funkcija(reikšmė_1, reikšmė_1, reikšmė_3) Arba: r_funkcija(arg_1 = reikšmė_1, arg_2 = reikšmė_1, arg_3 = reikšmė_3) Pavyzdys – funkcija c(), kuri skirta kurti duomenų sekas (vektorius): c(1, 16, 99, -3, 58) ## [1] 1 16 99 -3 58 Funkcija c() bus viena iš dažniausiai naudojamų, todėl ją įsiminkite labai gerai. Užduotis 4.7 Apskaičiuokite dvejetainį logaritmą skaičiui 65. Koks atsakymas? Sukurkite seką („R“ vektorių) iš skaičių: 1; 10; 100; 1000; 10000. 4.2.2 Operatoriai „R“ operatoriai – tai pavieniai simboliai ar kelių simbolių sekos, atliekančios tam tikrus veiksmus (t. y., operacijas). Iš principo, operatorius – tai „R“ funkcija, tik užrašoma ne žodžiais, o simboliais. Pavyzdžiui, sudėties operatorius +: -25 + 43 ## [1] 18 Operatoriai būna: Aritmetiniai: atlieka matematines operacijas, pvz., +, -; Palyginimo: lygina reikšmes, pvz., &lt;; Loginiai: (&amp; – IR, | – ARBA, ! – NE) – įprastai naudojami tikrinant sąlygas, pvz., ar geras IR turtingas; Priskyrimo: pvz., &lt;-, -&gt; ar = – skirti kurti „R“ objektus; Skaičių sekų kūrimo, pvz., :; Kitokie, pvz., funkcijų jungimo į grandinę operatorius %&gt;%. Užduotis 4.8 „RStudio“ pagalbos lango („Help“) paieškos laukelyje parašykite nurodytus operatorius ir suraskite reikiamą informaciją apie juos: &lt;- – kaip vadinasi tema? | – kaip vadinasi tema? + – kaip vadinasi tema ir ar dokumentacijoje pateikta pavyzdžių? : – kam skirtas šis operatorius ir kaip juo naudotis? 4.3 R objektai Viskas, kas „R“ atmintyje yra išsaugota tam tikru pavadinimu, vadinama objektais. Išsaugoti galime skaičius, duomenų sekas, duomenų lenteles ir netgi funkcijas (pav., 4.1). „R“ objektai dar vadinami kintamaisiais kompiuterijos prasme (angl. variable), nes pavadinimu žymimą reikšmę galime pakeisti. Pav. 4.1: Programos „R“ objektų tipų pavyzdžiai. Pastabos. Atkreipkite dėmesį į tai, kad vienodai skambantys terminai (pvz., „objektas“, „kintamasis“) statistikos ir kompiuterijos prasme gali turėti susijusias, bet skirtingas reikšmes. Tikiuosi, kad greit susigaudysite ir tai nekels problemų. 4.3.1 Objektų kūrimas Veiksmas, kurio metu kintamajam priskiriama reikšmė (t. y., kurio metu sukuriamas objektas), vadinamas priskyrimu (angl., assignmemt). „R“ objektai sukuriami naudojant taip vadinamą priskyrimo operatorių: arba &lt;- (įprastinis „R“ naudotojo pasirinkimas), arba =. Rodyklė &lt;- susideda iš simbolių „mažiau“ ir „minus“, parašytų be tarpo. Programoje „RStudio“ įterpiama naudojant kombinaciją Alt+-. Kartais paspaudus šią kombinaciją įterpiamas operatorius =. Tokiu atveju programa mano, kad esamoje situacijoje šis operatorius yra tinkamesnis. Būtinai atkreipkite dėmesį į tai, kad iš kiekvienos operatoriaus pusės yra palikta po tarpelį. Tai suteikia aiškumo. Sukurkime objektą objekto_pavadinimas kurio reikšmė būtų skaičius keturi: # Skaitinės reikšmės priskyrimas objekto_pavadinimas = 4 # Skaitinės reikšmės priskyrimas objekto_pavadinimas &lt;- 4 Sakoma, kad objektui objekto_pavadinimas priskiriama reikšmė 4. Jei parašome sukurto kintamojo pavadinimą, įprastai atspausdinama jo reikšmė (tai vadinama spausdinimu pagal nutylėjimą): objekto_pavadinimas ## [1] 4 Taip pat tą patį rezultatą galime pasiekti naudodami komandą print() (šiuo atveju tai išreikštasis spausdinimas, nes parašome komandą): print(objekto_pavadinimas) ## [1] 4 Vėliau sukurtą objektą galima panaudoti atliekant tolimesnius veiksmus. Panagrinėkime pavyzdį. Sukurkime objektą ir priskirkime jam reikšmę: nupirkom_kiausiniu &lt;- 10 Atspausdinkime sukurtą objektą (reikšmės spausdinimas pagal nutylėjimą): nupirkom_kiausiniu ## [1] 10 Sukurkime dar vieną objektą: suvalgem_kiausiniu &lt;- 6 Atspausdinkime ir jį: suvalgem_kiausiniu ## [1] 6 Su šiais dviem objektais galime atlikti matematinius veiksmus tarsi tai būtų skaičiai, kuriuos priskyrėme: liko_kiausiniu &lt;- nupirkom_kiausiniu - suvalgem_kiausiniu Atspausdinkime rezultatą: liko_kiausiniu ## [1] 4 Reikšmes taip pat galima priskirti naudojant ir = simbolį: po_papildymo = liko_kiausiniu + 3 po_papildymo ## [1] 7 Užduotis 4.9 Naudodami operatorių &lt;- sukurkite objektus pavadinimais „a“, „b“ ir „c“, kurių reikšmės būtų atitinkamai 96, -6, 0.01. Visus šiuos objektus sudėkite. Ar rezultatas toks, kokio tikėjotės? 4.3.2 Darbinė erdvė Galime apsibrėžti, kad darbinė erdvė, arba darbinė aplinka (angl., workspace, arba working environment), – tai visi darbinėje „R“ atmintyje esantys (sukurti ar įkelti) objektai. Jų pavadinimai yra išvardinti lange „Environment“ (pav. 3.3 langas Nr. 3). „Išvalyti darbinę erdvę“ – reiškia ištrinti visus „R“ atmintyje esančius objektus. „Išsaugoti/užkrauti darbinę erdvę“ – šiuos objektus išsaugoti į kietąjį diską ar vėl įkelti į „R“. Užduotis 4.10 Į konsolę nukopijuokite programos kodą x &lt;- 2 ir paspauskite klavišą Enter. Lange „Environment“ atsiras objektas, pavadinimu „x“. Ar matote jį? Jei norime, kad „R“’as konsolėje išvardintų objektų, šiuo metu esančių jo atmintyje, pavadinimus, galime naudoti komandą objects(): objects() # R&#39;as išvardija, kas jo darbinėje atmintyje Dažnai naudojamas komandos objects() sinonimas yra komanda ls(), kuri daro visiškai tą patį: ls() # R&#39;as išvardija, kas jo atmintyje Norėdami pašalinti objektą, naudojame funkciją remove() arba rm(), kurios skliaustuose įrašome objekto pavadinimą, pvz.: remove(suvalgem_kiausiniu) Kaip analizuojant „R“ kodą pagal skliaustelius atpažinti, kur yra įprastinė funkcija, o kur kitoks objektas? Pradiniam susigaudymui galima sakyti, kad po funkcijos rašomi paprastieji apvalieji skliausteliai ( ), pvz., sum(). Jei parašyti laužtiniai skliausteliai [ ] arba [[ ]], vadinasi, tai kitoks objektas (ne funkcija). 4.3.3 Objektų pavadinimai Leistini simboliai pavadinimuose Programoje „R“ objektų pavadinimuose pirmasis simbolis privalo būti raidė. Pirmas gali būti ir taškas, bet tada objektas tampa paslėptas, o tai jau pažengusiųjų lygio tema, tad tokie pavadinimai nerekomenduojami. Antras ir tolimesni simboliai gali būti didžiosios ir mažosios raidės, skaičiai, taškas (.) ir apatinis brūkšnys (_). Ar didžiosios ir mažosios raidės – svarbu? Programa „R“ skirtingai reaguoja į didžiąsias ir mažąsias raides. Tad pavadinimai T ir t arba c ir C, arba mano_mama, mano_Mama ir mano_MAMA yra suprantami kaip skirtingi žodžiai. Skirtingas programų reagavimas į didžiąsias ir mažąsias raides angliškai vadinamas terminu „case sensitive“. Pavadinimų rašymo stilius (rekomendacijos) Ar pamenat filmuką „Kung-fu Panda“? Jame kung-fu meistrai naudojo skirtingus kovos stilius: tigro, gervės, gyvatės… Panašiai ir rašant kintamųjų pavadinimus, kuriuose norima pavartoti kelis žodžius, naudojami įvairūs stiliai: DvikuprioKupranugarioStilius – žodžiai rašomi iš didžiosios raidės, be tarpų (angl. big/upper camel case); vienkuprioKupranugarioStilius – visi žodžiai, išskyrus pirmąjį, rašomi iš didžiosios raidės, be tarpų (angl. small/lower camel case); taškuotojo.leopardo.stilius – žodžiai atskiriami taškais; gyvatės_stilius – visos raidės mažosios, o žodžiai atskiriami apatiniais brūkšniais (angl. snake case). Šio kurso metu daug dėmesio skirsime darbui „Tidyverse“ sistema. Todėl objektų pavadinimus rašysime pagal „Tidyverse“ stiliaus gido rekomendacijas – naudosime gyvatės_stilių, kur: pavadinime naudojamos tik mažosios raidės, skaičiai ir apatinis brūkšnys _; pirmasis simbolis pavadinime – visada raidė (mažoji). Taip pat stenkitės kurti prasmingus pavadinimus, pvz., ugis, svoris, amzius (vietoje x, y ar z), kurie padėtų lengviau suprasti jūsų kodo esmę ir kitam žmogui (tarkim, jums po 6 mėnesių) būtų paprasčiau jį suprasti. Pastebėsite, kad kitų autorių kode objektų pavadinimuose taškas (.) yra vartojamas gana dažnai. Deja, tam tikrame kontekste jis įgyja specialiąją reikšmę. Todėl taško „R“ objektų pavadinimuose venkite. Kaip kurti „R“ objektų pavadinimus, kad vėliau nekiltų problemų? Naudotis „Tidyverse“ stiliaus rekomendacijomis: pirmasis simbolis pavadinime privalo būti mažoji raidė; kiti simboliai – tik mažosios raidės, skaičiai ir apatiniai brūkšniai _; pavadinimai turėtų būti prasmingi, bet trumpi. Taško „R“ objektų pavadinimuose venkite. Lietuviškų (tiksliau, neangliškų) raidžių „R“ objektų pavadinimuose taip pat siūlau vengti. Gali kilti problemų, jei nustatyta netinkama lokalė. Papildoma. Visą „Tidyverse“ stiliaus gidą galite rasti adresu style.tidyverse.org . Užduotis 4.11 Kurie iš šių „R“ objektų pavadinimų (1) yra leistini programoje „R“ apskritai ir kurie (2) rekomenduojamų vartoti simbolių prasme yra tinkami pagal „Tidyverse“ stiliaus gidą? pirmoobjektopavadinimas &lt;- 1 PIRMOOBJEKTOPAVADINIMAS &lt;- 1 1objektopavadinimas &lt;- 1 pirmo.objekto.pavadinimas &lt;- 1 Objekto.pavadinimas.1 &lt;- 1 obj.....nr..........1 &lt;- 1 pirmo!objekto!pavadinimas &lt;- 1 o001452475584 &lt;- 1 pirmo_objekto_pavadinimas &lt;- 1 pirmo_objekto$pavadinimas &lt;- 1 pirmoObjektoPavadinimas &lt;- 1 0pavadinimas0 &lt;- 1 PIRMO_OBJEKTO_PAVADINIMAS &lt;- 1 _objektas &lt;- 1 obj_1 &lt;- 1 Netaisyklingi pavadinimai Programoje „R“ yra mechanizmas, skirtas naudoti ir netaisyklingus pavadinimus: pavadinimus reikia įrašyti tarp atgal pasvirusių simbolių, vadinamų – graviais ` (angl. backtick). Šis simbolis įprastai yra šalia Esc ir ~. `1 netaisyklingas pavadinimas +` &lt;- 22 `1 netaisyklingas pavadinimas +` ## [1] 22 Kai kuriais atvejais, tarkim, dirbant papildiniu „R Commander“, šis metodas neveiks arba rezultatai bus netikėti (pvz., klaida). Tad dirbant „R Commander“ rekomenduoju naudoti tik taisyklingus objektų pavadinimus. 4.4 Svarbiausi R duomenų tipai Programa „R“ yra skirta darbui su duomenimis. Pagal prigimtį duomenys būna skirtingų tipų (pvz., skaičiai ar kategorijos). Vieną klasifikaciją, kuri svarbi statistinei analizei, peržvelgėme teorinių paskaitų metu. Dėl praktinių (pvz., ar patogu dirbti) bei techninių (pvz., kiek vietos užima kompiuterio atmintyje) sumetimų kiekviena kompiuterinė duomenų analizės sistema savaip apibrėžia duomenų tipus. Reiktų žinoti, kad yra „teoriniai statistiniai“ ir „kompiuteriniai“ duomenų tipai. Visi „R“ objektai turi savybę pavadinimu klasė (angl. class), kas reiškia, kad su skirtingos klasės objektais tos pačios funkcijos gali elgtis skirtingai (pvz., funkcija plot() braižo skirtingo tipo grafikus, funkcija summary() atlieka skirtingo tipo skaitines suvestines). Objekto klasę galime patikrinti naudodami funkciją class(). Per objektų klasių prizmę ir aptarsime svarbiausius programos „R“ duomenų tipus 4.1. Lentelė 4.1: Pagrindiniai „R“ duomenų tipai. Kompiuterinio duomenų tipo pavadinimas „R“ klasė Alternatyvus pavadinimas Atitinkamas statistinių duomenų tipas Reikšmių užrašymo pavyzdys Sveikieji skaičiai¹ integer Kiekybiniai 1L, -65L, 0L Realieji skaičiai¹ numeric double Kiekybiniai 42, -0.6, 1.2e2, .3 Loginės reikšmės¹ logical boolean Atitikmens neturi TRUE, FALSE Ženklų eilutės¹(tekstas) character strings Atitikmens neturi &quot;labas&quot;, &#39;A4&#39; Faktorius² factor Kategoriniai ¹ – Pagrindinis (atominis) duomenų tipas. ² – Sudėtinis duomenų tipas (bus aptarta vėliau). Aptarkime kiekvieną iš šių klasių plačiau. 4.4.1 Skaitiniai kintamieji Prieš aptardami technines detales apie svarbiausius skaitinius „R“ duomenų tipus įsidėmėkite tai, kad: Klasė „integer“ tinka ir tolydiesiems, ir diskretiesiems (jei jie suapvalinti iki sveikųjų dalių) kiekybiniams duomenims reprezentuoti. Klasė „numeric“ taip pat tinka ir tolydiesiems, ir diskretiesiems kiekybiniams duomenims. Abi skaitinių kompiuterinių duomenų klasės („numeric“ ir „integer“) yra tinkamos statistiniams kiekybiniams kintamiesiems reprezentuoti. Klasė „numeric“ Klasė „numeric“ – tai realieji skaičiai, t. y., skaičiai su kableliu. Šios klasės objektai kompiuterijoje dar vadinami „double“ (nuo „double-precision floating-point format“). Visiems skaičiams (ne tik „numeric“ klasės) programoje naudojamas tam tikras spalvinis žymėjimas. Be papildomų nurodymų programoje „R“ parašytas skaičius suprantamas kaip klasės „numeric“ atstovas, pvz., 0, 42 ar -3.2. Konsolėje parašykite class(42) ir įsitikinsite. Programoje „R“ sveikoji ir dešimtoji dalys skaičių rašomos atskiriant tašku, pvz., 10.66, o ne kableliu 10,66 (atkreipkite dėmesį į tai, kad kablelis paryškintas kita, skaičiams nebūdinga spalva). Taip yra todėl, kad tai, kas lietuviškai vadinama „kableliu“, angliškai užrašoma kaip taškas (žiūrėti pavyzdžius). Jei sveikoji skaičiaus dalis yra 0, tai jos galime nerašyti, pvz., .01 yra tas pats, kas 0.01, o -.2 atitinka -0.2. Šitoks užrašymas gali būti naudojamas ne tik programoje „R“, bet ir mokslinėje literatūroje. Realieji skaičiai gali būti užrašomi ir inžineriniu-moksliniu formatu naudojant simbolius \\(e\\) arba \\(E\\) (abiem atvejais ta pati reikšmė), kur 1e4 reiškia \\(1\\cdot10^4\\), o 2.3e-2 reiškia \\(2.3\\cdot10^{-2}\\). Pvz., 1e2, -1.2E-2. Kad ir kokiu būdu būtų užrašyti, programoje „RStudio“ skaičiai yra išryškinami ta pačia skaičiams būdinga spalva (ji priklauso nuo pasirinktos spalvų schemos): -1.2E-2, 2, .06. (Šioje svetainėje žaliai išryškinami tik sveikieji skaičiai, pvz., lentelėje 4.1). „R“ duomenų statistiniuose aprašymuose trumpinama num arba dbl. Tinka reprezentuoti bet kokiems kiekybiniams statistinių duomenų tipams. Svarbu! Į programą „R“ įvestų skaičių sveikoji ir dešimtoji dalis visada atskiriama tik tašku, bet ne kableliu. Skaičių sekos užrašymo pavyzdys ir jos atvaizdavimo grafiškai pavyzdys: seka_num &lt;- c(125.4, 122.3, 100, 111.2, 101, 121, 122, 119.3) plot(seka_num) Užduotis 4.12 „RStudio“ konsolėje įvykdykite po vieną komandą ir stebėkite, koks atsakymas (gali būti ir klaida): 1 class(1) 1e2 1E3 1e-3 1E-2 1.691e2 class(1.691e2) str(1e2) # str() - objekto struktūra Ar suprantate kiekvieną šio kodo eilutę? Klasė „integer“ Klasei „integer“ priklauso teigiami ir neigiami sveikieji skaičiai bei nulis: Sveikasis skaičius kompiuterio atmintyje užima mažiau vietos nei realusis ar kompleksinis. Mūsų kurso metu naudojamiems duomenims šis skirtumas nebus praktiškai reikšmingas. Norint, kad skaičius būtų saugomas kaip sveikasis, jo pabaigoje parašome L didžiąją raidę, pvz., 4L. Sveikasis skaičius įprastai gali būti ne mažesnis nei -2147483647 ir ne didesnis nei 2147483647. Tačiau to mums prisiminti nereikia, nes jei parašytume netinkamo dydžio skaičių, „R“ mums apie tai praneš įspėjimo žinute. „R“ duomenų statistiniuose aprašymuose trumpinama int. Įprastai naudojamas kiekybiniams diskretiesiems statistiniams kintamiesiems reprezentuoti, bet tinka ir iki sveikosios dalies suapvalintiems tolydiesiems. Užduotis 4.13 „RStudio“ redaktoriaus lange parašykite 100, L, 100L. Kokiomis spalvomis paryškino užrašą 100L? Konsolėje įvykdykite kodą 100L. Koks atsakymas? Konsolėje įvykdykite kodą class(100L). Koks atsakymas? Įvykdykite kodą: str(100L) # str() - objekto struktūra 4.4.2 Loginės reikšmės Programoje „R“ yra dvi loginės reikšmės TRUE (taip, tiesa) ir FALSE (ne, netiesa), kurios priklauso klasei „logical“: Atsiranda atliekant palyginimą arba sąlygos tikrinimą, pvz., 1 &lt; -1 (lyginame 1 ir -1) arba is.numeric(24) (tikriname, ar 24 priklauso klasei „numeric\"). Loginės reikšmės gali būti užrašomos ir sutrumpintai (T arba F), bet visą laiką tik didžiosiomis raidėmis. Atliekant matematinius veiksmus, loginės reikšmės automatiškai paverčiamos į skaičius: TRUE į 1, FALSE į 0. Tad veiksmo TRUE + TRUE + FALSE atsakymas bus 2. Jei pradiniai statistiniai duomenys užrašyti loginėmis reikšmėmis, prieš atliekant statistinę analizę, loginius kintamuosius įprastai reikia pasiversti į kategorinius naudojant funkciją factor() arba as.factor(). Statistiniuose „R“ duomenų aprašymuose trumpinama: lgl, lgcl arba logi. Užduotis 4.14 Kam lygios šios išraiškos? Nurodykite konkretų atsakymą, arba kad „R“ neapskaičiuos (bus klaida). Nenaudokite programos „R“, apskaičiuokite mintinai: sum(TRUE, TRUE, TRUE, FALSE, TRUE) x &lt;- c(&quot;vyras&quot;, &quot;moteris&quot;, &quot;vyras&quot;, &quot;moteris&quot;, &quot;moteris&quot;) sum(x == &quot;moteris&quot;) # == atlieka palyginimą, o = priskyrimą Įvykdykite kodą: str(TRUE) # str() - objekto struktūra 4.4.3 Tekstiniai kintamieji Ženklų ir simbolių eilutės (tekstas) – priklauso klasei „character“, angliškai dar vadinamos terminu „strings“: Mūsų kurso metu tai bus pagalbinis duomenų tipas, kurio reikia norint užrašyti, pvz., grafikų pavadinimus. Tekstinės reikšmės sukuriamos tekstą ar simbolius parašius dvigubuose (&quot;...&quot;) ar viengubose (&#39;...&#39;) „kompiuteristų“ kabutėse (atkreipkite dėmesį, kad tos kabutės yra tiesios ir jose esantis tekstas įprastai paryškinamas tam tikra spalva, šioje svetainėje ji yra žalia), o ne pagražintose „literatūrinėse“ kabutėse, pvz., „...“ arba ‘...’ (šio tipo kabutėse esantis tekstas nėra paryškintas klasei „character“ būdinga spalva, jis pilkas). Ženklų eilučių pavyzdžiai: &quot;labas&quot;,&#39;A4&#39;. „R“ duomenų eilutės palaiko specialiuosius simbolius, kurie prasideda ženklu \\, vadinamu „išeities simboliu“ (angl., escape character). Pvz., \\n – nurodo, kad spausdinant tekstą šioje vietoje bus nauja eilutė, \\t – tabuliacija (tam tikros rūšies tarpas), \\\" ir \\' – nurodo, kad šioje vietoje bus kabutės (kabutėse), o ne ženklų eilutės pabaiga. Norėdami atspausdinti paprastą atgal pasvirusį brūkšnį, jį turime rašyti 2 kartus (\\\\). Vienose situacijose tai yra labai patogu, kitose – labai neįprasta ir apsunkina eilutės suprantamumą. Jei pradiniai duomenys yra tekstiniai, juos įprastai pasiversime į kategorinius duomenis naudodami funkciją factor() arba as.factor(). Kompiuterio atmintyje faktoriai užima mažiau vietos nei tekstas. „R“ duomenų statistiniuose aprašymuose trumpinama chr arba char. Prieš atliekant statistinę analizę, tekstinių kintamųjų reikšmės verčiamos į kategorinių kintamųjų reikšmes. Užduotis 4.15 Komanda writeLines() žmogui suprantama išraiška atspausdina ženklų eilutes. „RStudio“ konsolėje įvykdykite kiekvieną komandą ir stebėkite, koks atsakymas (gali būti ir klaida): writeLines(&quot;1 Abc&quot;) writeLines(„2 Abc“) # :( writeLines(&#39;3 Abc&#39;) writeLines(‘4 ABC’) # :( writeLines(&quot;5 A &#39;BC&#39;&quot;) writeLines(&#39;6 A &quot;BC&quot;&#39;) writeLines(&quot;7 A \\&quot;BC\\&quot;&quot;) # \\&quot; kabutės kabutėse writeLines(&quot;8 A\\tB\\tC&quot;) # \\t tabuliacija writeLines(&quot;9 A\\nB\\nC&quot;) # \\n nauja eilutė writeLines(&quot;A\\\\B\\\\C&quot;) # \\\\ tiesiog atgal pasviręs brūkšnys str(&quot;ABC&quot;) # str() — objekto struktūra Ar galite paaiškinti, kodėl gautas būtent toks rezultatas? 4.4.4 Faktoriai – kategoriniai kintamieji Nominalieji duomenys Faktorius (klasė „factor“) – tai „R“ duomenų tipas, turintis iš anksto apibrėžtą galimų skirtingų reikšmių (kategorijų) skaičių. Faktoriai skirti saugoti kategorinių kintamųjų reikšmes. Faktoriai turi iš anksto apibrėžtą galimų reikšmių (kategorijų) skaičių. Programoje „R“ kategorijos vadinamos „lygiais“ (angl. levels). Faktorius yra sudėtinis duomenų tipas: faktorių reikšmės kompiuterio atmintyje saugomos kaip sveikieji skaičiai (t. y., kategorijos kodai), o kategorijų pavadinimai – kaip tekstas. Tokiu būdu kategoriniai duomenys kompiuterio atmintyje užima mažiau vietos nei tekstas. Statistiniuose aprašymuose klasė „factor“ trumpinama fct, fctr arba tiesiog Factor. Faktorius gali būti sukurtas naudojant funkciją factor(), o argumentas levels skirtas nurodyti pageidaujamą kategorijų eilės tvarką: mano_kategorijos &lt;- factor(c(&quot;A&quot;, &quot;C&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;A&quot;), levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) mano_kategorijos # Atspausdiname rezultatą ## [1] A C C B A A ## Levels: A B C Tie patys duomenys, tik kita kategorijų eilės tvarka: mano_kategorijos_2 &lt;- factor(mano_kategorijos, levels = c(&quot;B&quot;, &quot;A&quot;, &quot;C&quot;)) mano_kategorijos_2 # Atspausdiname rezultatą ## [1] A C C B A A ## Levels: B A C Duomenys priklauso klasei „factor“: class(mano_kategorijos) ## [1] &quot;factor&quot; Skirtumas pasimato sudarant lenteles ir braižant grafikus: # Stulpelinė diagrama plot(mano_kategorijos) # Stulpelinė diagrama # (tiems patiems duomenims pakeista kategorijų eilės tvarka) plot(mano_kategorijos_2) (Prisiminkite, kokio tipo grafiką funkcija plot() nubraižė skaitiniams kintamiesiems. T. y., ar tokio paties?) Bandant palyginti kelias faktoriaus reikšmes, „R“ pasakys, kad tokį veiksmą atlikti neprasminga (not meaningful for factors), nes kategoriniai kintamieji neturi natūralaus kategorijų eiliškumo: # [1] pirmas elementas, t. y. raidė „A“ # [2] antrasis elementas, t. y. raidė „C“ mano_kategorijos[1] &lt; mano_kategorijos[2] ## Warning in Ops.factor(mano_kategorijos[1], mano_kategorijos[2]): &#39;&lt;&#39; not ## meaningful for factors ## [1] NA Simbolis NA reiškia, kad atsakymas yra negalimas (angl., not available). Ranginiai duomenys Ranginiams duomenims įprastai naudojama klasė „ordered“. Ji sukuriama naudojant tą pačią funkciją factor() ir nurodant argumentą ordered = TRUE: ranginis &lt;- factor(mano_kategorijos, ordered = TRUE) ranginis ## [1] A C C B A A ## Levels: A &lt; B &lt; C Iš principo, tai tie patys faktoriai, tik papildomai kategorijos turi eilės tvarką, todėl galima palyginti, kuri reikšmė yra didesnė. class(ranginis) ## [1] &quot;ordered&quot; &quot;factor&quot; Ranginio kintamojo reikšmes galima palyginti, nes rangai turi eilės tvarką: ranginis[1] &gt; ranginis[2] ## [1] FALSE Statistiniuose aprašymuose klasė „ordered“ trumpinama kaip ord arba Ord.factor. Užduotis 4.16 Atkartokite šiame skyriuje pateiktus pavyzdžius su faktoriais, tik kategorijų eilės tvarką išdėliokite nuo C iki A. Atvaizduokite grafiškai. Kas pasikeitė? Kintamasis mano_kategorijos buvo sukurtas šio skyriaus pavyzdžiuose. Įvykdykite funkciją unclass(mano_kategorijos). Kaip galėtumėte paaiškinti rezultatą? (Užrašę ?unclass gauname tokį paaiškinimą: „unclass returns (a copy of) its argument with its class attribute removed.“) Įvykdykite kodą šiame skyriuje sukurtiems kintamiesiems: str(ranginis) str(mano_kategorijos) 4.5 R duomenų struktūros Terminas „duomenų struktūra“ nurodo formą, kuria saugomi duomenys. Jei duomenis prilygintume mėgintuvėliams, tai duomenų struktūros būtų tam tikro tipo dėžutės ir laikikliai, skirti tam tikru būdu mėgintuvėlius išdėlioti ir saugoti. Programoje „R“ yra 4 pagrindinės duomenų struktūros: (atominis) vektorius (vector) – tai to paties duomenų tipo reikšmių seka. (Žodis „atominis“ ir reiškia, kad duomenys yra vieno tipo). Neturi nei eilučių, nei stulpelių. Ši duomenų struktūra atitinka duomenų eilutę arba kintamąjį statistikos prasme. Mūsų kurso metu ši struktūra yra labai svarbi. Pavyzdys: į vektorių surašomi visų Gyvybės mokslų centro (GMC) studentų ūgiai. Kitas pavyzdys, į vektorių surašomos visų GMC dėstytojų plaukų spalvos. matrica (matrix) – tai lentelės pavidalo duomenų struktūra, sudaryta tik iš vieno tipo duomenų. Turi eilutes ir stulpelius. Iš skaitinių reikšmių sudarytos matricos atitinka matricas, apie kurias mokėmės per matematikos kursą universitete. Naudojantis jomis efektyviai sprendžiami tiesinės algebros uždaviniai, pvz., atliekama pagrindinių komponentų ar klasterinė analizės. duomenų lentelė (data.frame) – tai lentelės pavidalo duomenų struktūra (turi eilutes ir stulpelius), kurios visi stulpeliai yra vienodo ilgio. Nuo matricos skiriasi tuo, kad skirtinguose stulpeliuose gali būti skirtingo tipo duomenys, tačiau tame pačiame stulpelyje būna tik to paties tipo duomenys. T. y., duomenų lentelės stulpeliai yra vienodo ilgio (atominiai) vektoriai. Tai pagrindinė duomenų struktūra, su kuria dirbsime šio kurso metu. Pavyzdys. Duomenų lentelė sudaryta iš 3 stulpelių: pirmame studentų ūgiai, antrame – tų pačių studentų plaukų spalvos, trečiame – vėlgi tų pačių studentų matematikos egzamino pažymiai. sąrašas (list) – tai duomenų struktūra, kurios kiekvienas elementas gali būti skirtingo ilgio ir talpinti skirtingo tipo duomenis. Paprasčiausiu atveju kiekvienas elementas yra skirtingo ilgio ir duomenų tipo vektorius. Tačiau bendruoju atveju, kiekvienas sąrašo elementas yra tarsi atskiras konteineris, kuris gali talpinti skirtingas duomenų struktūras (vektorius, matricas, duomenų lenteles ar net kitus sąrašus). Tokiu būdu dažnai mums atsakymus pateikia įvairios „R“ statistinės analizės funkcijos. Pavyzdys. Sąrašas sudarytas iš 3 elementų: tiriamojo vardas, tiriamojo amžius, tiriamojo vaikų vardai. Akivaizdu, kad vardas ir amžius – skirtingi duomenų tipai. O vaikų skaičius skirtingas, todėl šis elementas kiekvieno tiriamojo atveju bus ne vienodo ilgio. Šio kurso metu svarbiausios duomenų struktūros – vektoriai ir duomenų lentelės. 4.6 Klausimai savikontrolei Užduotis 4.17 Kokie skliaustai (apvalieji, laužtiniai, riestiniai ar trikampiai) rašomi po „R“ funkcijų (komandų) pavadinimų? Kokiu simboliu žymimi „R“ kalbos komentarai? Kuo panašios ir kuo skiriasi šios „R“ programos duomenų struktūros: „R“ vektoriai, „R“ matricos, „R“ sąrašai (lists) ir duomenų lentelės (data.frames)? Lyginkite duomenų tipus, kurie gali būti saugomi šiose struktūrose, duomenų išdėstymo būdą bei kur šios struktūros gali būti panaudotos. Kaip apibūdintumėte, kas yra funkcijos argumentas? Kaip programoje „R“ užrašomos loginės reikšmės „tiesa“ ir „netiesa“? Kas yra „R“ konsolė? Ką ji daro? Ką reiškia užrašai 1e4 bei 9e-4? Kaip rekomenduojama rašyti „R“ objektų pavadinimus? Pateikite 2 tokių pavadinimų pavyzdžius. Kur – matricoje ar duomenų lentelėje – gali būti skirtingų tipų (pvz., ir skaičiai, ir faktoriai, ir tekstas) duomenys? Ar duomenų lentelėje visi stulpeliai būtinai privalo būti vienodo ilgio? Kokie „R“ operatoriai atlieka šias operacijas: objekto kūrimas (reikšmės priskyrimas)? Ką „R“ programos kode reiškia simbolis #? Iki kur jis galioja? Nuo kur nebegalioja? Kokie „R“ duomenų tipai yra svarbiausi šiam kursui? Žinokite jų pavadinimus ir lietuvių, ir anglų kalba. Kokios „R“ klasės tinkamos skaitiniams tolydiesiems ir kokios skaitiniams diskretiesiems duomenis? Kokios „R“ klasės tinkamos kategoriniams duomenims? Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["r-paketai.html", "5. R paketai 5.1 Paketų užkrovimas 5.2 RStudio langas Packages 5.3 R paketų saugyklos 5.4 Apie paketų diegimą 5.5 Funkcijų naudojimas neužkrovus paketų 5.6 Plačiau apie paketus Klausimai ir komentarai", " 5. R paketai Įsivaizduokite, kad įsigijote naują mobilųjį telefoną (pav. 5.1). Kas jame įdiegta? Na, galima sakyti, kad jis yra „tuščias“: sistema, pvz., „Android“, tam, kad telefonas veiktų apskritai, bei kelios programėlės, kad galėtumėte paskambinti, parašyti žinutę ar aplankyti interneto tinklalapį. Ką darote? Ogi einate į svetainę, tokią kaip „Google Play“ (ar kitą priklausomai nuo kompanijos, pagaminusios telefoną), ir atsisiunčiate naujausias ir jums patogiausias programėles, taip išplėsdami savo išmaniojo įrenginio galimybes. „R“ – lyg naujas išmanusis telefonas „R“ paketai – tarsi programėlės, kurias galima parsisiųsti Pav. 5.1: Analogija tarp „R“, „R“ paketų ir mobiliojo telefono. Iliustracijos šaltinis: Panašiai yra ir su programa „R“. Pati programa turi tik bazines funkcijas, todėl užima gana nedaug vietos. Šių funkcijų gali ir užtekti. Visgi, kai kurie naudotojai nori labiau jų poreikiams pritaikytos programos. Turbūt nenustebsite, kad ekonomistams, psichologams, biologams ir kitų sričių specialistams reikalingi šiek tiek kitokie statistinės analizės aspektai. Dėl šių priežasčių programos „R“ galimybes galima smarkiai išplėsti papildiniais, kurie vadinami paketais (angl. packages). Tai tarsi programėlės mobiliojo telefono pavyzdyje. Du svarbūs dalykai susiję su „R“ paketais yra diegimas (angl., installation) ir užkrovimas (angl., loading). Dabar juos apžvelgsime. 5.1 Paketų užkrovimas Atidarius „R“, automatiškai užkraunami tik keli pagrindiniai paketai. Visus likusius užsikrauname, kai jų prireikia. (Juk ir įsijungę telefoną atsidarome ne visus „apps’us“ iš karto, o tik tuos, kuriuos tuo metu naudojame). Be to, paketus reikia užkrauti kiekvieną kartą iš naujo įjungus ar perkrovus „R“, nes kai programa išjungiama, išjungiami ir paketai. Paketus užkrauna komanda library(), kurios skliaustuose rašomas dominančio paketo pavadinimas. Alternatyva (kurios nerekomenduoju) – funkcija require(). Taip pat šiam tikslui skirtas „RStudio“ langas „Packages“. 5.2 RStudio langas Packages Programa „RStudio“ turi paketų valdymui (parsisiuntimui iš saugyklos CRAN, užkrovimui, pašalinimui iš kompiuterio ir kt.) skirtą langą. Paketų valdymo principai naudojant programą „RStudio“ pateikti 5.2. Pav. 5.2: Paketų užkrovimas naudojantis „RStudio“. Paaiškinimai tekste. Paveiksle 5.2 pateiktas pavyzdys, kaip naudojantis „RStudio“ surandamas ir užkraunamas paketas dplyr (A, B, C). Pirma, lango „Packages“ (A) paieškos laukelyje (B) surenkame visą ar dalį paketo pavadinimo. Paketų sąrašas susiaurėja. Sąraše rodomi paketų pavadinimai (pvz., dplyr), aprašymas ir versija (pvz., 0.7.3). Ties norimo paketo pavadinimu uždėję varnelę (C), paketą užkrauname (prijungiame) ir galime naudoti jo funkcijas. Šią varnelę nuėmę, paketą atjungiame ir jo funkcijų naudoti nebegalime. Paspaudus mygtuką, pažymėtą „D“, ištuštinamas paieškos laukelis (B). Paspaudus „Update“ (G) saugykloje „CRAN“ ieškoma, ar yra įdiegtų paketų atnaujinimų: jei yra, programa paklausia, kuriuos paketus norite atnaujinti. Jei paketą neseniai įdiegėme ar atnaujinome ir jo sąraše nesimato, sąrašą galime atnaujinti paspaudę mygtuką, pažymėtą „E“. Jei paspausime mygtuką ties „F“, tada paketas bus pašalintas iš kompiuterio visam laikui (na, iki tol, kol įdiegsime iš naujo). Užduotis 5.1 Naudodamiesi „RStudio“ langu „Packages“: Patikrinkite, ar užkrautas paketas base (jei teisingai ieškosite, paketas bus sąrašo apačioje). Patikrinkite, ar įdiegtas paketas tidyverse. Patikrinkite, ar įdiegtas paketas DescTools. 5.3 R paketų saugyklos Pirmą kartą įsidiegus „R“ ir „RStudio“, į kompiuterį įdiegiami tik keli baziniai paketai. Kai prireikia papildomų, juos reikia atsisiųsti atskirai. Kaip ir telefono programėles, paketus užtenka atsisiųsti vieną kartą (nebent norite atnaujinti). Yra kelios pagrindinės „R“ paketų saugyklos: „CRAN“ (Comperhensive R Archive Network) – pagrindinė saugykla, kurioje esantys paketai turi atitikti tam tikrus kokybės standartus. Jose esančios paketų versijos yra stabilios. Iš čia parsisiuntėme „R“. Iš čia paketus siunčiamės dažniausiai. „Bioconductor“ – tai specializuota saugykla bioinformatikos analizei skirtiems „R“ paketams. „GtiHub“ saugyklos, kuriose galima rasti ne tik „R“, bet ir kitų programų papildinių. Čia įprastai saugomos vis dar kuriamos bei tobulinamos (angl. development) „R“ paketų versijos, tad jos įprastai yra naujesnės, nei „CRAN“’e. Bet nebūtinai stabilios (t. y., gali turėti dar neišspręstų problemų). Yra ir kitų saugyklų. 5.4 Apie paketų diegimą Jei paketo jūsų kompiuteryje nėra, tada jį reikia atsisiųsti ir įsidiegti. Yra keletas vietų (saugyklų), iš kur paketai gali būti atsiųsti. Dėl šios priežasties kiekvienai saugyklai turi būti naudojamas vis kitoks kodas. 5.4.1 Diegimas iš CRAN Diegimui iš „CRAN“ naudojama funkcija install.packages(), kurios skliaustuose kabutėse nurodomas dominančio paketo pavadinimas, pvz.: install.packages(&quot;remotes&quot;) Apie paketų diegimą iš „CRAN“ taip pat rašoma skyriuje „1.4 R paketų diegimas“. 5.4.2 Diegimas iš GitHub Jei norime diegti kelis paketus iš karto, juos nurodome kaip tekstinių reikšmių seką (naudojame funkciją c()): install.packages(c(&quot;remotes&quot;, &quot;devtools&quot;)) Norint diegti iš kitur, prieš tai reikia būti atsisiuntus paketą remotes (arba devtools). Tada diegdami, pvz., iš „GtiHub“, naudojame komandą remotes::install_github(). Funkcijos skliaustuose įrašome vartotojo vardą (kurio paketą diegsimės) ir saugyklos pavadinimą tokiu formatu &quot;vartotojas/saugykla&quot;, pvz.: remotes::install_github(&quot;Rapporter/pander&quot;) Šis kodas iš vartotojo Rapporter saugyklos „pander“ parsiunčia paketą pander. Seniau paketų atsiuntimui naudojamos funkcijos buvo pakete devtools. Tačiau kūrėjai jas perkėlė į remotes, o iš šio paketo importuoja į devtools. Tai reiškia, kad tiek naujoji komanda remotes::install_github(), tiek senoji devtools::install_github() veiks. 5.5 Funkcijų naudojimas neužkrovus paketų Norėdami naudoti funkciją neužkrovus paketo arba norėdami programai „R“ nurodyti, kad būtų naudojama funkcija iš konkretaus paketo, jei yra kelios vienodą pavadinimą turinčios funkcijos, naudosime operatorių :: tokiu stiliumi: paketas::funkcija(). Pvz., remotes::install_github(). Dalis šio skyriaus medžiagos kol kas yra paslėpta. –&gt; 5.6 Plačiau apie paketus Išsamesnė informacija apie „R“ paketus pradedantiesiems pateikta straipsnyje „R Packages: A Beginner’s Guide“ . Apie paketų kūrimą rašoma knygoje „R packages“ . Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["teorija-skaitines-suvestines.html", "6. Skaitinės suvestinės (teorija) 6.1 Aprašomoji statistika 6.2 GA parametrai ir imties statistikos 6.3 Aprašomosios statistikos 6.4 Imties dydis – jį privaloma pateikti ataskaitoje 6.5 Kaip statistiškai aprašyti vieno kintamojo reikšmes? 6.6 Kaip pasirinkti tolydiesiems duomenims tinkamas suvestines? 6.7 Kvantiliai ir kvartiliai 6.8 Statistinis dažnis ir dažnių lentelės Klausimai ir komentarai", " 6. Skaitinės suvestinės (teorija) 6.1 Aprašomoji statistika Aprašomoji statistika – yra statistikos mokslo dalis. Jos esmė – atlikti skaitines bei grafines duomenų suvestines, kurios glaustai perteikia esminius duomenų bruožus. 6.2 GA parametrai ir imties statistikos Jeigu atliekant statistinius skaičiavimus naudojami visos generalinės aibės (GA) duomenys, tada rezultatą – apskaičiuotąją GA charakteristiką – vadiname generalinės aibės parametru (pvz., GA vidurkis). Jei analogiškiems skaičiavimams naudojami imties duomenys, tada rezultatą – imties charakteristiką – vadiname imties statistika (pvz., imties vidurkis). Generalinė aibė → parametras. Imtis → statistika. 6.3 Aprašomosios statistikos Imties statistikas galima skirstyti į kelias sąlygines grupes (pav. 6.1): Pav. 6.1: Imties statistikų rūšys. Šiame skyriuje nagrinėsime aprašomąsias statistikas. Aprašomosios statistikos – charakteristikos, skirtos glaustai apibūdinti imties duomenis. Aprašomųjų statistikų pavyzdžių pateikta pav. 6.2. Įverčiai – tai, pagal turimus imties duomenis, geriausias spėjimas, koks yra tikrasis GA parametras (pvz., tikrasis vidurkis). Būna 2 rūšių: taškiniai įverčiai; intervaliniai įverčiai (pvz., pasikliauties intervalai). Statistinių kriterijų statistikos – tai dydžiai, kurių pagalba tikrinamos statistinės hipotezės ir daromos statistinės išvados (pvz., t statistika Stjudento t teste). Pav. 6.2: Aprašomųjų statistikų ir kitų skaitinių suvestinių pavyzdžiai. * – kitos suvestinės. 6.4 Imties dydis – jį privaloma pateikti ataskaitoje Imties dydis – tai statistika, kurią privaloma nurodyti kiekvienoje duomenų analizės ataskaitoje. 6.5 Kaip statistiškai aprašyti vieno kintamojo reikšmes? Prieš atliekant vieno kintamojo suvestines, reikia nustatyti kintamojo duomenų tipą. Panagrinėkime du kraštutinumus – nominaliuosius ir tolydžiuosius duomenis. Šiais atvejais – įprasti tokie pasirinkimai: Kategoriniams nominaliesiems duomenims nurodoma: imties dydis; dažnių lentelės. Tolydiesiems duomenims: imties dydis; duomenų centras (įprastai vidurkis arba mediana); duomenų sklaida (įprastai SD, kvantiliai, MAD arba IQR). Jei duomenys ranginiai arba skaitiniai diskretieji, jiems gali tikti ir tolydžiųjų, ir diskrečiųjų duomenų aprašymo metodai. Įvertinus, į ką – tolydžiuosius ar diskrečiuosius duomenis – konkretus kintamasis panašesnis, parenkamas aprašomosios statistikos metodas. Įprasti pasirinkimai: Ranginiams duomenims: imties dydis; dažnių lentelė; mediana; kiti centrą (pvz., vidurkis) ir sklaidą (pvz., SD) aprašantys dydžiai naudojami tik tada, jei jie turi prasmę. Diskretiesiems skaitiniams duomenims: imties dydis; duomenų centras; duomenų sklaida; dažnių lentelė (įprasta, kai skirtingų reikšmių mažai). 6.6 Kaip pasirinkti tolydiesiems duomenims tinkamas suvestines? Kai jau nustatėme, kad duomenys tolydieji, toliau žiūrime į duomenų pasiskirstymo formą ir įvertiname, ar yra išskirčių. Tokiu būdu nustatome, kokios statistikos geriausiai apibūdina duomenų centrą ir sklaidą (išsidėstymą apie tą centrą): Jei duomenys simetriški ir be ryškių išskirčių, įprastai centrui apibūdinti naudojamas aritmetinis vidurkis ir sklaidai – standartinis nuokrypis (SD). Jei duomenys smarkiai asimetriški arba turi ryškių išskirčių, labiau tinka išskirtims ir nukrypimams atsparios (robastiškos) statistikos: centrui – mediana, sklaidai – kvartiliai, MAD (medianinis absoliutusis nuokrypis nuo medianos), IQR (tarpkvartilinis plotis). Galutinėje ataskaitoje tyrėjo nuožiūra pasirenkamas vienas labiausiai tinkantis centro padėties ir vienas sklaidos aprašymo būdas. Taip pat nurodomas ir imties dydis. Statistiškai aprašant tolydžiuosius duomenis įprasta apibūdinti imties dydį, duomenų centro padėtį ir sklaidą. 6.7 Kvantiliai ir kvartiliai Kvantilis (pažymėkime raide \\(q\\)) – \\(\\beta\\)-tosios eilės kvantilis yra reikšmė, kuri variacinę eilutę dalina į \\(\\beta \\times 100\\) ir \\((1-\\beta) \\times 100\\) procentinių dalių. Čia \\(\\beta\\) yra dalis – skaičius tarp 0 ir 1 \\((0 &lt; \\beta &lt; 1)\\). Atkreipkite dėmesį, kad kvantilis matuojamas tais pačiais matavimo vienetais, kaip ir tiriamieji duomenys: jei matuojame ilgį centimetrais, tai kvantilis yra tam tikras ilgis centimetrais, jei masę kilogramais, tai ir kvantilis bus tam tikra masė kilogramais. Pvz., jei kvantilis \\(q_{\\beta=0.2} = 35 \\mu m\\) (įprastai bus žymimas tiesiog \\(q_{0.2} = 35 \\mu m\\)), tai reiškia, kad 20% mūsų imtyje esančių tiriamųjų yra mažesni už \\(35 \\mu m\\) ir 80% didesni už šį kvantilį. Tai pat pastebėkite, jog skaičius \\(\\beta\\) šalia kvantilio nurodo, kuri imties narių dalis yra mažesnė už kvantilio reikšmę. Kvantilis \\(q_{0.5}\\) yra plačiausiai naudojamas ir turi specialų pavadinimą – mediana \\((Md)\\). Tai skaičius, variacinę eilutę dalinantis į dvi lygias dalis santykiu 50%:50%. Kvartiliai – tai kvantiliai, dalijantys variacinę duomenų eilutę į 4 lygias dalis. Įprastai žymimi \\(Q_1\\), \\(Md\\), \\(Q_3\\). 6.8 Statistinis dažnis ir dažnių lentelės Kintamojo reikšmės dažnis \\(f_i\\) – tai skaičius, nurodantis, kiek kartų reikšmė \\(x_i\\) pasikartojo duomenų eilutėje. Kinta intervale nuo 0 iki \\(+\\infty\\). Kintamojo reikšmės santykinis dažnis \\(\\frac {f_i}{n}\\) – tai skaičius, nurodantis, kurią duomenų eilutės dalį sudaro reikšmė \\(x_i\\). Įprastai tai skaičius tarp 0 ir 1 \\(\\left(0 \\le \\frac{f_i}{n} \\le 1 \\right)\\). Gali būti išreikštas ir procentais. Čia \\(n\\) – visas elementų skaičius (imties dydis). Kintamojo reikšmių dažnių lentelėse nurodoma, kiek kartų kiekviena diskrečiojo ar kategorinio kintamojo reikšmė pasikartojo. Dažnių lentelės – tai pagrindinės kategorinių duomenų suvestinės. Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["r-vektoriai.html", "7. Darbas su duomenų sekomis 7.1 Specialiosios paskirties žodžiai 7.2 Bendrieji darbo su vektoriais principai 7.3 Darbas su tekstiniais kintamaisiais 7.4 Darbas su kategoriniais kintamaisiais 7.5 Darbas su skaitiniais kintamaisiais 7.6 Darbas su loginiais kintamaisiais Klausimai ir komentarai", " 7. Darbas su duomenų sekomis Skyriaus video medžiaga ir komentarai dėl užduočių („YouTube“ grojaraštis) . Daugelyje situacijų duomenis galima užrašyti ir nagrinėti kaip reikšmių sekas, kurios padeda atsakyti į mums rūpimus duomenų analizės klausimus. Žiūrint griežtai, programoje „R“ yra dviejų rūšių vektoriai: to paties duomenų tipo elementų sekos, vadinamos atominiais vektoriais, ir sąrašai, kurie gali būti sudaryti iš skirtingų tipų elementų. Mūsų kursas orientuotas į pradedančiųjų lygio duomenų analizę, todėl, paprastumo dėlei, vartodami terminą „vektorius“, turėsime omenyje to paties duomenų tipo elementų sekas. Atominis vektorius yra ir pati mažiausia duomenų struktūra programoje: netgi viena reikšmė, tarkim 234, programoje „R“ yra laikoma vektoriumi, susidedančiu iš vieno elemento. Tad šiame skyriuje panagrinėsime darbo su skaitinių, tekstinių ir kitokių duomenų tipų sekomis specifiką: kaip jas sukurti, apibendrinti, atvaizduoti grafiškai, perskaičiuoti ar transformuoti. Tikslas – išmokti parengti analizei ir statistiškai apibendrinti duomenis, pateiktus kaip duomenų sekos. Šio skyriaus uždavinius reikia atlikti iš eilės: dalis uždavinių yra tęstiniai. Reikiami paketai: DescTools, tidyverse (dplyr, tibble, ggplot2, stringr ir kiti). 7.1 Specialiosios paskirties žodžiai „R“ kalboje yra žodžių, kurie atlieka specialiosios paskirties reikšmių vaidmenį (žr. lentelėje 7.1). Programa „RStudio“ juos atpažįsta ir netgi nudažo kita spalva. Lentelė 7.1: „R“ kalbos žodžiai, naudojami kaip specialiosios paskirties reikšmės. Paaiškinimas Žodis Rezultatas „R“ komandų lange Tuščias narys; tam tikrame kontekste reiškia „ištrinti“ NULL NULL Trūkstama reikšmė (trumpinys nuo angl., NA – not available, t.p., missing value) NA NA Negalima skaitinė reikšmė, skaitinė neapibrėžtis (angl., NaN – not a number) NaN NaN (Teigiama) begalybė Inf Inf Neigiama begalybė -Inf -Inf Loginė reikšmė „netiesa“ FALSE FALSE Loginė reikšmė „netiesa“ (sutrumpintai) F FALSE Loginė reikšmė „tiesa“ TRUE TRUE Loginė reikšmė „tiesa“ (sutrumpintai) T TRUE Pavyzdžiai, kaip gaunamos arba užrašomos šios reikšmės: 0/0 # neapibrėžtas skaičius (NaN - not a number) ## [1] NaN log(0) # neapibrėžtumas: labai mažas skaičius ## [1] -Inf 2 &gt; 10 # „2 daugiau už 10“; atsakymas – loginė reikšmė „netiesa“ ## [1] FALSE F # loginė reikšmė „netiesa“ (sutrumpintai) ## [1] FALSE 6 != 7 # „6 nelygu 7“; atsakymas – loginė reikšmė „tiesa“ ## [1] TRUE T # loginė reikšmė „tiesa“ (sutrumpintai) ## [1] TRUE NULL ## NULL Užduotis 7.1 Funkcijos, kurios prasideda žodžiu is, įprastai atlieka patikrinimą ir pateikia atsakymą TRUE arba FALSE. Pvz., is.na() tikrina, ar reikšmė yra trūkstama, is.nan() – ar tai negalima skaitinė reikšmė. Įvykdykite komandas is.na(NA), is.na(NaN), is.nan(NA), is.nan(NaN) ir padarykite išvadas: ar NaN yra praleistos reikšmės tipas; ar NA yra negalimos skaitinės reikšmės tipas. 7.2 Bendrieji darbo su vektoriais principai 7.2.1 Vektoriaus kūrimas „R“ vektorius statistikoje atitinka duomenų seką, dar vadinamą duomenų eilute. Kelios reikšmės į vektorių (t. y., į seką) sujungiamos naudojant komandą c() (c nuo žodžio combine arba concatenate). Reikšmės rašomos komandos skliausteliuose ir atskiriamos kableliais (,), pvz.: c(6, 23, 33, 19) ## [1] 6 23 33 19 Jei tuos pačius skaičius parašysime „R“ konsolėje be komandos c(), „R“ pamanys, kad tai atskiri niekaip nesusiję elementai, nesupras, ką su jais norime daryti, ir praneš, kad tai klaida (Error): 6, 23, 33, 19 ## Error: &lt;text&gt;:1:2: unexpected &#39;,&#39; ## 1: 6, ## ^ Komanda c() į vektorių gali sujungti ne tik skaičius, bet ir kitokios rūšies duomenų reikšmes: tekstinius kintamuosius: c(&quot;Man&quot;, &quot;puikiai&quot;, &quot;sekasi&quot;, &quot;.&quot;) ## [1] &quot;Man&quot; &quot;puikiai&quot; &quot;sekasi&quot; &quot;.&quot; logines reikšmes (angliškai vadinamos „logical“ arba „boolean“): c(TRUE, FALSE, FALSE, TRUE, TRUE) ## [1] TRUE FALSE FALSE TRUE TRUE ir kitus. Programoje „R“ kuriant vektorius, skirtingi skaičiai ar kitokio tipo reikšmės atskiriamos kableliu. O skaičių sveikoji ir dešimtoji dalys – tašku. Vektorių galime išsaugoti „R“ atmintyje kaip objektą, naudodami priskyrimo operatorių. vektorius &lt;- c(11, 20, 33, 45) Tada jį atspausdinti neišreikštuoju būdu (angl. implicit printing) – tiesiog parašomas objekto pavadinimas: vektorius ## [1] 11 20 33 45 Jei visą kodo eilutę papildomai apskliaudžiame, rezultatas įprastai taip pat būna atspausdinamas: (vektorius &lt;- c(11, 20, 33, 45)) ## [1] 11 20 33 45 Arba išreikštai (angl. explicit printing) – naudojama funkcija print()): print(vektorius) ## [1] 11 20 33 45 Yra ir kitų būdų kurti vektorius. Jie įprastai yra specifiški tam tikram duomenų tipui. Juos aptarsime vėliau. Užduotis 7.2 Sukurkite vektorių iš pateiktų skaičių ir pavadinkite jį seka_1: 1; 10; 100; 1000; 10000. Vektorių atspausdinkite. Duoti kelių merginų ūgiai metrais. Pateikite juos kaip duomenų seką merginu_ugiai ir atspausdinkite neišreikštuoju būdu. Merginų ūgiai (m). 1,67 1,56 1,66 1,59 1,77 1,71 1,69 1,66 1,68 1,55 1,70 1,72 Skirtingų tipų duomenys vienoje sekoje? Kas atsitiks, jei į vieną seką bandysime sudėti kelių tipų duomenis? „R“ visus elementus pavers į tokį tipą, kuriuo gali būti reprezentuojamos visos reikšmės. Deja, įprastai rezultatas bus netikėtas (ir tikrai ne maloniąja prasme). Atsargiai – į vieną seką sujungus skirtingus duomenų tipus rezultatas bus netikėtas! Imkime loginę reikšmę TRUE. Šiame pavyzdyje visos reikšmės bus paverstos į skaičius (TRUE → 1): c(TRUE, 1, 0, 1) ## [1] 1 1 0 1 O šiame – į tekstą (TRUE → &quot;TRUE&quot;): c(TRUE, 15, .30, &quot;mama&quot;) ## [1] &quot;TRUE&quot; &quot;15&quot; &quot;0.3&quot; &quot;mama&quot; Dar keistesnių dalykų įvyksta dirbant su sudėtiniais duomenų tipais, pvz., faktoriais. Yra tam tikros taisyklės, ką ir kokiais atvejais „R“ padaro. Tačiau pradedantiesiems, nežinantiems šių taisyklių, skirtingų tipų duomenų jungimo į vektorių rekomenduoju vengti. Užduotis 7.3 Naudodami funkciją class(), patikrinkite, kokiam duomenų tipui („R“ klasei) priklauso sekos c(TRUE, 1, 0, 1) bei c(TRUE, 15, .30, &quot;mama&quot;). 7.2.2 Vektoriaus savybių tikrinimas Aptarsime tik kelias funkcijas, skirtas vektoriaus savybių tikrinimui: length() – elementų skaičius; class() – „R“ klasė; str() ir tibble::glimpse() – struktūra; attributes() – atributai. Funkcija length() pateikia vektoriaus ilgį, t. y., suskaičiuoja, iš kelių elementų sudarytas vektorius. Ji bus naudinga, kai turėdami į vektorių surašytas reikšmes norėsime apskaičiuoti imties dydį, įprastai žymimą raide „n“: vektorius_2 &lt;- c(11, NA, 33, 45) n &lt;- length(vektorius_2) # Apskaičiuojame ir priskiriame n # Atspausdiname ## [1] 4 Atkreipkite dėmesį į tai, kad skaičiuojamos ir trūkstamos reikšmės. Bet kokio „R“ objekto, taip pat ir vektoriaus, klasę parodo funkcija class(): class(vektorius_2) ## [1] &quot;numeric&quot; Mums reiktų žinoti svarbiausius duomenų tipus atitinkančias klases: numeric; integer; character; factor; ordered; logical. Apie statistikoje naudojamus duomenų tipus rašoma skyriuje „2.5 Kintamųjų tipai statistikoje“. Apie programoje „R“ naudojamus – skyriuje „4.4 Svarbiausi R duomenų tipai“. Vektoriaus struktūrą galime peržiūrėti naudodami funkciją str(): str(vektorius_2) ## num [1:4] 11 NA 33 45 Arba glimpse() iš paketo tibble() (apie šią funkciją plačiau bus rašoma temoje apie duomenų lenteles): tibble::glimpse(vektorius_2) ## num [1:4] 11 NA 33 45 Vektoriams ši funkcija pateikia sutrumpintą „R“ duomenų tipo („R“ klasės) pavadinimą, vektoriaus ilgį (elementų skaičių) ir kelias pirmąsias reikšmes. Pavyzdyje tai: num – numeric – skaitinis duomenų tipas; [1:4] – 4 elementai (nuo 1 iki 4); toliau – 11 NA 33 ir t.t. – kelios pirmosios reikšmės. Vektoriaus savybes, vadinamas atributais, galima peržiūrėti naudojant funkciją attributes(). Atsakymas NULL rodo, kad objektas atributų neturi: attributes(vektorius_2) ## NULL Kategoriniai kintamieji turi atributą, pavadinimu levels – kategorijų pavadinimus. Užduotis 7.4 Apskaičiuokite anksčiau sukurto vektoriaus seka_1 ilgį. Programoje „R“ yra apibrėžtas kintamasis letters, kuriame surašytos mažosios angliškos abėcėlės raidės. Konsolėje atspausdinkite šį kintamąjį, parašydami letters; Naudodami komandas length() ir str() ištirkite: kiek raidžių yra angliškoje abėcėlėje? koks kintamojo tipas – skaitinis (num) ar kitoks? Ištirtos 5 gėlės ir duomenys apie jas pateikti po šio uždavinio sąlyga duomenų sekų pavidalu. Kiekvieną iš gėlės savybių (lapu_ilgis ir kt.) ištirkite naudodami funkcijas class(), str() ir attributes() (įvertinkite kiek ir kokių atributų yra). # Duomenys apie gėles lapu_ilgis &lt;- c(1.3, NA, 2.2, 1.1, 1.6) lapu_skaicius &lt;- c(24L, 22L, 28L, 25L, 25L) ziedu_spalva &lt;- factor(c(&quot;raudona&quot;, &quot;geltona&quot;, &quot;geltona&quot;, &quot;balta&quot;, &quot;balta&quot;)) kvapo_stiprumas &lt;- ordered(c(&quot;silpnas&quot;, &quot;vidutinis&quot;, &quot;stiprus&quot;, &quot;stiprus&quot;, NA)) ar_augo_lauke &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) komentaras &lt;- c(&quot;-&quot;, &quot;-&quot;, &quot;tirta ryte&quot;, &quot;-&quot;, &quot;-&quot;) 7.2.3 Vektoriaus elementų pasirinkimas Ši potemė yra susijusi su skyriumi „Elementų eilės numerių žymėjimas: [ ]“, nes norėdami pasirinkti tam tikrus vektoriaus elementus (sukurti elementų poaibį, angl. subset), galime naudoti viengubų laužtinių skliaustų operatorių []. Skliaustuose nurodomas teigiamas arba neigiamas skaitinis elemento indeksas (eilės numeris), loginis indeksas arba pavadinimas (jei elementas jį turi). Pasirinkimas pagal elemento pavadinimą Iliustracijai naudokime vektorių merginu_ugiai: merginu_ugiai ## [1] 1.67 1.56 1.66 1.59 1.77 1.71 1.69 1.66 1.68 1.55 1.70 1.72 Jei elementai turi pavadinimus, juos galime pasirinkti kabutėse nurodydami šiuos pavadinimus. Naudojant [], elementų pavadinimus reikia pateikti kabutėse. Sakykime, turime seką su merginų vardais. Naudodamiesi jais, suteikiame reikšmėms pavadinimus. O prieš tai nusistatykime lietuviškąją lokalę, kad galėtume naudoti lietuviškas raides: Sys.setlocale(locale = &quot;Lithuanian&quot;) # Lietuviška lokalė Windows sistemai vardai &lt;- c(&quot;Inga&quot;, &quot;Greta&quot;, &quot;Jonė&quot;, &quot;Justė&quot;, &quot;Raimonda&quot;, &quot;Laura&quot;, &quot;Žaneta&quot;, &quot;Ingrida&quot;, &quot;Kristina&quot;, &quot;Toma&quot;, &quot;Rima&quot;, &quot;Sandra&quot;) names(merginu_ugiai) &lt;- vardai # Suteikiami pavadinimai merginu_ugiai ## Inga Greta Jonė Justė Raimonda Laura Žaneta Ingrida ## 1.67 1.56 1.66 1.59 1.77 1.71 1.69 1.66 ## Kristina Toma Rima Sandra ## 1.68 1.55 1.70 1.72 Vienoje eilutėje pateiktas elemento pavadinimas (šiuo atveju, merginos vardas), kitoje – elemento reikšmė (šiuo atveju, ūgis). Dabar ūgius galime sužinoti pagal vardus: merginu_ugiai[&quot;Jonė&quot;] ## Jonė ## 1.66 merginu_ugiai[c(&quot;Jonė&quot;, &quot;Laura&quot;, &quot;Toma&quot;)] ## Jonė Laura Toma ## 1.66 1.71 1.55 Užduotis 7.5 Programoje „R“ yra pavyzdiniai duomenys state.name ir state.area. Pirmajame vektoriuje – JAV valstijų pavadinimai, antrajame – tų valstijų užimamas plotas kvadratinėmis myliomis. Parašykite kodą, kuris atsakytų į klausimus: Atspausdinkite state.area ir state.name reikšmes. Kelių valstijų duomenys pateikti? Pagal pavyzdį, valstijų plotams suteikite pavadinimus. Tada sudarykite vektorių, kuriame būtų tik šių 4 valstijų plotai: Arizona, New Jersey, Texas, Utah. Teigiami skaitiniai indeksai Norėdami pasirinkti elementą, nurodome teigiamą jo indeksą. Programoje „R“ elementų numeravimas (indeksavimas) prasideda nuo 1. Tarkime, mus domina antrasis elementas: merginu_ugiai[2] ## Greta ## 1.56 Pasirinkime antrą ir ketvirtą (atkreipkite dėmesį į tai, kad nurodant indeksus bus panaudota funkcija c()): merginu_ugiai[c(2, 4)] ## Greta Justė ## 1.56 1.59 Dar keli pavyzdžiai: (skaiciu_seka &lt;- 1:10) ## [1] 1 2 3 4 5 6 7 8 9 10 skaiciu_seka[2] ## [1] 2 skaiciu_seka[c(2, 4)] ## [1] 2 4 Užduotis 7.6 Naudodami kintamąjį letters atlikite užduotis (parašykite programos kodą): Nurodykite, kokia 16-toji abėcėlės raidė; Nurodykite, kokios yra 6, 11, 18 ir 20 abėcėlės raidės. Neigiami skaitiniai indeksai Neigiami skaitiniai indeksai panaikina nurodytuosius elementus. Prieš indeksą padedamas „minus“ (-) ženklas: merginu_ugiai[-2] ## Inga Jonė Justė Raimonda Laura Žaneta Ingrida Kristina ## 1.67 1.66 1.59 1.77 1.71 1.69 1.66 1.68 ## Toma Rima Sandra ## 1.55 1.70 1.72 merginu_ugiai[-c(2, 4, 9, 10, 11)] ## Inga Jonė Raimonda Laura Žaneta Ingrida Sandra ## 1.67 1.66 1.77 1.71 1.69 1.66 1.72 Norėdami panaikinti paskutinį elementą, galime naudoti tokį kodą: n &lt;- length(merginu_ugiai) merginu_ugiai[-n] ## Inga Greta Jonė Justė Raimonda Laura Žaneta Ingrida ## 1.67 1.56 1.66 1.59 1.77 1.71 1.69 1.66 ## Kristina Toma Rima ## 1.68 1.55 1.70 Čia n yra elementų skaičius, atitinkantis paskutinio elemento eilės numerį: 12. Dar keli pavyzdžiai: skaiciu_seka ## [1] 1 2 3 4 5 6 7 8 9 10 skaiciu_seka[-2] ## [1] 1 3 4 5 6 7 8 9 10 skaiciu_seka[-c(2, 4, 9, 10)] ## [1] 1 3 5 6 7 8 n2 &lt;- length(skaiciu_seka) skaiciu_seka[-n2] ## [1] 1 2 3 4 5 6 7 8 9 Užduotis 7.7 Naudodami kintamąjį letters atlikite užduotis (parašykite programos kodą): Pašalinkite 16-tąją abėcėlės raidę; Pašalinkite 6, 11, 18 ir 20 abėcėlės raides. Pasirinkimas pagal sąlygas (loginį indeksą) Kuriant poaibius pagal loginį indeksą pasirenkami tik tie elementai, kuriems loginis indeksas yra TRUE (pav. 7.1). Nagrinėjant šią temą naudinga žinoti, kaip atliekamos pagrindinės palyginimo operacijos (žr. skyriuje „7.6.1 Palyginimo operacijos“). Pav. 7.1: Loginiai indeksai poaibiams kurti: pasirenkami tik tie elementai, kuriems indeksas yra TRUE. Iliustracijos šaltinis: . Sakykime, mus domina tų gėlių, kurios augo lauke, lapų skaičius. ar_augo_lauke ## [1] FALSE TRUE TRUE FALSE TRUE lapu_skaicius ## [1] 24 22 28 25 25 Tada naudojame tokį užrašą: lapu_skaicius[ar_augo_lauke] ## [1] 22 28 25 Be to, abu vektoriai turi būti vienodo ilgio: length(ar_augo_lauke) == length(lapu_skaicius) # palyginimui naudojame ==, o ne = ## [1] TRUE Dabar sakykime, kad mus domina geltonų gėlių lapų skaičius. ziedu_spalva ## [1] raudona geltona geltona balta balta ## Levels: balta geltona raudona Atlikę palyginimo operaciją, sužinome, kurios gėlės yra geltonos: ziedu_spalva == &quot;geltona&quot; # TRUE, jei geltona ## [1] FALSE TRUE TRUE FALSE FALSE Palyginimo rezultatą galime išsaugoti kaip objektą, ir jį naudoti reikiamų elementų pasirinkimui net kelis kartus: ar_geltona &lt;- ziedu_spalva == &quot;geltona&quot; lapu_skaicius[ar_geltona] ## [1] 22 28 lapu_ilgis[ar_geltona] ## [1] NA 2.2 Arba palyginimo operaciją galime įrašyti tiesiai tarp laužtinių skliaustų: lapu_skaicius[ziedu_spalva == &quot;geltona&quot;] # palyginimui naudojame ==, o ne = ## [1] 22 28 Dar keli pavyzdžiai: skaiciu_seka[skaiciu_seka &lt; 5] ## [1] 1 2 3 4 skaiciu_seka[skaiciu_seka == 5] ## [1] 5 is.na(skaiciu_seka) # Tikrinimas kiekvienam elementui atskirai ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE !is.na(skaiciu_seka) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE Užduotis 7.8 Naudokite uždavinio 7.4 duomenis apie gėles. Parodykite, kiek lapų (lapu_skaicius) turėjo gėlės, kurių kvapas buvo stiprus (kvapo_stiprumas). Nenustebkite, jei atsakyme atsiras reikšmė NA. Funkcija !is.na() tikrina, kurios reikšmės yra netrūkstamos (! reiškia NE). Naudodami šią funkciją pasirinkite tik tas gėlių spalvas (ziedu_spalva), jei toms gėlėms yra žinomas lapų ilgis (lapu_ilgis). Naudodami duomenis state.name ir state.area parašykite kodą, kuris atsakytų į klausimus: Išvardinkite valstijas, kurių plotas mažesnis už 10000 kvadratinių mylių (pavadinkime jas „mažomis valstijomis“? Koks mažų valstijų skaičius? Kai kurie atsakymai pasitikrinimui (jums reikia pateikti sprendimus): ## [1] 28 25 NA ## [1] raudona geltona balta balta ## Levels: balta geltona raudona ## [1] &quot;Connecticut&quot; &quot;Delaware&quot; &quot;Hawaii&quot; &quot;Massachusetts&quot; ## [5] &quot;New Hampshire&quot; &quot;New Jersey&quot; &quot;Rhode Island&quot; &quot;Vermont&quot; Specializuotos funkcijos elementams pasirinkti Norėdami pasirinkti kelis pirmuosius elementus, galime naudoti funkciją head(), kurios argumentas n nurodo, kiek pirmųjų elementų pasirinkti: head(merginu_ugiai, n = 2) # palieka pirmus 2 elementus ## Inga Greta ## 1.67 1.56 Jei reikia pašalinti kelis paskutinius elementus (ir rodyti pirmuosius), naudojame neigiamą indeksą: head(merginu_ugiai, n = -8) # pašalina 8 paskutinius elementus ## Inga Greta Jonė Justė ## 1.67 1.56 1.66 1.59 Analogiškai funkcija tail() parodo paskutiniuosius elementus: tail(merginu_ugiai, n = 3) # palieka 3 paskutinius elementus ## Toma Rima Sandra ## 1.55 1.70 1.72 Arba pašalina pirmuosius (kad būtų rodomi tik paskutiniai): tail(merginu_ugiai, n = -7) # pašalina 7 pirmuosius elementus ## Ingrida Kristina Toma Rima Sandra ## 1.66 1.68 1.55 1.70 1.72 Jei pasirinktus elementus norėsime naudoti toliau, juos priskiriame naujam objektui, pvz.: ugiai2 &lt;- head(merginu_ugiai, n = 5) ugiai2_be_vardu &lt;- unname(ugiai2) # pašalina pavadinimus ugiai2_be_vardu ## [1] 1.67 1.56 1.66 1.59 1.77 Funkcijos head() ir tail() bus naudingos dirbant su duomenų lentelėmis: jos parodys pirmąsias ir paskutines lentelės eilutes. Dar keli pavyzdžiai: skaiciu_seka ## [1] 1 2 3 4 5 6 7 8 9 10 head(skaiciu_seka, n = 2) ## [1] 1 2 head(skaiciu_seka, n = -2) ## [1] 1 2 3 4 5 6 7 8 tail(skaiciu_seka, n = 2) ## [1] 9 10 tail(skaiciu_seka, n = -2) ## [1] 3 4 5 6 7 8 9 10 Užduotis 7.9 Naudodami kintamąjį letters atlikite užduotis (parašykite programos kodą): Atspausdinkite 10 paskutiniųjų angliškos abėcėlės raidžių; Pašalinkite 10 paskutiniųjų angliškos abėcėlės raidžių; Atspausdinkite visas raides, išskyrus pirmą ir paskutinę. 7.2.4 Vektoriaus elementų reikšmių pakeitimas Vektoriaus reikšmėms pakeisti naudojama operatorių [] ir &lt;- kombinacija. Pasidarykime objekto kopiją, su kuria dirbsime: ugiai3 &lt;- ugiai2 Galima keisti vieną ar kelias reikšmes naudojant indeksą (eilės numerį): ugiai3[1] &lt;- 1.90 ugiai3 ## Inga Greta Jonė Justė Raimonda ## 1.90 1.56 1.66 1.59 1.77 ugiai3[c(1, 3)] &lt;- c(2.00, 2.10) ugiai3 ## Inga Greta Jonė Justė Raimonda ## 2.00 1.56 2.10 1.59 1.77 Keitimas pagal loginę sąlygą: ugiai3[ugiai3 &lt; 1.60] &lt;- NA ugiai3 ## Inga Greta Jonė Justė Raimonda ## 2.00 NA 2.10 NA 1.77 Keitimas pagal pavadinimą: ugiai3[&quot;Raimonda&quot;] &lt;- 1.00 ugiai3 ## Inga Greta Jonė Justė Raimonda ## 2.0 NA 2.1 NA 1.0 Užduotis 7.10 Sudarykite „R“ vektorių, tada visas neigiamas reikšmes duomenų sekoje pakeiskite nuliais: -0.54 0.45 -1.07 0.75 0.88 -0.99 1.24 0.73 0.13 -0.10 7.2.5 Vektorizuotos operacijos Daugelis operacijų programoje „R“ yra vektorizuotos. T. y., parašius funkciją ar komandą, perskaičiavimas atliekamas kiekvienam elementui atskirai papildomai nerašant sudėtingesnio programos kodo, tokio kaip ciklas (angl., loop). Tai didelis privalumas, supaprastinantis darbą šia programa. Aritmetiniai (pvz., +, -), palyginimo (pvz., &lt;, &gt;) operatoriai veikia vektorizuotai. Iliustracijai imkime praeituose skyreliuose sukurtus objektus vektorius ir vektorius_2. vektorius ## [1] 11 20 33 45 vektorius_2 ## [1] 11 NA 33 45 Prie kiekvieno vektoriaus elemento pridėkime po 100: vektorius + 100 # atitinka c(11 + 100, 20 + 100, 33 + 100, 45 + 100) ## [1] 111 120 133 145 Palyginkime, ar reikšmės mažesnės už 21: vektorius &lt; 21 # atitinka c(11 &lt; 21, 20 &lt; 21, 33 &lt; 21, 45 &lt; 21) ## [1] TRUE TRUE FALSE FALSE Sudėkime kelių vienodo ilgio vektorių pirmuosius, antruosius, trečiuosius ir t.t. elementus: vektorius + vektorius_2 # atitinka c(11 + 11, 20 + NA, 33 + 33, 45 + 45) ## [1] 22 NA 66 90 Jei dirbame su keliais vektoriais ir vienas iš jų yra trumpesnis, trumpesniojo reikšmės cikliškai naudojamos iš naujo: vektorius + c(0, 10000) # atitinka c(11 + 0, 20 + 10000, 33 + 0, 45 + 10000) ## [1] 11 10020 33 10045 Toks elgesys dažnai yra nepageidautinas, tad būkite atidūs. Laimei, kai kurios funkcijos, kurias naudosime dirbdami su duomenų lentelėmis kitų užsiėmimų metu, apskritai stabdo skaičiavimus, jei keli vektoriai yra skirtingo ilgio, ir taip apsaugo nuo netikėtų rezultatų. Kai kurios funkcijos taip pat atlieka veiksmus su kiekvienu elementu atskirai, pvz., logaritmuoja: log(vektorius) # atitinka c(log(11), log(20), log(33), log(45)) ## [1] 2.397895 2.995732 3.496508 3.806662 Arba tikrina, kurios reikšmės yra trūkstamos (žymimos simboliu NA): is.na(vektorius_2) ## [1] FALSE TRUE FALSE FALSE Jei galite rinktis tarp vektorizuotos ir nevektorizuotos (pvz., savo pačių parašytos) funkcijos, žinokite, kad didelė tikimybė, jog pirmoji veiks efektyviau, nes yra kruopščiai parašyta, išbandyta ir optimizuota. Užduotis 7.11 Uždaviniuose 7.2 ir 7.3 buvo sukurti keli vektoriai, kuriuos dabar ir panaudosime. Vektorius merginu_ugiai: Apskaičiuokite, kiek merginų dalyvavo apklausoje. Pasirodo, visos merginos buvo apsiavusios aukštakulniais, ūgį padidinančiais 4 cm. Perskaičiuokite, koks tikrasis kiekvienos merginos ūgis. Rezultatą priskirkite kintamajam tikrieji_merginu_ugiai. Programoje „R“ dešimtainį logaritmą skaičiuoja funkcija log10(), pvz., log10(16). Šio tipo logaritmavimą atlikite kiekvienam vektoriaus seka_1 elementui. 7.3 Darbas su tekstiniais kintamaisiais Tekstiniai kintamieji – tai ne statistinis duomenų tipas. Jis reikalingas, pvz., užrašyti grafikų pavadinimus. Programoje „R“ tekstinius duomenis atitinka klasė „character“ (sutrumpintai chr). Darbui su tekstiniais kintamaisiais galime naudoti bazines arba paketo stringr funkcijas. Darbui su tekstiniais kintamaisiais skirtas specializuotas paketas stringr . Visos svarbiausios paketo stringr funkcijos prasideda str_, todėl paprasta prisiminti. str yra trumpinys nuo kompiuterinio termino „string“ – teksto eilutė. Duomenyse bus lietuviškų simbolių, todėl įsijunkime lietuviškąją lokalę. Sys.setlocale(locale = &quot;Lithuanian&quot;) # Lietuviška lokalė Windows sistemai Tekstinės reikšmės sudaromos naudojant funkciją c() ir kabutes. Skirtingos reikšmės atskiriamos kableliais. miestai &lt;- c(&quot;Vilnius&quot;, &quot;Kaunas&quot;, &quot;Klaipėda&quot;) miestai ## [1] &quot;Vilnius&quot; &quot;Kaunas&quot; &quot;Klaipėda&quot; Naudodami is.character() patikriname, ar vektorius yra tekstinis, o as.character() vektorių paverčia į tekstinį: is.character(miestai) ## [1] TRUE skaiciai &lt;- 1:5 skaiciai ## [1] 1 2 3 4 5 is.character(skaiciai) ## [1] FALSE skaiciai_chr &lt;- as.character(skaiciai) skaiciai_chr ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; is.character(skaiciai_chr) ## [1] TRUE Žodžiu is prasidedančios funkcijos tikrina, o žodžiu as – keičia duomenų tipą ar kitą savybę. Galime palyginti, ar kelios reikšmės yra vienodos: &quot;A&quot; == &quot;B&quot; ## [1] FALSE &quot;A&quot; == &quot;a&quot; ## [1] FALSE Taip pat ar reikšmė priklauso pogrupiui: &quot;Vilnius&quot; %in% miestai ## [1] TRUE &quot;A&quot; %in% miestai ## [1] FALSE Funkcijos paste() ir paste0() sujungia kelias reikšmes į vieną. paste(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) ## [1] &quot;A B C&quot; paste0(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) ## [1] &quot;ABC&quot; Gali būti pasirenkamas norimas skirtumas nurodant sep: paste(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, sep = &quot;, &quot;) ## [1] &quot;A, B, C&quot; Funkcija paste0() atitinka paste(sep = &quot;&quot;). Veikia vektorizuotai: vardas &lt;- c(&quot;Jonas&quot;, &quot;Ona&quot;, &quot;Gytis&quot;) kreipinys &lt;- c(&quot;ponas&quot;, &quot;panelė&quot;, &quot;ponaitis&quot;) vardas_ir_kreipinys &lt;- paste(kreipinys, vardas) vardas_ir_kreipinys ## [1] &quot;ponas Jonas&quot; &quot;panelė Ona&quot; &quot;ponaitis Gytis&quot; Jei visas reikšmes norime sujungti į vieną eilutę, papildomai naudojama collapse ir nurodome skirtuką: paste(kreipinys, vardas, collapse = &quot;, &quot;) ## [1] &quot;ponas Jonas, panelė Ona, ponaitis Gytis&quot; Kaip alternatyva funkcijai paste(), gali būti naudojama stringr::str_c() (reikalingas paketas stringr). Įprastai str_c() duoda labiau prognozuojamus rezultatus, kai tekstinių reikšmių vektoriuje yra praleistų reikšmių (NA). stringr::str_c(kreipinys, vardas) ## [1] &quot;ponasJonas&quot; &quot;panelėOna&quot; &quot;ponaitisGytis&quot; stringr::str_c(kreipinys, vardas, sep = &quot; &quot;) ## [1] &quot;ponas Jonas&quot; &quot;panelė Ona&quot; &quot;ponaitis Gytis&quot; stringr::str_c(kreipinys, vardas, collapse = &quot;, &quot;) ## [1] &quot;ponasJonas, panelėOna, ponaitisGytis&quot; stringr::str_c(kreipinys, vardas, sep = &quot; &quot;, collapse = &quot;, &quot;) ## [1] &quot;ponas Jonas, panelė Ona, ponaitis Gytis&quot; Kiekvienos tekstinės reikšmės simbolių skaičių pasako nchar() arba stringr::str_length(): nchar(vardas_ir_kreipinys) ## [1] 11 10 14 stringr::str_length(vardas_ir_kreipinys) ## [1] 11 10 14 Naudojant stringr::str_sort() tekstines reikšmes galima išdėlioti eilės tvarka: Nurodant locale ir dviženklį kalbos kodą (pvz., &quot;lt&quot;) galima išdėlioti abėcėlės tvarka. Nurodant numeric = TRUE – kaip skaičius. raidės &lt;- c(&quot;Z&quot;, &quot;J&quot;, &quot;Y&quot;, &quot;K&quot;) stringr::str_sort(raidės, locale = &quot;lt&quot;) ## [1] &quot;Y&quot; &quot;J&quot; &quot;K&quot; &quot;Z&quot; stringr::str_sort(raidės, locale = &quot;en&quot;) ## [1] &quot;J&quot; &quot;K&quot; &quot;Y&quot; &quot;Z&quot; skaiciai_chr_2 &lt;- c(&quot;20&quot;, &quot;5&quot;, &quot;10&quot;, &quot;150&quot;, &quot;12&quot;, &quot;1&quot;) stringr::str_sort(skaiciai_chr_2) ## [1] &quot;1&quot; &quot;10&quot; &quot;12&quot; &quot;150&quot; &quot;20&quot; &quot;5&quot; stringr::str_sort(skaiciai_chr_2, numeric = TRUE) ## [1] &quot;1&quot; &quot;5&quot; &quot;10&quot; &quot;12&quot; &quot;20&quot; &quot;150&quot; Funkcija stringr::str_order() parodo išdėliojimo eilės tvarką (naudojama analogiškai kaip str_sort()): stringr::str_order(raidės, locale = &quot;en&quot;) ## [1] 2 4 3 1 Funkcija dplyr::recode() perkoduoja reikšmes pagal šabloną senoji_reikšmė = naujoji_reikšmė: dplyr::recode(kreipinys, &quot;ponas&quot; = &quot;Mr.&quot;, &quot;panelė&quot; = &quot;Miss.&quot;) ## [1] &quot;Mr.&quot; &quot;Miss.&quot; &quot;ponaitis&quot; Taip pat gali būti naudingos funkcijos: stringr::str_to_lower(vardas_ir_kreipinys) # visos mažosios ## [1] &quot;ponas jonas&quot; &quot;panelė ona&quot; &quot;ponaitis gytis&quot; stringr::str_to_upper(vardas_ir_kreipinys) # visos didžiosios ## [1] &quot;PONAS JONAS&quot; &quot;PANELĖ ONA&quot; &quot;PONAITIS GYTIS&quot; stringr::str_to_title(vardas_ir_kreipinys) # pirma didžioji ## [1] &quot;Ponas Jonas&quot; &quot;Panelė Ona&quot; &quot;Ponaitis Gytis&quot; make.names(vardas_ir_kreipinys) # paverčia į leistinus „R“ objektų pavadinimus ## [1] &quot;ponas.Jonas&quot; &quot;panelė.Ona&quot; &quot;ponaitis.Gytis&quot; Kitus duomenų tipus galime paversti į tekstą naudodami as.character(), norimu pavidalu suformatuodami skaičius (žr. „7.5.5 Skaičių formatavimas“) ar kitaip sudarydami teksto eilutes. Įprastai į tekstą paverstus duomenis galima tvarkingiau pateikti lentelėse bei ataskaitose, nei, pvz., suapvalintus, bet nesuformatuotus skaičius. Visgi tekstiniams kintamiesiems statistinė analizė neatliekama. Prieš tai jie turi būti paversti į kategorinius. Kai kurios funkcijos tekstą automatiškai atpažįsta kaip faktorius (tik kategorijas gali išrikiuoti nelogiška tvarka). Kitais atvejais pakeitimą privalu atlikti „rankiniu būdu“ naudojant as.factor() ar analogiškas funkcijas (žr., „7.4.1 Faktorių kūrimas“). Praktinis patarimas: dirbdami prisiminkite, kad jei norite pakeisti/atnaujinti objekto reikšmes, reikia naudoti &lt;- arba =: raidės ## [1] &quot;Z&quot; &quot;J&quot; &quot;Y&quot; &quot;K&quot; (raidės &lt;- stringr::str_sort(raidės, locale = &quot;lt&quot;)) ## [1] &quot;Y&quot; &quot;J&quot; &quot;K&quot; &quot;Z&quot; (raidės &lt;- dplyr::recode(raidės, &quot;Y&quot; = &quot;i&quot;, &quot;K&quot; = &quot;25&quot;)) ## [1] &quot;i&quot; &quot;J&quot; &quot;25&quot; &quot;Z&quot; raidės &lt;- stringr::str_c(raidės, collapse = &quot; + &quot;) raidės ## [1] &quot;i + J + 25 + Z&quot; Užduotis 7.12 Duota seka vardai_2 &lt;- c(&quot;G&quot;, &quot;J&quot;, &quot;G&quot;, &quot;A&quot;, &quot;Y&quot;, &quot;G&quot;). Tai pirmosios vardų „Gytis“, „Jonas“ ir „Aistis“ raidės. Atlikite užduotis: atsakymai, kurių tikimasi, pateikti žemiau. Išrikiuokite raides pagal lietuvių kalbos abėcėlę. Pašalinkite raidę „Y“. Perkoduokite į vardus. Suskaičiuokite, kokio ilgio kiekvienas vardas. Prieš kiekvieną vardą pridėkite „p. “. Kiekvieną pirmąją raidę paverskite į didžiąją. Visus vardus (su prierašu „p. “) atskyrę kableliais sujunkite į vieną eilutę. Suskaičiuokite, kokio ilgio galutinė eilutė. Atsakymai pasitikrinimui: ## [1] &quot;A&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;Y&quot; &quot;J&quot; ## [1] &quot;A&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;J&quot; ## [1] &quot;Aistis&quot; &quot;Gytis&quot; &quot;Gytis&quot; &quot;Gytis&quot; &quot;Jonas&quot; ## [1] 6 5 5 5 5 ## [1] &quot;p. Aistis&quot; &quot;p. Gytis&quot; &quot;p. Gytis&quot; &quot;p. Gytis&quot; &quot;p. Jonas&quot; ## [1] &quot;P. Aistis&quot; &quot;P. Gytis&quot; &quot;P. Gytis&quot; &quot;P. Gytis&quot; &quot;P. Jonas&quot; ## [1] &quot;P. Aistis, P. Gytis, P. Gytis, P. Gytis, P. Jonas&quot; ## [1] 49 7.4 Darbas su kategoriniais kintamaisiais Kategoriniai kintamieji (faktoriai) – tai iš anksto žinomą galimų skirtingų reikšmių (kategorijų) skaičių turintys kintamieji. Sutrumpintai žymimi fct. Darbui su faktoriais yra sukurtas specializuotas paketas forcats . Svarbiausios jo funkcijos prasideda užrašu fct_. 7.4.1 Faktorių kūrimas Faktoriai sukuriami naudojant funkciją factor(). fct_1 &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;, &quot;D&quot;)) fct_2 &lt;- factor(c(&quot;A&quot;, &quot;T&quot;, &quot;T&quot;, &quot;T&quot;, &quot;C&quot;, &quot;T&quot;)) miestai &lt;- c(&quot;Vilnius&quot;, &quot;Vilnius&quot;, &quot;Kaunas&quot;, &quot;Vilnius&quot;, &quot;Klaipėda&quot;, &quot;Kaunas&quot;, &quot;Alytus&quot;) (miestai_fct &lt;- factor(miestai)) ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Alytus Kaunas Klaipėda Vilnius Taip pat kategorinius kintamuosius galime gauti keisdami duomenų klasę funkcijomis as.factor() (kategorijas išrikiuoja abėcėliškai), forcats::as_factor() (kategorijas išrikiuoja pagal jų eilės tvarką vektoriuje), factor() (kategorijas galime nurodyti patys naudodami levels = c(…)) ir panašias funkcijas. miestai &lt;- c(&quot;Vilnius&quot;, &quot;Vilnius&quot;, &quot;Kaunas&quot;, &quot;Vilnius&quot;, &quot;Klaipėda&quot;, &quot;Kaunas&quot;, &quot;Alytus&quot;) # Kategorijos išdėliojamos pagal abėcėlę. # Rezultatas skirsis priklausomai nuo nustatytos „R“ lokalės. as.factor(miestai) ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Alytus Kaunas Klaipėda Vilnius # Kategorijos išdėliojamos pagal eilės tvarką vektoriuje. # Pirma sutinkamas „Vilnius“, po to „Kaunas“ ir t.t. forcats::as_factor(miestai) ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Vilnius Kaunas Klaipėda Alytus # Kategorijos išdėliojamos nurodyta eilės tvarka. factor(miestai, levels = c(&quot;Kaunas&quot;, &quot;Alytus&quot;, &quot;Vilnius&quot;, &quot;Klaipėda&quot;)) ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Kaunas Alytus Vilnius Klaipėda Norint duomenis paversti į ranginius, naudojamos funkcijos ordered(), as.ordered() arba factor(..., ordered = TRUE): vietos &lt;- c(&quot;pirma&quot;, &quot;antra&quot;, &quot;trečia&quot;) as.ordered(vietos) # kategorijos išdėliotos neteisingai ## [1] pirma antra trečia ## Levels: antra &lt; pirma &lt; trečia ordered(vietos, levels = c(&quot;pirma&quot;, &quot;antra&quot;, &quot;trečia&quot;)) ## [1] pirma antra trečia ## Levels: pirma &lt; antra &lt; trečia factor(vietos, levels = c(&quot;pirma&quot;, &quot;antra&quot;, &quot;trečia&quot;), ordered = TRUE) ## [1] pirma antra trečia ## Levels: pirma &lt; antra &lt; trečia Ranginius duomenis versti į nominaliuosius naudojama funkcija factor(..., ordered = FALSE). Turint tekstinius kintamuosius, funkcija type.convert() tinkamą duomenų tipą bando atspėti automatiškai, tad ji taip pat gali duomenis paversti į nominaliuosius faktorius (kategorijos nebūtinai bus išrikiuotos logiška tvarka). type.convert(miestai) # Automatinis kintamojo tipo parinkimas → factor ## [1] Vilnius Vilnius Kaunas Vilnius Klaipėda Kaunas Alytus ## Levels: Alytus Kaunas Klaipėda Vilnius type.convert(skaiciai_chr_2) # Automatinis kintamojo tipo parinkimas → numeric ## [1] 20 5 10 150 12 1 Įvykdę automatinį duomenų tipo parinkimą būtinai patikrinkite, ar rezultatas yra toks, kokio tikėjotės. Naudodami funkciją cut() į kategorijas galime padalinti skaitinių kintamųjų reikšmes (apie tai bus rašoma skyriuje „7.5.4 Skaitinio kintamojo reikšmių kategorizavimas“). Užduotis 7.13 Duota duomenų eilutė budejimo_dienos &lt;- c(&quot;Pirmadienis&quot;, &quot;Antradienis&quot;, &quot;Ketvirtadienis&quot;, &quot;Sekmadienis&quot;). Paverskite ją į faktorių. Kategorijos turi būti išrikiuotos logiška tvarka. 7.4.2 Faktorių pertvarkymas ir analizė Toliau šio skyriaus pavyzdžiuose bus naudojami duomenys apie kates. Duomenų įkėlimo kodo suprasti nebūtina. Duomenų aprašymas: help(cats, package = &quot;MASS&quot;). lytis &lt;- dplyr::recode_factor(MASS::cats$Sex, &quot;M&quot; = &quot;Patinas&quot;, &quot;F&quot; = &quot;Patelė&quot;) kunas &lt;- cut(MASS::cats$Bwt, breaks = 3, labels = c(&quot;Smulkus&quot;, &quot;Vidutinis&quot;, &quot;Didelis&quot;), ordered_result = TRUE) sirdis &lt;- cut(MASS::cats$Hwt, breaks = 2, labels = c(&quot;Lengva&quot;, &quot;Sunki&quot;), ordered_result = TRUE) head(lytis) ## [1] Patelė Patelė Patelė Patelė Patelė Patelė ## Levels: Patinas Patelė head(kunas) ## [1] Smulkus Smulkus Smulkus Smulkus Smulkus Smulkus ## Levels: Smulkus &lt; Vidutinis &lt; Didelis head(sirdis) ## [1] Lengva Lengva Lengva Lengva Lengva Lengva ## Levels: Lengva &lt; Sunki Norint patikrinti ar kintamasis yra kategorinis, naudojama funkcija is.factor(), o is.ordered() tikrina, ar kategorijos turi eilės tvarką (t. y., ar kintamasis yra ranginis). Funkcija levels() išvardija kategorijas: levels(lytis) ## [1] &quot;Patinas&quot; &quot;Patelė&quot; levels(miestai_fct) ## [1] &quot;Alytus&quot; &quot;Kaunas&quot; &quot;Klaipėda&quot; &quot;Vilnius&quot; Funkcija summary() automatinę suvestinę atlieka pagal kintamojo tipą („R“ klasę). Kategoriniams kintamiesiems sudaro dažnių lentelę. summary(lytis) ## Patinas Patelė ## 97 47 summary(miestai_fct) ## Alytus Kaunas Klaipėda Vilnius ## 1 2 1 3 Dažnių lentelėms sudaryti naudojama funkcija table() arba ftable(). table(lytis) ## lytis ## Patinas Patelė ## 97 47 table(miestai_fct) ## miestai_fct ## Alytus Kaunas Klaipėda Vilnius ## 1 2 1 3 „R“ rezultatuose: miestai_fct – kintamojo pavadinimas (gali ir nebūti); Alytus Kaunas ... – reikšmių (grupių) pavadinimai; 1 2 1 3 – reikšmių pasikartojimo dažnis (grupių dydžiai). Funkciją table() galima naudoti ne tik faktoriams, bet ir kitų tipų kintamiesiems, kai norima sudaryti dažnių lentelę. Taip pat galima sudaryti kryžmines (kelių kintamųjų) dažnių lenteles, kurios rodo, kiek kartų pasikartoja kiekviena kelių kintamųjų reikšmių kombinacija. dazn_lentele &lt;- table(lytis, kunas) dazn_lentele ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 31 42 24 ## Patelė 39 8 0 „R“ rezultatuose matome, kad, pvz., kombinacija „Patinas“ ir „Smulkus“ pasikartoja 31 kartą, o „Patelė“ ir „Didelis“ – apskritai nepasitaikė. Funkcija addmargins() prideda eilučių ir stulpelių sumas addmargins(dazn_lentele) ## kunas ## lytis Smulkus Vidutinis Didelis Sum ## Patinas 31 42 24 97 ## Patelė 39 8 0 47 ## Sum 70 50 24 144 addmargins(dazn_lentele, margin = 1) # tik eilutėms ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 31 42 24 ## Patelė 39 8 0 ## Sum 70 50 24 addmargins(dazn_lentele, margin = 2) # tik stulpeliams ## kunas ## lytis Smulkus Vidutinis Didelis Sum ## Patinas 31 42 24 97 ## Patelė 39 8 0 47 ES taisyklė: pirma (1) – eilutės; antra (2) – stulpeliai. Funkcija prop.table() apskaičiuoja procentines dalis: bendrąją dalį, dalį pagal eilutes arba dalį pagal stulpelius. prop.table(dazn_lentele) # bendra suma lygi 1 ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 0.21527778 0.29166667 0.16666667 ## Patelė 0.27083333 0.05555556 0.00000000 prop.table(dazn_lentele, margin = 1) # eilučių suma lygi 1 ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 0.3195876 0.4329897 0.2474227 ## Patelė 0.8297872 0.1702128 0.0000000 prop.table(dazn_lentele, margin = 2) # stulpelių suma lygi 1 ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 0.4428571 0.8400000 1.0000000 ## Patelė 0.5571429 0.1600000 0.0000000 Kiekvienam lentelės elementui galima atlikti matematinius veiksmus (plačiau apie skaičiavimus skyriuje „7.5.2 R kaip kalkuliatorius“): (rez_1 &lt;- 100 * prop.table(dazn_lentele)) ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 21.527778 29.166667 16.666667 ## Patelė 27.083333 5.555556 0.000000 round(rez_1, digits = 1) ## kunas ## lytis Smulkus Vidutinis Didelis ## Patinas 21.5 29.2 16.7 ## Patelė 27.1 5.6 0.0 Dar vienas būdas sudaryti dažnių lentelę – funkcija ftable(). Ji patogesnė tada, kai turime daugiau nei 2 kategorinius kintamuosius. table(lytis, sirdis, kunas) ## , , kunas = Smulkus ## ## sirdis ## lytis Lengva Sunki ## Patinas 31 0 ## Patelė 39 0 ## ## , , kunas = Vidutinis ## ## sirdis ## lytis Lengva Sunki ## Patinas 37 5 ## Patelė 8 0 ## ## , , kunas = Didelis ## ## sirdis ## lytis Lengva Sunki ## Patinas 11 13 ## Patelė 0 0 ftable(lytis, sirdis, kunas) ## kunas Smulkus Vidutinis Didelis ## lytis sirdis ## Patinas Lengva 31 37 11 ## Sunki 0 5 13 ## Patelė Lengva 39 8 0 ## Sunki 0 0 0 Automatinę grafinę suvestinę atlieka funkcija plot() – nubraižo stulpelinę diagramą: plot(lytis) Arba: ggplot2::qplot(lytis) Y ašyje atidedamas reikšmių pasikartojimo dažnumas (grupės narių skaičius). Norėdami sujungti kelis kategorinius kintamuosius (ir jų kategorijas), naudojame forcats::fct_c(). fct_3 &lt;- forcats::fct_c(fct_1, fct_2) fct_3 ## [1] A A D C C D A T T T C T ## Levels: A C D T Nebenaudojamas kategorijas galime pašalinti naudodami droplevels() arba forcats::fct_drop(): # Didelių patelių kūnų nėra, bet kategorija liko. # Ji bus atvaizduojama tiek grafikuose, tiek lentelėse. kates_kunas &lt;- kunas[lytis == &quot;Patelė&quot;] levels(kates_kunas) ## [1] &quot;Smulkus&quot; &quot;Vidutinis&quot; &quot;Didelis&quot; # Pašalinama nebenaudojama kategorija. kates_kunas_drop &lt;- forcats::fct_drop(kates_kunas) levels(kates_kunas_drop) ## [1] &quot;Smulkus&quot; &quot;Vidutinis&quot; table(kates_kunas) ## kates_kunas ## Smulkus Vidutinis Didelis ## 39 8 0 table(kates_kunas_drop) ## kates_kunas_drop ## Smulkus Vidutinis ## 39 8 plot(kates_kunas) plot(kates_kunas_drop) Funkcija dplyr::recode_factor() skirta perkoduoti kategorinio kintamojo reikšmes. Kaip ir dplyr::recode(), veikia pagal šabloną senoji_reikšmė = naujoji_reikšmė. Skirtumas toks, kad perkoduojamų reikšmių eiliškumas nurodo naujųjų kategorijų eiliškumą. Reikšmių eiliškumas išlieka tas pats, tik grafikuose ir lentelėse kategorijos bus atvaizduojamos kitokia tvarka. dplyr::recode_factor(fct_1, &quot;A&quot; = &quot;Arklas&quot;, &quot;D&quot; = &quot;Deimantas&quot;) ## [1] Arklas Arklas Deimantas C C Deimantas ## Levels: Arklas Deimantas C dplyr::recode_factor(fct_1, &quot;D&quot; = &quot;Deimantas&quot;, &quot;A&quot; = &quot;Arklas&quot;) ## [1] Arklas Arklas Deimantas C C Deimantas ## Levels: Deimantas Arklas C Užduotis 7.14 Paskutinio pavyzdžio kategorijų perkodavimo procedūrą papildykite raidę „C“ perkoduodami į žodį „Citrina“ (t. y., parašykite kodą, kuris perkoduoja visas tris raides į pilnus žodžius). Rezultatus atvaizduokite grafiškai ir dažnių lentele. Kodas geliu_rusys &lt;- iris$Species sugeneruos duomenų seką geliu_rusys. Kodo suprasti nereikia, bet konsolėje parašę kodą ?iris, „Help“ lange rasite pradinių duomenų aprašymą. Užduotis – ištirti seką geliu_rusys (kiekvienam punktui parašykite kodą): Kokia duomenų „R“ klasė? Kokį statistinį duomenų tipą atitinka šie duomenys? Kiek reikšmių iš viso? (Koks imties dydis?) Kiek yra skirtingų reikšmių? Kokie jų pavadinimai? Sudarykite dažnių lentelę. Duomenis atvaizduokite grafiškai. Įvardinkite, kaip vadinasi diagrama. Kodas pasaras &lt;- chickwts$feed sugeneruos duomenų seką pasaras. Pradinių duomenų aprašymas: ?chickwts. Ištirkite seką pasaras taip, kaip darėte duomenims geliu_rusys. 7.5 Darbas su skaitiniais kintamaisiais Programoje „R“ skaičiai visada užrašomi angliškai. Tai reiškia, kad tarp sveikosios ir dešimtosios dalies dedamas taškas (nors lietuviškai sakome „kablelis“). Jei sveikąją dalį sudaro tik nulis, jo galime nerašyti. O kablelis naudojamas atskirti kelias skirtingas reikšmes (t. y., kelis skaičius, o ne skaitmenis), kaip matėte ankstesniuose pavyzdžiuose. x &lt;- c(1.2, .6, .2200, 3.31) x ## [1] 1.20 0.60 0.22 3.31 Taip pat „R“ turi kelias matematines konstantas, kurios gali būti panaudotos skaičiavimuose 7.2. Lentelė 7.2: Matematinės konstantos Konstanta Reikšmė Pastaba pi skaičius \\(\\pi = 3.14159...\\) exp(1) skaičius \\(e = 2.71828...\\) Atitinka išraišką \\(e^1\\). 7.5.1 Skaičių sekų kūrimas Įprastai reikšmių sekos kuriamos naudojant operatorių c(). Tačiau dirbant su skaitiniais duomenimis yra specializuotų būdų skaičių sekoms kurti. Operatorius : Naudojant vieno dvitaškio operatorių : sukuriama seka nuo:iki kas 1. Pvz., sukuria didėjančių skaičių seką nuo 3 iki 21 kas 1: 3:21 ## [1] 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Ar mažėjančių skaičių seką nuo 3 iki -11 kas 1: 3:-11 ## [1] 3 2 1 0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 Užduotis 7.15 Naudodami : operatorių: Sukurkite seką a nuo 20 iki 200 kas 1 ir ją atspausdinkite. Sukurkite seką b nuo 0,3 iki -6,6 kas 1 ir ją atspausdinkite. Abi sekas sudėkite ir rezultatą pavadinkite c. Kokį įspėjimą parašo „R“? Funkcija seq() Jei nepakanka operatoriaus :, galime naudoti funkciją seq() (nuo angliško žodžio sequence). Jos argumentai yra: from – (nuo) pirmoji reikšmė, to – (iki) paskutinė galima reikšmė, jei ji įeina į seką. Bei vienas iš: by – (kas) sekos reikšmių keitimosi žingsnis, length.out – bendras sekos ilgis, along.width – kitas vektorius: šio ir naujojo vektorių ilgiai bus vienodi. Pvz., seka nuo 1 iki 27 kas 5 (reikšmė 27 neįtraukta): seq(from = 1, to = 27, by = 5) ## [1] 1 6 11 16 21 26 Seka nuo 1 iki 21, kurią sudaro 4 elementai (atstumai tarp reikšmių vienodi): seq(from = 1, to = 21, length.out = 4) ## [1] 1.000000 7.666667 14.333333 21.000000 Seka nuo 1 iki 20, kurią sudaro tiek pat elementų, kiek yra sekoje 2:7: seka_a &lt;- 2:7 seq(from = 1, to = 20, along.with = seka_a) ## [1] 1.0 4.8 8.6 12.4 16.2 20.0 Taip pat dažnai naudojama funkcija seq_along(), kuri išvardija vektoriaus elementų eilės numerius. T. y., sukuria seką nuo 1 iki length(x), jei turime objektą x. Pvz.: seq_along(seka_a) ## [1] 1 2 3 4 5 6 Toks funkcionalumas naudojamas braižant grafikus, kuriant for ciklus (apie juos kol kas plačiau nesimokysime), ar kitais atvejais, kai reikia vienodo ilgio sekų. Užduotis 7.16 Sukurkite sekas: seka_s1: nuo 2 iki \\(\\pi\\) kas 0,2; seka_s2: nuo \\(e\\) iki \\(\\pi\\), kurioje yra 10 reikšmių; seka_s3, kurioje išvardinti seka_s2 elementų eilės numeriai. Atsakymai: ## [1] 2.0 2.2 2.4 2.6 2.8 3.0 ## [1] 2.718282 2.765316 2.812351 2.859385 2.906420 2.953455 3.000489 ## [8] 3.047524 3.094558 3.141593 ## [1] 1 2 3 4 5 6 7 8 9 10 Atsitiktinės sekos iš galimų reikšmių aibės Jei norime pasirinkti atsitiktinių skaičių seką iš žinomos reikšmių aibės, naudojame funkciją sample() (angl. sample – imties sudarymas). Svarbiausi funkcijos parametrai: x – galimų reikšmių vektorius; size – būsimos imties (vektoriaus) dydis; replace (loginė reikšmė) – jei TRUE, tada ta pati reikšmė gali būti ištraukta kelis kartus (grąžintinis imties sudarymo būdas). Jei FALSE – kiekviena reikšmė gali būti pasirinkta ne daugiau kaip vieną kartą (negrąžintinis imties sudarymas). prob – kiekvienos x reikšmės pasirinkimo tikimybė. Jei nenurodyta, tada tikimybės yra lygios. set.seed(1) # Apie šią funkciją - kitame skyriuje galimos_reikšmės &lt;- c(1, 5, 7) sample(galimos_reikšmės) ## [1] 1 7 5 sample(galimos_reikšmės, size = 1) ## [1] 7 sample(galimos_reikšmės, size = 20, replace = TRUE) ## [1] 1 7 7 5 5 1 1 1 7 5 7 5 7 7 5 7 7 1 5 1 Užduotis 7.17 Sudarykite sveikųjų skaičių seką nuo 1 iki 10 ir pavadinkite seka_int_1. Sekos seka_int_1 narius išdėliokite atsitiktine tvarka. Atsitiktiniu negrąžintiniu būdu iš sekos seka_int_1 paimkite 5 reikšmes. Ar paimtosios reikšmės gali būti vienodos? Atsitiktiniu grąžintiniu būdu iš sekos seka_int_1 paimkite 25 reikšmes. Ar paimtosios reikšmės gali būti vienodos? Ar pakartojus ketvirto punkto eksperimentą kiekvieną kartą bus gautas toks pats atsakymas? Atsitiktinių skaičių sekos: statistiniai dėsniai Atsitiktinių skaičių sekų, kurių nariai skirstosi pagal įvairius statistinius dėsnius, kūrimui naudojamos funkcijos, prasidedančios raide r (ang. random), po kurios eina sutrumpintas dėsnio pavadinimas, toks kaip norm – normalusis, arba Gauso, dėsnis, pois – Puasono (prancūzų mokslininko pavardė Poisson), unif tolygusis (angl. uniform) ir kiti. Kiekvienam iš šių dėsnių būdingi tam tikri parametrai. Pvz., rnorm(10, mean = 1, sd = 0.2) sukurs atsitiktinę seką iš 10 skaičių, paimtų iš generalinės aibės, pasiskirsčiusios pagal normalųjį skirstinį, kurio vidurkis (angl. mean) lygus 1, o standartinis nuokrypis (sd angl. standard deviation) – 0,2: rnorm(10, mean = 1, sd = 0.2) ## [1] 1.1667466 0.9447904 0.9289996 1.0174975 1.4504511 1.1668920 1.2624831 ## [8] 1.5005291 1.2336463 0.9147669 Funkcija rpois(6, lambda = 3) sukurs atsitiktinę seką iš 6 skaičių, paimtų iš pagal Puasono (Poisson) skirstinį, kurio parametras \\(\\lambda = 3\\), pasiskirsčiusios aibės. Funkcija runif(5, min = 2, max = 14) sukurs seką, paimtą iš generalinės aibės, kurios reikšmės pasiskirsčiusios tolygiai intervale nuo 2 iki 14: runif(5, min = 2, max = 14) ## [1] 3.915123 2.967743 3.591804 4.062865 7.733334 Plačiau šiuos dėsnius nagrinėsime temoje apie tikimybes. Atkreipkite dėmesį, kad tolydusis ir tolygusis (skirstinys) yra du skirtingi terminai. Užduotis 7.18 Simuliuokite eksperimentą, kurio metu paimama 9 narių imtis iš pagal normalųjį skirstinį pasiskirsčiusios generalinės aibės su parametrais \\(\\mu\\) = 1.82 (vidurkis) ir \\(\\sigma\\) = 0.18 (standartinis nuokrypis). Atkartojamas atsitiktinumas Visgi dirbant kompiuteriu reikia žinoti, kad kompiuteryje atsitiktinumas nėra tikras. Jis yra simuliuojamas algoritmais, kuriais sugeneruotų reikšmių pasikartojimo periodas yra labai didelis, tarkim \\(2^{19937}-1\\). Daugeliui praktinių problemų spręsti to pakanka. Algoritmo rezultatas priklauso nuo pradinių sąlygų. Šias pradines sąlygas nustato funkcija set.seed(), kurios skliaustuose nurodomas teigiamas arba neigiamas sveikasis skaičius. Kiekvieną kartą prieš atsitiktinių skaičių kūrimą naudojant šią funkciją gaunami vienodi rezultatai. Todėl „atsitiktinai“ sugeneruoti skaičiai iš tiesų yra pseudoatsitiktiniai. rnorm(10) # Variantas A ## [1] -0.96193342 -0.29252572 0.25878822 -1.15213189 0.19578283 ## [6] 0.03012394 0.08541773 1.11661021 -1.21885742 1.26736872 rnorm(10) # Variantas B ## [1] -0.7447816 -1.1312186 -0.7163585 0.2526524 0.1520457 -0.3076564 ## [7] -0.9530173 -0.6482428 1.2243136 0.1998116 set.seed(201809) rnorm(10) # Variantas C ## [1] 0.9991890 -1.2069877 0.5160472 0.4601108 -0.5160344 0.2357106 ## [7] -0.6072210 -0.7666150 1.0941386 0.7102374 set.seed(201809) rnorm(10) # Variantas D identiškas variantui C ## [1] 0.9991890 -1.2069877 0.5160472 0.4601108 -0.5160344 0.2357106 ## [7] -0.6072210 -0.7666150 1.0941386 0.7102374 set.seed(201809) rnorm(10) # Variantas E identiškas variantui C ## [1] 0.9991890 -1.2069877 0.5160472 0.4601108 -0.5160344 0.2357106 ## [7] -0.6072210 -0.7666150 1.0941386 0.7102374 Kaip matote, trys paskutinės sekos yra identiškos, nes naudotos tos pačios pradinės sąlygos. Prieš atliekant analizę, programos kodo pradžioje rekomenduojama nurodyti pradines pseudoatsitiktinių skaičių generatoriaus vertes. Taip kelis kartus vykdant tą pačią analizę bus gaunami identiški rezultatai, jei analizės metu naudojami atsitiktinumą simuliuojantys analizės metodai. Užduotis 7.19 Simuliuokite eksperimentą, kurio metu iš tolygiojo skirstinio (mažiausia reikšmė -100, didžiausia – 100) sudaroma 65 narių imtis. Kodą parašykite taip, kad ir jūsų, ir kolegos kompiuteryje būtų gauti identiški rezultatai. 7.5.2 R kaip kalkuliatorius Programoje „R“ matematinius (ir kitokius) veiksmus atlieka simboliai, vadinami operatoriais (pvz., lentelėje 7.3), arba komandos, vadinamos funkcijomis (pvz., lentelėse 7.4, 7.5). Taip pat galima panaudoti ir konstantas, tokias kaip skaičius \\(\\pi\\) (lentelė 7.2). „R“ operatoriai – tai funkcijos, užrašomos ne žodžiais, o specialiaisiais simboliais, tokiais kaip +, &lt;-, == ar %&gt;%. Lentelė 7.3: Matematinius veiksmus atliekantys „R“ operatoriai Simbolis (operatorius) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas + Sudėtis 5 + 8 13 - Atimtis 5 - 7 -2 * Daugyba 3 * 4 12 / Dalyba 6 / 3 2 ^ Kėlimas laipsniu 3^2 9 ** Kėlimas laipsniu 3**2 9 %/% Sveikoji dalis (po dalybos) 7 %/% 3 2 %% Liekana (po dalybos) 7 %% 3 1 Veiksmai atliekami eilės tvarka, panašiai, kaip matematikoje: pirma veiksmai skliausteliuose; tada kėlimas laipsniu; tada daugyba, dalyba; tada sudėtis, atimtis. 2 * 3^2 # 2 * 9 ## [1] 18 (3 + 6)^2 - 9/3 # 9^2 - 3 ## [1] 78 21 %/% 2^2 # 21 %/% 4 ## [1] 5 Jei nesate tikri, kokia tvarka bus atlikti veiksmai – naudokite papildomus skliaustus. Tada tikrai bus aišku: (5 %/% 2)^2 ## [1] 4 5 %/% (2^2) ## [1] 1 Jei yra pradžios skliaustai (, būtinai turi būti ir pabaigos skliaustai ). Lentelė 7.4: „R“ komandos, atliekančios dažnas matematines operacijas Funkcija (komanda) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas sqrt() Kvadratinė šaknis sqrt(4) 2 abs() Modulis (absoliučioji vertė) abs(-2) 2 sin(), cos(), tan(), Trigonometrinės funkcijos (skliaustuose radianai; daugiau informacijos suvedus komandą ?Trig). sin(pi/6) 0.5 exp() Eksponentė \\((e^x)\\) exp(0) 1 log(), log2(), log10() Natūrinis \\((\\ln{x})\\), dvejetainis \\((\\log_2{x})\\) ir dešimtainis \\((\\lg{x})\\) logaritmai. log10(100) 2 factorial() Faktorialas \\((4! = 4\\cdot3\\cdot2\\cdot1)\\) factorial(4) 24 choose() Binominis koeficientas \\(C^k_n\\).Taip pat žymimas \\(\\binom{n}{k} = {n! \\over k!(n-k)!}\\). choose(n = 5, k = 2) 10 Lentelė 7.5: „R“ komandos, atliekančios apvalinimą. Funkcija (komanda) Atliekamas veiksmas (operacija) Pavyzdys Pavyzdžio atsakymas round() Įprastinis apvalinimas (iki n skaičių po kablelio) round(8.275, digits = 2) 8.28 round(-8.275, digits = 2) -8.28 signif() Įprastinis apvalinimas (iki n reikšmingų skaičių) signif(8.275, digits = 2) 8.3 signif(0.0275, digits = 2) 0.028 ceiling() Apvalinimas¹ į didesnę pusę ceiling(8.275) 9 ceiling(-8.275) -8 floor() Apvalinimas¹ į mažesnę pusę floor(8.975) 8 floor(-8.975) -9 trunc() Apvalinimas¹ į nulio pusę trunc(9.99) 9 trunc(-9.99) -9 ¹Apvalinimas iki artimiausio sveikojo skaičiaus. Pavyzdžiai Komandų, atliekančių matematinius veiksmus, naudojimo pavyzdžiai. sqrt(125) ## [1] 11.18034 abs(-4) ## [1] 4 cos(4 * pi) ## [1] 1 exp(2) # Skaičius e pakeltas kvadratu ## [1] 7.389056 log(2.718282) # logaritmas pagrindu e ## [1] 1 factorial(6) # 6! ## [1] 720 choose(52, 5) # skaičiuojama 52!/(47! × 5!) ## [1] 2598960 arba choose(n = 52, k = 5) # nurodyti argumentai suteikia aiškumo ## [1] 2598960 Užduotis 7.20 Naudodamiesi „R“ parašykite ir apskaičiuokite šias išraiškas: \\((2+3.3)^7 + \\ln{6} + cos(\\pi\\sqrt{2})\\); \\(|2^5 - 3^4|\\); \\(e^{\\left(-\\frac{1}{2}\\right)}\\); \\(e^e\\); \\(\\pi r\\ ^2\\), kai \\(r = 2.5\\); Konstantą \\(\\pi\\) suapvalinkite: iki 3 skaičių po kablelio; iki 5 reikšmingų skaitmenų. 7.5.3 Skaitinių kintamųjų suvestinės Skaitines suvestines galima skaičiuoti automatiškai („greituoju būdu“) arba išreikštai nurodant norimą funkciją. Pavyzdžiuose bus naudojamas vektorius x. Kai tirsite savo duomenis, naudokite savojo vektoriaus pavadinimą. set.seed(951753) x &lt;- round(rnorm(30), digits = 1) # suapvalinta iki 1 skaičiaus po kablelio. Automatines suvestines atlieka funkcija summary(x). Skaitiniams kintamiesiems tai mažiausia reikšmė, 1 kvartilis, mediana, vidurkis, 3 kvartilis ir didžiausia reikšmė. Jei yra trūkstamų reikšmių, nurodomas jų skaičius. summary(x) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -2.200 -0.875 -0.100 -0.090 0.575 2.400 Vietoje x reikia įrašyti kintamojo pavadinimą: Duomenų centras: mean(x) – vidurkis; mean(x, trim = .10) – 10% nupjautinis vidurkis. Skaičių trim galima keisti nuo 0 iki 0.5, tai atitinka nuo 0% iki 50% nupjautinį vidurkį; median(x) – mediana; DescTools::Hmean(x) – harmoninis vidurkis; DescTools::Gmean(x) – geometrinis vidurkis. Sklaida: sd(x) – standartinis nuokrypis; var(x) – dispersija; IQR(x) – IQR, tarpkvartilinis plotis, arba kvartilių skirtumas (angl. interquartile range); mad(x) – MAD, absoliučiojo nuokrypio nuo medianos mediana, padauginta iš 1,4826 (angl. median absolute deviation). Kitos padėties statistikos: min(x) – mažiausia reikšmė; max(x) – didžiausia reikšmė; quantile(x, probs = 0.25), quantile(x, probs = 0.75) – 25% ir 75% procentiliai. Skaičių probs galima keisti nuo 0 iki 1. Pozicija: dplyr::first(x) – pirmoji reikšmė pagal eilę; dplyr::last(x) – paskutinė reikšmė pagal eilę; dplyr::nth(x, n = 2) – n-toji reikšmė pagal eilę (šiuo atveju – antroji reikšmė). Skaičius, dydis: sum(x) – visų reikšmių suma (atitinka matematinį užrašą \\(\\sum x_i\\)); length(x) – imties arba grupės dydis; dplyr::n_distinct(x) arba length(unique(x)) – unikalių (nepasikartojančių) reikšmių skaičius; sum(is.na(x)) – trūkstamų reikšmių skaičius; sum(!is.na(x)) – netrūkstamų reikšmių skaičius. Skirstinio forma: DescTools::Kurt(x) – eksceso koeficientas (angl., excess kurtosis). Parametras method (galimos reikšmės yra 1, 2, 3) kontroliuoja, kuris eksceso skaičiavimo metodas naudojamas; DescTools::Skew() – asimetrijos koeficientas (angl., skewness). Parametras method (galimos reikšmės yra 1, 2, 3) kontroliuoja, kuris asimetrijos koeficiento skaičiavimo metodas naudojamas. Pvz.: median(x) ## [1] -0.1 DescTools::Kurt(x) ## [1] -0.7198677 quantile(x, probs = 0.25) ## 25% ## -0.875 min(x) ## [1] -2.2 Jei duomenyse yra trūkstamų reikšmių, tada daugumos iš šių funkcijų atsakymas bus NA. x_na &lt;- x x_na[25] &lt;- NA x_na ## [1] -1.9 -1.7 2.4 0.0 2.0 -0.1 -1.5 -0.8 -2.2 0.6 0.0 -0.3 -0.9 -0.3 ## [15] -0.1 -0.1 0.5 1.9 -0.9 0.0 -0.8 1.4 -0.1 0.3 NA 1.0 -1.8 -1.1 ## [29] 1.4 -0.6 mean(x_na) ## [1] NA Tokiu atveju įprastai galima nurodyti parametrą na.rm = TRUE. Taip bus daromos suvestinės prieš tai pašalinus trūkstamas reikšmes. mean(x_na, na.rm = TRUE) ## [1] -0.1275862 Alternatyva, jei funkcija neturi parametro na.rm – papildomai naudoti funkciją na.omit(): mean(na.omit(x_na)) ## [1] -0.1275862 Arba x_be_na &lt;- na.omit(x_na) sd(x_be_na) ## [1] 1.195795 „Greitam“ grafiniam atvaizdavimui galime naudoti šias funkcijas: hist(x) plot(density(x)) boxplot(x) ggplot2::qplot(x = x, geom = &quot;histogram&quot;, bins = 5, # bins - stulpelių skaičius xlab = &quot;Pavadinimas X&quot;, ylab = &quot;Pavadinimas Y&quot;, color = I(&quot;black&quot;)) ggplot2::qplot(x = x, geom = &quot;density&quot;, adjust = 1) # adjust - glotninimo parametro daugiklis ggplot2::qplot(y = x, geom = &quot;boxplot&quot;) Išsamiau apie grafikus mokysimės atskiro užsiėmimo metu. Užduotis 7.21 Šio skyriaus pavyzdžiuose sukurtai duomenų eilutei x apskaičiuokite visas poskyryje nurodytas aprašomąsias statistikas. Įvertinkite: duomenų centro padėtį; sklaidą; simetriją; išskirčių buvimą/nebuvimą. Sukurkite duomenų eilutę y &lt;- rexp(30) (pagal eksponentinį dėsnį pasiskirstę duomenys). Apskaičiuokite poskyryje nurodytas aprašomąsias statistikas bei atvaizduokite grafiškai. Įvertinkite: duomenų centro padėtį; sklaidą; simetriją; išskirčių buvimą/nebuvimą. Apskaičiuokite, koks imties set.seed(12); x_3 &lt;- rnorm(30) standartinis nuokrypis, kuris skaičiuojamas pagal formulę: \\[s_x = \\sqrt{\\frac{\\sum^n_{i=1}(x_i-\\overline{x})^2}{n-1}}\\] Funkcijų sd() bei var() naudoti negalima. Funkcija set.seed(12) nustato pradines sąlygas kompiuterio pseudoatsitiktinių skaičių generatoriui, todėl kiekvieno iš mūsų skaičiavimuose sugeneruojama ta pati skaičių seka (gaunami atkartojami rezultatai, o tai šiuolaikinėje duomenų analizėje labai svarbu). Apskaičiuokite, koks imties set.seed(12); x_4 &lt;- rnorm(30) medianinis absoliutusis nuokrypis nuo medianos, kuris skaičiuojamas pagal formulę: \\[mad_x = 1.4826 \\cdot median( |x_i - median(x)|)\\] Funkcijos mad() naudoti negalima; Sakykime, kad set.seed(-121258); x_5 &lt;- rnorm(1e5) yra visa mūsų tiriama generalinė aibė (GA). Apskaičiuokite jai GA eksceso koeficientą (angl. excess kurtosis) pagal formulę: \\[ekscesas = N \\cdot \\frac{\\sum^N_{i=1}{(x_i - \\overline{x}})^4}{\\left(\\sum^N_{i=1}{(x_i - \\overline{x}})^2\\right)^2} - 3\\] kur \\(N\\) – GA dydis, \\(\\overline{x}\\) – GA vidurkis. Formulė gali būti išskaidyta į kelias eilutes. 7.5.4 Skaitinio kintamojo reikšmių kategorizavimas Kartais skaitinio kintamojo reikšmes, pvz., amžių, reikia suskirstyti į kategorijas „jaunas“, „vidutinio amžiaus“, „pagyvenęs“. Tam naudinga funkcija cut(). set.seed(654852) amžius &lt;- sample(1:80, size = 100, replace = TRUE) summary(amžius) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 23.50 40.50 41.22 61.50 80.00 Funkcijoje nurodomos ribos, kaip „supjaustyti“ kintamojo reikšmes. Kiekvienam pogrupiui galime suteikti pavadinimus. amžiaus_gr &lt;- cut(amžius, breaks = c(0, 30, 60, 100), # intervalų ribos labels = c(&quot;jaunas&quot;, &quot;suaugęs&quot;, &quot;pagyvenęs&quot;)) summary(amžiaus_gr) ## jaunas suaugęs pagyvenęs ## 35 38 27 Jei mažiausios ar didžiausios galimos reikšmės nežinome, galime nurodyti -Inf arba Inf Neturint rimto pagrindo tolydžiuosius dydžius kategorizuoti ir analizuoti kaip kategorinius yra nekorektiška. amžiaus_gr_2 &lt;- cut(amžius, breaks = c(-Inf, 30, 60, Inf), # intervalų ribos labels = c(&quot;jaunas&quot;, &quot;suaugęs&quot;, &quot;pagyvenęs&quot;)) summary(amžiaus_gr_2) ## jaunas suaugęs pagyvenęs ## 35 38 27 Jei reikšmes norite suskirstyti į kelias pagal intervalo plotį lygias grupes, parametrui breaks nurodykite vieną sveikąjį skaičių: amžiaus_gr_3 &lt;- cut(amžius, breaks = 4) # intervalų skaičius summary(amžiaus_gr_3) ## (0.921,20.8] (20.8,40.5] (40.5,60.2] (60.2,80.1] ## 22 28 23 27 Matome, kad reikšmės pateiktos kaip vienodo pločio intervalai. Tik išorinių intervalų galai padidinti 0.1% tam, kad didžiausios ir mažiausios reikšmės patektų į intervalą. Plačiau apie funkciją rašoma dokumentacijoje: ?cut. Pastaba: neturint rimto pagrindo, tolydžiuosius dydžius kategorizuoti ir analizuoti kaip kategorinius kintamuosius yra nekorektiška, nes skirstant į kategorijas prarandama dalis informacijos. Pradinių duomenų reikšmių atstatyti iš kategorijų nebeįmanoma. seq(2, 80, length.out = 4) ## [1] 2 28 54 80 Užduotis 7.22 Sugeneruokite duomenis duom &lt;- rnorm(62, 180, 20). Reikšmes suskirstykite į grupes „didelis“ ir „mažas“. Pirmoje grupėje turi būti reikšmės didesnės už medianą, antroje – mažesnės. Tą pačią duomenų eilutę suskirstykite į 5 reikšmių grupes. Kokia duomenų „R“ klasė (duomenų tipas)? 7.5.5 Skaičių formatavimas Rengiant galutinę duomenų analizės ataskaitą įprastai norima, kad skaičiai būtų suapvalinti ir pateikti tvarkingai. Problema atliekant įprastinį apvalinimą – jei paskutinis skaičius yra nulis, įprastai „R“ jo nerodo. round(10.2, digits = 0) # Tikimės 10.0 ## [1] 10 Taip pat gali būti ir kitų aplinkybių, kada naudingos funkcijos, kurios skaičius suformatuoja ir paverčia į tvarkingai apipavidalintą tekstą. Priklausomai nuo situacijos, gali būti naudingos funkcijos, formatC(), prettyNum(), sprintf(), sringr::str_glue(), format() ar kitos. Apžvelgsime tik kelias. Funkcija format(). Keli svarbesni parametrai: digits – reikšmingų skaitmenų skaičius; nsmall – minimalus skaitmenų po kablelio skaičius; width – minimalus laukelio plotis (simbolių skaičius). decimal.mark – sveikosios ir dešimtosios dalies skirtukas (&quot;.&quot; arba &quot;,&quot;). set.seed(2015874) (pries_formatavima &lt;- rnorm(5)) ## [1] -0.1295767 -0.7823619 0.7726673 2.3148301 -0.4781434 pries_formatavima[3] &lt;- pries_formatavima[3] * 1000 format(pries_formatavima, digits = 1) ## [1] &quot; -0.1&quot; &quot; -0.8&quot; &quot;772.7&quot; &quot; 2.3&quot; &quot; -0.5&quot; format(pries_formatavima, digits = 1, width = 6) ## [1] &quot; -0.1&quot; &quot; -0.8&quot; &quot; 772.7&quot; &quot; 2.3&quot; &quot; -0.5&quot; format(pries_formatavima, digits = 3) ## [1] &quot; -0.130&quot; &quot; -0.782&quot; &quot;772.667&quot; &quot; 2.315&quot; &quot; -0.478&quot; format(pries_formatavima, digits = 1, decimal.mark = &quot;,&quot;) ## [1] &quot; -0,1&quot; &quot; -0,8&quot; &quot;772,7&quot; &quot; 2,3&quot; &quot; -0,5&quot; Peržvelkime formatC() galimybes. Svarbiausi funkcijos argumentai: width – minimalus laukelio plotis (simbolių skaičius). Jei reikia, rezultatas gali užimti ir daugiau ženklų, nei nurodyta. digits – skaitmenų po kablelio skaičius; format – skaičių formatas: &quot;f&quot; – fiksuotasis skaičių formatas: išlaikomas nurodytas skaitmenų po kablelio skaičius. &quot;e&quot; – inžinerinis skaičių formatas; &quot;g&quot; – formatas parenkamas pagal skaičiaus dydį. decimal.mark – sveikosios ir dešimtosios dalies skirtukas (&quot;.&quot; arba &quot;,&quot;). flag – formato modifikatoriaus žymė: &quot;0&quot; – jei yra tuščių vietų, prieš skaičių pridedami nuliai; &quot;-&quot; – lygiavimas ties kairiuoju kraštu; &quot;+&quot; – visada rodo skaičiaus ženklą (+ ar -); &quot; &quot; – jei pirmasis simbolis nėra ženklas (+ ar -), prideda tarpą prieš skaičių (taip išlaikomas lygiavimas). formatC(pries_formatavima, format = &quot;f&quot;, digits = 1) ## [1] &quot;-0.1&quot; &quot;-0.8&quot; &quot;772.7&quot; &quot;2.3&quot; &quot;-0.5&quot; formatC(pries_formatavima, format = &quot;f&quot;, digits = 2) ## [1] &quot;-0.13&quot; &quot;-0.78&quot; &quot;772.67&quot; &quot;2.31&quot; &quot;-0.48&quot; formatC(pries_formatavima, format = &quot;f&quot;, digits = 5) ## [1] &quot;-0.12958&quot; &quot;-0.78236&quot; &quot;772.66728&quot; &quot;2.31483&quot; &quot;-0.47814&quot; formatC(pries_formatavima, format = &quot;f&quot;, digits = 1, width = 10) ## [1] &quot; -0.1&quot; &quot; -0.8&quot; &quot; 772.7&quot; &quot; 2.3&quot; &quot; -0.5&quot; formatC(pries_formatavima, format = &quot;f&quot;, digits = 1, width = 10, flag = &quot;0&quot;) ## [1] &quot;-0000000.1&quot; &quot;-0000000.8&quot; &quot;00000772.7&quot; &quot;00000002.3&quot; &quot;-0000000.5&quot; formatC(pries_formatavima, format = &quot;f&quot;, digits = 1, width = 10, flag = &quot;-&quot;) ## [1] &quot;-0.1 &quot; &quot;-0.8 &quot; &quot;772.7 &quot; &quot;2.3 &quot; &quot;-0.5 &quot; formatC(pries_formatavima, format = &quot;f&quot;, digits = 1, width = 10, flag = &quot;+&quot;) ## [1] &quot; -0.1&quot; &quot; -0.8&quot; &quot; +772.7&quot; &quot; +2.3&quot; &quot; -0.5&quot; formatC(pries_formatavima, format = &quot;f&quot;, digits = 1, decimal.mark = &quot;,&quot;) ## [1] &quot;-0,1&quot; &quot;-0,8&quot; &quot;772,7&quot; &quot;2,3&quot; &quot;-0,5&quot; formatC(pries_formatavima, format = &quot;g&quot;, digits = 1) ## [1] &quot;-0.1&quot; &quot;-0.8&quot; &quot;8e+02&quot; &quot; 2&quot; &quot;-0.5&quot; formatC(pries_formatavima, format = &quot;e&quot;, digits = 1) ## [1] &quot;-1.3e-01&quot; &quot;-7.8e-01&quot; &quot;7.7e+02&quot; &quot;2.3e+00&quot; &quot;-4.8e-01&quot; formatC(pries_formatavima, format = &quot;e&quot;, digits = 1, flag = &quot; &quot;) ## [1] &quot;-1.3e-01&quot; &quot;-7.8e-01&quot; &quot; 7.7e+02&quot; &quot; 2.3e+00&quot; &quot;-4.8e-01&quot; Užduotis 7.23 (Užduotis dar nepateikta) 7.6 Darbas su loginiais kintamaisiais Loginiai kintamieji – tai „R“ duomenų tipas, kuris atsiranda atlikus palyginimo arba loginio patikrinimo operacijas, kai atsakymas būna TRUE (loginė reikšmė „taip“, „tiesa“) arba FALSE („ne“, „netiesa“). Trumpieji reikšmių variantai pademonstruoti lentelėje 7.1. Įprastai loginiai kintamieji trumpinami lgl. Susikurkime loginių reikšmių vektorių: lgl_seka &lt;- c(T, T, T, F, F, F, F, T, F, T, F, F) lgl_seka ## [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE ## [12] FALSE Kiek elementų iš viso? n &lt;- length(lgl_seka) n ## [1] 12 Norint statistiškai apdoroti pačias logines reikšmes, jos įprastai verčiamos į kategorinius kintamuosius, kaip tai daroma su tekstiniais kintamaisiais (žr. skyriuje „7.4.1 Faktorių kūrimas“). 7.6.1 Palyginimo operacijos Palyginimo operacijos, kurių rezultatas yra loginės reikšmės, pateiktos lentelėje 7.6. Lentelė 7.6: Palyginimą atliekantys „R“ operatoriai. TRUE yra loginė reikšmė „taip“, „tiesa“, FALSE – „ne“, „netiesa“. Operatorius Atliekamas palyginimas Pavyzdys Pavyzdžio atsakymas &lt; Ar mažiau 5 &lt; 8 TRUE &gt; Ar daugiau 5 &gt; 7 FALSE &lt;= Ar mažiau arba lygu 3 &lt;= 4 TRUE &gt;= Ar daugiau arba lygu 6 &gt;= 3 TRUE == Ar lygu 3 == 2 FALSE != Ar nelygu 3 != 2 TRUE %in% Ar tai vienas iš … &quot;C&quot; %in% c(&quot;G&quot;, &quot;M&quot;, &quot;C&quot;) TRUE Užduotis 7.24 7.6.2 Loginės operacijos Palyginimo operacijos rezultatą modifikuojantys operatoriai: ! – neiginys (loginė operacija „NE“): iš FALSE („ne“) padaro TRUE („taip“), iš TRUE → FALSE; !(amžius &lt; 22): „amžius nemažesnis už 22“. Operatoriai, skirti sujungti kelias palyginimo sąlygas: | – jungtukas „ARBA“ (loginė operacija „ARBA“): pvz., kai tikriname, ar diena ne darbo, jei nedirbame per šventes ir sekmadieniais; diena == &quot;šventinė&quot; | savaitės_diena == &quot;sekmadienis&quot;: „diena yra arba šventinė, arba savaitės diena yra sekmadienis“. &amp; – jungtukas „IR“ (loginė operacija „IR“): pvz., kai tikriname, ar tai vyras, jaunesnis nei 35 metai; lytis == &quot;vyras&quot; &amp; amžius &lt; 35: „ir vyras, ir jaunesnis nei 35“. Kitos sąlygų patikrinimui naudingos funkcijos: is.na() – tikrina, ar eilutėje esanti reikšmė yra praleista (NA): is.na(NA); !is.na() – tikrina, ar eilutėje esanti reikšmė nėra praleista: !is.na(NA); between(), t. y., dplyr::between(),– tikrina, ar skaičius yra tam tikrame intervale imtinai: between(10, left = 11, right = 20). Įvykdę komandas ?Comparison bei ??base::logic daugiau informacijos rasite „R“ dokumentacijoje. Užduotis 7.25 7.6.3 Loginiai kintamieji kaip skaičiai Vykdant analizę dažnai panaudojama tokia savybė – atliekant matematinius veiksmus, „R“ loginius kintamuosius automatiškai paverčia į skaičius: TRUE → 1; FALSE → 0. Todėl sum() apskaičiuoja, keli elementai, o mean() parodo, kuri dalis (skaičius nuo 0 iki 1) tenkina sąlygą (yra TRUE). sum(lgl_seka) # Sekoje yra 5 TRUE reikšmės ## [1] 5 mean(lgl_seka) # Sekoje yra 41,7% TRUE reikšmių ## [1] 0.4166667 Taikymo pavyzdžiai: Kiek kartų pasikartoja žodis „Vilnius“ ir kurią reikšmių dalį jis užima duomenų eilutėje? miestai &lt;- c(&quot;Vilnius&quot;, &quot;Vilnius&quot;, &quot;Kaunas&quot;, &quot;Vilnius&quot;, &quot;Klaipėda&quot;, &quot;Kaunas&quot;, &quot;Alytus&quot;) sum(miestai == &quot;Vilnius&quot;) ## [1] 3 mean(miestai == &quot;Vilnius&quot;) ## [1] 0.4285714 Kiek kartų pasikartoja žodžiai „Vilnius“ bei „Alytus“ ir kurią reikšmių dalį jie užima duomenų eilutėje? sum(miestai %in% c(&quot;Vilnius&quot;, &quot;Alytus&quot;)) ## [1] 4 mean(miestai %in% c(&quot;Vilnius&quot;, &quot;Alytus&quot;)) ## [1] 0.5714286 Kurią procentinę duomenų eilutės reikšmių dalį sudaro praleistos reikšmės? Atsakymą pateikti dešimtosios dalies tikslumu. eilute &lt;- c(1:3, NA, 1:14, NA, NA, NA, 22:25, NA, NA, 1:6, NA, NA, NA, NA) ar_trukstama &lt;- is.na(eilute) (ats1 &lt;- mean(ar_trukstama) * 100) # dalis procentais ## [1] 27.02703 # Pašalins paskutinius skaičius, jei jie yra nuliai (ats2a &lt;- round(ats1, digits = 1)) ## [1] 27 paste(&quot;Trūkstamų reikšmių dalis yra&quot;, ats2a, &quot;%.&quot;) ## [1] &quot;Trūkstamų reikšmių dalis yra 27 %.&quot; # Paliks paskutinius skaičius, net jei jie yra nuliai (ats2b &lt;- formatC(ats1, digits = 1, format = &quot;f&quot;)) ## [1] &quot;27.0&quot; paste(&quot;Trūkstamų reikšmių dalis yra&quot;, ats2b, &quot;%.&quot;) ## [1] &quot;Trūkstamų reikšmių dalis yra 27.0 %.&quot; Užduotis 7.26 Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["teorija-grafikai.html", "8. Grafikai (teorija) 8.1 Grafikai vieno kintamojo apibendrinimui 8.2 Diagramų palyginimas Klausimai ir komentarai", " 8. Grafikai (teorija) Šioje dalyje pateikta teorinė medžiaga apie dažnai statistinėms suvestinėms atlikti naudojamus grafikus. Peržiūrėkite pateiktą video medžiagą, išnagrinėkite grafikus. Bet pirmiausia keletas svarbių sąvokų: Kintamojo reikšmių pasiskirstymas, arba skirstinys (angl. distribution), – tai būdas arba taisyklė, nurodanti, kaip išsidėsto mūsų tiriamo kintamojo reikšmės: kai kurios reikšmės pasitaiko dažniau, kai kurios rečiau, kai kurių gali apskritai nebūti. Statistinis dažnis (angl. frequency) parodo, kaip dažnai reikšmė pasitaiko duomenų eilutėje. Dažnių lentelė (angl. frequency table) parodo, kaip dažnai kiekviena iš reikšmių pasitaiko arba kaip dažnai patenka į tam tikrą reikšmių intervalą. Reikšmių grupavimas į intervalus angliškai vadinamas binning, o tokio tipo intervalas – bin. Mediana (žymėsime Md) – tai reikšmė, duomenų eilutę dalinanti į 2 lygias dalis. Įprastai tai vidurinė duomenų eilutės reikšmė arba dviejų vidurinių reikšmių vidurkis. Moda (žymėsime Mo) – dažniausiai pasitaikanti duomenų eilutės reikšmė. Taip pat moda galima vadinti dažniausiai pasitaikančių reikšmių intervalą, jei duomenys grupuoti. Duomenų sklaidos matai parodo, ar duomenys nuo centro nutolę daug, ar nedaug. 8.1 Grafikai vieno kintamojo apibendrinimui 8.1.1 Kategoriniams duomenims Šie grafikai tinkami nominaliesiems, ranginiams ir kiekybiniams diskretiesiems duomenims (kai skirtingų reikšmių yra nedaug). Video epizodas 8.1 Stulpelinė diagrama. 8.1.2 Tolydiesiems duomenims Šie grafikai tinkami kiekybiniams tolydiesiems ir kiekybiniams diskretiesiems duomenims. Video epizodas 8.2 Histograma. Pav. 8.1: Pavyzdys, kaip analizuoti histogramą. Pav. 8.2: Histogramos grupavimo intervalo pločio parinkimas. A – per siauras intervalas (per didelis intervalų skaičius) išryškina triukšmą ir paslepia tendenciją. D – per platūs intervalai (per mažas intervalų skaičius) taip pat paslepia tikrąją tendenciją. B, C – tinkamai parinktas intervalų skaičius, matoma tendencija. B – geriausias variantas. Įprastai reikia tarp 5 ir 15 intervalų. Video epizodas 8.3 Branduolinio tankio diagrama. Pav. 8.3: Vienas duomenų taškas atvaizduotas branduoline kreive. Branduolinio tankio diagramoje vienas taškas aprašomas kreive, vadinama branduoliu, kuri ties centru aukščiausia, o į kraštus mažėja. Pavyzdyje (A, B, C, D) tai Gauso kreivės, kurios gali skirtis savo pločiu. Branduolio formą ir plotį pasirenka tyrėjas, visgi kiekvienam grafiko taškui aprašyti naudojami identiški branduoliai. Pav. 8.4: Branduolinio tankio diagramoje (BTD) atvaizduoti visi duomenų eilutės taškai. Svarbu pasirinkti tinkamą branduolio plotį. A – per siauri branduoliai nepakankamai gerai suglotnina kreivę, matosi triukšmas, sunku įžiūrėti tendenciją. D – per platūs branduoliai per daug suglotnina duomenis, BTD smarkiai išeina už realių duomenų ribų, taip pat nesimato tikrosios tendencijos. B, C – pakankamai gerai parinktas branduolio plotis. C – geriausias variantas. Pav. 8.5: Informacijos branduolinio tankio (BTD) ir stačiakampėje diagramoje palyginimas. Abiejų tipų diagramose atvaizduoti tie patys duomenys. \\(Md\\) – mediana, \\(Q_1\\), \\(Q_3\\) – pirmasis ir trečiasis kvartiliai. Pav. 8.6: Branduolinio tankio diagramos (BTD) naudojimas grupių lyginimui. Iš grafiko matosi, kad S. pratensis augalai turėjo santykinai daugiau ilgesnių stiebų nei S. officinalis (nes mėlynas grafikas pasislinkęs į didesnių reikšmių pusę). Video epizodas 8.4 Stačiakampė diagrama (J.W. Tukey stiliaus). Video epizodas 8.5 Stačiakampė, smuikinė ir pasklaidytų taškų diagramos. 8.2 Diagramų palyginimas Grafiniam informacijos palyginimui, pateiktam šio poskyrio grafikuose 8.7, 8.8, 8.9, 8.10, 8.11, 8.12, buvo dirbtinai sugeneruoti duomenys. Kintamasis „Reikšmė“ padalintas į 8 duomenų grupes (nuo A iki H). Grupė A yra kontrolinė. Visos kitos nuo jos skiriasi pagal vieną konkretų požymį: imties dydį (n): A grupėje n = 250 (didesnė grupė), B – n = 63 (keturis kartus mažesnė grupė); centro padėtį: A vidurkis yra 50 (vidutiniškai didesnės reikšmės), C – 40 (vidutiniškai mažesnės reikšmės); sklaidą: A standartinis nuokrypis (SD) yra 5 (mažesnė sklaida), D – 10 (didesnė sklaida); viršūnių skaičių: A viena viršūnė, E – dvi viršūnės; simetriją: A pasiskirstymas simetriškas, F – dešinioji asimetrija (skirstinio „uodega“ nutįsusi į didelių reikšmių pusę); simetriją: A pasiskirstymas simetriškas, G – kairioji asimetrija (skirstinio „uodega“ nutįsusi į mažų reikšmių pusę); išskirtis: A ryškių išskirčių nėra, H – yra du labai smarkiai nuo centro nutolę taškai. Peržvelkite žemiau pateiktus grafikus ir įvertinkite, kaip ši informacija juose matoma. Pav. 8.7: Grupių palyginimas duomenis atvaizduojant taškais. Visi taškai išsidėstę į vieną liniją. Kai taškai persidengia, grafikas tampa mažai informatyvus. Pav. 8.8: Grupių palyginimas duomenis atvaizduojant pasklaidytų taškų diagrama. Siekiant išvengti persidengimo, taškai pasklaidyti x ašiai lygiagrečia kryptimi. Pav. 8.9: Grupių palyginimas duomenis atvaizduojant histograma. Pav. 8.10: Grupių palyginimas duomenis atvaizduojant branduolinio tankio diagrama (BTD). Pav. 8.11: Grupių palyginimas duomenis atvaizduojant stačiakampe diagrama. Pav. 8.12: Grupių palyginimas duomenis atvaizduojant smuikine diagrama. Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["aprasomoji-nadojant-Rcmdr.html", "9. R Commander: pagrindai ir aprašomoji statistika 9.1 R Commander diegimas ir įjungimas 9.2 R Commander konfigūravimas 9.3 Duomenų įkėlimas į R 9.4 Duomenų lentelės peržiūra 9.5 Kintamųjų klasės keitimas 9.6 Reikšmių perskaičiavimas ar perkodavimas 9.7 Grafikai 9.8 Programos kodo elementai", " 9. R Commander: pagrindai ir aprašomoji statistika „R Commander“ yra „R“ paketas (Rcmdr), sukuriantis duomenų analizei skirtą langą, veikiantį „pasirink ir paspausk“ metodu, o programos kodas generuojamas automatiškai. Tai ypač pravartu, jei esate pradedantysis „R“ vartotojas, neturite pakankamo kiekio programavimo žinių arba „R“ naudojate tik retkarčiais. Pastaba. Šio skyriaus medžiaga yra priedas prie „YouTube“ grojaraščiuose „Pratybos Nr. 4“ ir „Pratybos Nr. 5“ esančios medžiagos. 9.1 R Commander diegimas ir įjungimas „R Commander“ įdiegiamas naudojant komandą install.packages(&quot;Rcmdr&quot;) (užtenka atlikti vieną kartą), o įjungiamas naudojant komandą library(Rcmdr). Jei langas išjungiamas, o paketas Rcmdr vis dar užkrautas, iš naujo „R Commander“ galite atidaryti naudodami komandą Commander(). Taip pat galite atsisiųsti papildomų įskiepių (ang. plug-ins), kurie praplės Rcmdr funkcionalumą. Kaip tai padaryti, mokoma kurso „YouTube“ grojaraštyje „Pratybos Nr. 4“ . 9.2 R Commander konfigūravimas Jei norite Rcmdr paleisti 3 langų režimu, prieš įjungdami papildinį naudokite tokį kodą: options(Rcmdr = list(console.output = FALSE)) Jei papildomai norite užsikrauti jau įdiegtus įskiepius, tam, kad atsirastų papildomos meniu komandos, naudokite tokį konfigūravimo kodą: # Pradiniai R Commander nustatymai ====================================== options(Rcmdr = list( console.output = FALSE, plugins = c( &quot;RcmdrPlugin.KMggplot2&quot;, &quot;RcmdrPlugin.EZR.as.menu&quot;, &quot;RcmdrPlugin.biostat&quot; )) ) Po to naudokite funkciją library(Rcmdr) (jei paketas dar neužkrautas) arba Commander() (jei paketas užkrautas, bet Commander langas uždarytas), kuri jūsų situacijai tinka. Jei konfigūravimo kode bus nurodyti įskiepiai (paketai), kurių jūsų kompiuteryje nėra, „R Commander“ nepasileis apskritai. Jei konfigūravimo kode buvo klaida, tada pataisykite kodą, įvykdykite jį ir iš naujo pasileiskite „R Commander“. Jei vis dar neveikia, perkraukite „R“ ir bandykite iš naujo. 9.3 Duomenų įkėlimas į R Šiame skyriuje susipažinsite su būdais, kaip duomenis įsikelti į „R“. Duomenų įkėlimo ir išsaugojimo skyriai techninėje angliškoje literatūroje gali būti trumpinami IO, I/O ar panašiai (nuo žodžių input and output), pvz., „Data IO“. Priklausomai nuo prigimties, duomenys kompiuteryje, interneto svetainėse ar serveriuose gali būti saugomi daugybe formatų. Šio kurso metu daugiausiai dirbsime su duomenų lentelės tipo duomenimis, todėl susipažinsime, kokiais formatais įprastai išsaugomos duomenų lentelės. Duomenis į programą „R“ galima importuoti: įsikeliant iš „R“ paketų; nuskaitant iš įprastinių duomenų bylų (esančių kompiuteryje ar internete); susivedant „ranka“; iš iškarpinės (pvz., naudojant kopijavimą, Ctrl+C), jei jie yra pateikti tinkamu formatu. Šio kurso kontekste svarbiausi bylų su duomenimis formatai pateikti pav. 9.1. Pav. 9.1: Bylų su duomenų lentelėmis klasifikavimas. Šio kurso kontekste svarbiausi formatai: duomenys „R“ paketuose, .Rds, .RData bylos, tekstiniai skirtukais atskirtų reikšmių formatai ir „Excel“ bylos. Dažnai duomenų bylos tipą galime atpažinti pagal bylos pavadinimo plėtinį, pvz., .txt ar .xlsx. Skirtingų programų ir formatų bylų pavadinimai įprastai turi standartinius tam formatui bylos pavadinimo plėtinius (taip vadinamos raidės po paskutinio taško, pagal kurias operacinė sistema parenka, kokia programa atidaryti bylą). Tam, kad juos matytumėte, rekomenduoju naudoti „RStudio“ langą „Files“, nes kitais būdais plėtiniai gali būti paslėpti (pav. 9.2). Panagrinėkime kelis šio kurso metu svarbius pavyzdžius – plėtiniai: .txt, .csv, .dat rodo, kad tai tekstiniai duomenys. Gali būti ir kitokių plėtinių arba tekstinė byla gali būti apskritai be plėtinio. Taip pat turėkite omenyje, kad tekstinėse bylose gali būti nebūtinai duomenys arba nebūtinai skirtukais atskirtų formatų duomenys, o .csv nėra „Excel“ formatas, nors ir gali turėti „Excel“ ikoną; .xlsx arba .xls – programos „Excel“ formatai; .Rds, .rds, .RDS – „R duomenų struktūros“ (Rds) formato byla; .RData, .Rda, .rda – R-data formato byla. Pav. 9.2: Duomenų bylų pavadinimų peržiūra programomis „Windows Explorer“ (kairėje) ir „RStudio“ (dešinėje). Sistemoje „Windows“ žinomų duomenų tipų plėtiniai buvo paslėpti („Name“), bet rodomi duomenų tipų apibūdinimai („Type“). Programoje „RStudio“ plėtiniai rodomi visada. CSV (comma separated values) iš tiesų yra tekstinė byla, nors ir matoma „Excel“ ikona („rankos.csv“). 9.3.1 R objektų pavadinimai Kurdami „R“ objektų (šiuo atveju, nuskaitytų duomenų lentelių) pavadinimus vadovautumėtės „Tidyverse“ stiliaus gido rekomendacijomis objektų pavadinimams ). Ilgainiui pastebėsite, kad naudojant šias taisykles darbas su duomenimis supaprastėja, pvz., nereikia prisiminti, kuri raidė pavadinime yra didžioji, kuri – mažoji. Tema apie „R“ objektų pavadinimus plačiau nagrinėjama skyriuje „4.3.3 Objektų pavadinimai“. Santrauka: Objektų pavadinimus turi sudaryti mažosios angliškos raidės (a–z), skaičiai (0–9) ir apatiniai brūkšniai (_); Pavadinimas turi prasidėti raide. 9.3.2 Skirtukais atskirtų reikšmių (SAR) formatas Šiame skyriuje aptarsime tekstinį skirtukais atskirtų reikšmių (trumpinsime SAR) formatą. Esminiai dalykai, kuriuos reikia pastebėti prieš nuskaitant duomenis, išsaugotus šiuo formatu: Sveikosios ir dešimtosios skaičiaus dalies skirtukas (angl., decimal separator). Juo gali būti arba taškas (., angl. period, jei tai angliškas/amerikietiškas užrašymo variantas), arba kablelis (,, angl. comma, jei tai europietiškas/lietuviškasis variantas); Stulpelių (reikšmių) skirtukas (angl., field separator, delimiter). Juo gali būti kablelis, kabliataškis (angl., semicolon), tarpas, tabuliacija („ilgas tarpas“), vertikalus brūkšnys (|) ar kitoks simbolis, bet ne taškas (.). Vienas iš dažniausių tekstinių duomenų formatų – .csv (angl. comma sepatated values). Šios rūšies formatai būna 2 tipų: csv 1 („amerikietiškasis“) formatas, kuriame stulpelio skirtukas yra kablelis (,), o sveikosios ir dešimtosios skaičiaus dalių skirtukas yra taškas (.). csv 2 („europietiškasis“) formatas, kuriame stulpelio skirtukas – kabliataškis (;), o sveikosios ir dešimtosios dalių skirtukas – kablelis (,). Jei skaičiai į programą „R“ nuskaityti teisingai, tai programoje „R“ tarp sveikosios ir dešimtosios dalies privalo būti taškas, o ne kablelis, pvz., 22.6. Tekstinių bylų pavyzdžiai pateikti pav. 9.3. Pav. 9.3: Tekstinėse bylose skirtukais atskirtų reikšmių formatu saugomų duomenų pavyzdžiai. Įprastai duomenų stulpelių pavadinimai būna pirmoje eilutėje, o kiekviena kita eilutė yra skirta duomenims. Sakykime, kad tai įprastinis duomenų pateikimo budas. Pvz.: pavadinimas_1;pavadinimas_2;pavadinimas_3 1,0;A;vyras 6,1;A;moteris 5,2;B;vyras Tačiau gali būti, kad virš duomenų yra komentarai: Tai komentaras apie duomenis, o ne patys duomenys pavadinimas_1;pavadinimas_2;pavadinimas_3 1,0;A;vyras 6,1;A;moteris 5,2;B;vyras Komentarai gali būti pažymėti kokiu nors simboliu: # Tai komentaras apie duomenis pavadinimas_1;pavadinimas_2;pavadinimas_3 1,0;A;vyras 6,1;A;moteris 5,2;B;vyras Taip pat gali nebūti stulpelių pavadinimų: 1,0;A;vyras 6,1;A;moteris 5,2;B;vyras Gali būti skirtingu būdu užrašomų praleistų reikšmių. Pvz., praleista reikšmė pažymėta NA: # NA - praleista reikšmė pavadinimas_1;pavadinimas_2;pavadinimas_3 NA;A;vyras 6,1;A;NA 5,2;B;vyras Praleista reikšmė pažymėta ?: pavadinimas_1;pavadinimas_2;pavadinimas_3 ?;A;vyras 6,1;A;? 5,2;B;vyras Praleistos reikšmės turi skirtingus žymėjimus: pavadinimas_1;pavadinimas_2;pavadinimas_3 NA;A;vyras 6,1;A;? 5,2;B;vyras Jei duomenyse yra neangliškų raidžių ar kitokių neįprastų simbolių, gali reikti pasirinkti tinkamą koduotę, tarkime UTF-8. Taip pat dirbant su lietuviškais simboliais turėtų būti nustatyta lietuviškoji lokalė tiek programoje „R“, tiek operacinėje sistemoje (Windows/MAC/Linux), nes kitaip gali kilti nesklandumų. Tad nuskaitydami duomenis būkite atidūs ir pasirinkite tinkamus nuskaitymo parametrus. Norintys gilesnių žinių apie CSV bylų sudarymo taisykles gali peržiūrėti šį šaltinį . 9.3.3 Pastabos apie programos R formatų duomenis Jei „R“ atmintyje yra objektas (žiūrėti „RStudio“ lange „Environment“) tokiu pat pavadinimu, kaip ir „.RData“ byloje (neįsikėlę pažiūrėti negalime), tai atidarius šią bylą senasis objektas iš atminties bus ištrintas ir pakeistas naujuoju, kuris buvo nuskaitytoje byloje. Būkite atidūs, kad neprarastumėte svarbių duomenų. Būtent dėl šios priežasties iš visų „R“ duomenų formatų .RData rekomenduoju mažiausiai. Funkcija data() skirta nuskaityti ne bet kokius, bet tik mokomuosius duomenis iš „R“ paketų. 9.4 Duomenų lentelės peržiūra Įsikėlus duomenis įprasta juos peržiūrėti. Tai daroma siekiant susipažinti su duomenimis, jų struktūra bei patikrinti, ar jie buvo įkelti taip, kaip tikėjomės. 9.4.1 Duomenys, kuriuos naudosime Šio skyriaus pavyzdžiuose ir klausimuose naudosime duomenų lenteles „iris“, „npk“, „swiss“ bei „women“, kurios yra „R“ paketo datasets dalis. Daugiau apie lenteles rašoma jų dokumentacijoje, kuri atveriama pele pažymėjus lentelės pavadinimą, parašytą redaktoriaus lange arba konsolėje, ir paspaudus F1. Taip pat parašius tokią komandą: klaustuką ? ir po jo – lentelės pavadinimą, pvz., ?iris, ?npk ar ?swiss (vieną komandą vienu metu). Jei naudojate „RStudio“, aprašymai atsiras „Help“ kortelėje. Mokomuosius duomenis iš paketų užsikraukime naudodami funkciją data(): data(&quot;iris&quot;, package = &quot;datasets&quot;) data(&quot;npk&quot;, package = &quot;datasets&quot;) data(&quot;swiss&quot;, package = &quot;datasets&quot;) data(&quot;women&quot;, package = &quot;datasets&quot;) 9.4.2 Pagrindinės peržiūros funkcijos Įsikėlus duomenų lenteles, įprasta susipažinti su duomenų lentelės struktūra ir susidaryti įspūdį, koks jos turinys. Tam naudingos funkcijos, kurių skliaustuose nurodomas dominančios lentelės pavadinimas be kabučių: class() – rodyti duomenų lentelės „R“ klasę. Jei yra kelios klasės, žiūrėkite į pirmąją. Įprastai lentelės skiriasi tik tuo, kaip yra atspausdinamos: įprastinė duomenų lentelė (klasė data.frame); „tibble“ duomenų lentelė (klasė tbl_df, oficiali tidyverse duomenų lentelės klasė iš paketo tibble); data.table klasės duomenų lentelė (iš paketo data.table. Šis paketas skirtas didelėms duomenų lentelėms, kai norima didelės spartos apdorojant duomenis). dim() – rodyti dimensiją: eilučių ir stulpelių skaičių lentelėje (galioja ES taisyklė – pirma eilutės, po to stulpeliai); glimpse() iš paketo dplyr (patogesnis str() analogas) – glaustai rodyti struktūrą: eilučių (Observations) ir stulpelių (Variables) skaičių, stulpeliuose esančių duomenų tipus ir kelias pirmąsias reikšmes; View() – peržiūrėti lentelę atskirame lange; head() – rodyti pirmąsias eilutes; tail() – rodyti paskutines eilutes; names() – rodyti kintamųjų pavadinimus; colnames() – rodyti stulpelių pavadinimus; rownames() – rodyti eilučių pavadinimus; summary(skim()) – stulpeliuose esančių duomenų tipų suvestinė. Privalo būti užkrautas paketas skimr. Jei, tarkime, norime patyrinėti duomenų lentelę „iris“ – štai keletas pavyzdžių, kaip naudoti šias funkcijas: library(dplyr) library(skimr) dim(iris) head(iris) tail(iris) glimpse(iris) summary(skim(iris)) Pastebėkite, kad po to, kai užkrovėme duomenis (lentelės), toliau jų pavadinimą rašome be kabučių, nes duomenų lentelė (šiuo atveju „iris“) — jau „R“ atmintyje esantis objektas. Užduotis 9.1 Naudodamiesi funkcijomis class(), dim(), glimpse(), head(), tail(), names(), colnames(), rownames(), View(), patyrinėkite duomenų lenteles iris, npk, swiss, women. Jos užkraunamos iš „R“ paketo datasets. Atsakykite į klausimus: Kokia duomenų lentelės klasė? Ar „data.frame“? Kiek lentelėje objektų? Kiek kintamųjų? Kokie kintamųjų pavadinimai? Ar lentelė turi eilučių pavadinimus, ar tik eilučių numerius? 9.4.3 Kaip atpažinti stulpeliuose esančių duomenų klases? Kiekvienas stulpelis lentelėje yra tam tikro tipo statistinis kintamasis. „R“ kiekvienam kintamajam – lentelės stulpeliui – suteikia „R“ objekto klasę, kurią galime sužinoti keliais būdais. Jei duomenų lentelę atspausdinsime R Markdown dokumente dirbdami Notebook režimu (kol kas nesimokėme), rezultatas bus panašus į tą, kuris pateiktas paveiksle 9.4. Pav. 9.4: Duomenų lentelė atspausdinta R Markdown dokumente dirbant Notebook režimu (nesimokėme). Kintamųjų (lentelės stulpelių) klasės pateiktos po pavadinimais trikampiuose skliaustuose. Eilučių skaičius – lentelės apačioje („4 rows“). Naudodami funkciją glimpse(), gausime tokį rezultatą: ## Observations: 4 ## Variables: 6 ## $ lapu_skaicius &lt;int&gt; 24, 22, 28, 25 ## $ lapu_ilgis &lt;dbl&gt; 1.3, 1.6, 2.2, 1.1 ## $ kvapo_stiprumas &lt;ord&gt; silpnas, vidutinis, stiprus, stiprus ## $ ziedu_spalva &lt;fct&gt; raudona, geltona, geltona, balta ## $ ar_augo_lauke &lt;lgl&gt; FALSE, TRUE, TRUE, FALSE ## $ komentaras &lt;chr&gt; &quot;-&quot;, &quot;-&quot;, &quot;tirta ryte&quot;, &quot;-&quot; Čia „R“ parašo eilučių (4) ir stulpelių (6) skaičių, išvardija kintamųjų pavadinimus (lapu_skaicius, lapu_ilgis, …), jų klases (int, num ir t.t.), kelias pirmąsias reikšmes (pvz., 24, 22, 28, …). Dažniausiai naudojamų „R“ duomenų tipų žymėjimai: dbl (double) arba num (numeric) – realusis skaičius (skaičius su kableliu); int (integer) – sveikasis skaičius; fct arba Factor – faktorius, kategorinis (nominalusis) kintamasis, kurio reikšmės neturi natūralios tvarkos; ord arba Ord.factor (ordered factor) – ranginis kintamasis (faktorius, kurio reikšmės turi eilės tvarką); lgl arba logi (logical) – loginis kintamasis; chr (character) – tekstas (simbolių eilutės); date arba Date – data; dttm (datetime), arba POSIXct, POSIXlt ir kiti – data ir laikas. Užduotis 9.2 Naudodami funkciją glimpse(), nustatykite, kokie „R“ duomenų tipai yra lentelių iris, npk, swiss bei women stulpeliuose. 9.4.4 Teorinis duomenų tipas ir jam tinkama R klasė Statistikos kurso metu dirbsime tik su kiekybiniais (skaitiniais) ir su kategoriniais (nominaliaisiais ir ranginiais) kintamaisiais. „R“ aplinkoje kintamiesiems turi būti parinktos tinkamos klasės. Tada „R“ braižys tinkamus grafikus, atliks tinkamas statistines suvestines, leis atlikti tai duomenų klasei tinkamus statistinius testus. Teoriniai kintamųjų tipai ir jiems tinkamos R klasės: Kiekybiniams (skaitiniams): tolydiesiems tinka: klasė „numeric“ (dar vadinama „double“) – įprastinis pasirinkimas. klasė „integer“ – taip pat tinka; diskretiesiems tinka: klasė „integer“ – įprastinis pasirinkimas; klasė „numeric“ („double“) – taip pat tinka. Kokybiniams (kategoriniams): nominaliesiems – klasė „factor“; ranginiams – klasė „ordered“. Statistinei duomenų analizei klasės „logical“ bei „character“ dažniausiai yra netinkamos. Jos įprastai verčiamos į kategorinių duomenų klases (factor, ordered). 9.5 Kintamųjų klasės keitimas Užduotis 9.3 Dar kartą patyrinėkite duomenų lenteles iris, npk, swiss bei women: Kas yra tiriamieji? (Skaitykite duomenų lentelės aprašyme – dokumentacijoje). Koks teorinis kintamojo tipas (tolydieji, skaitiniai diskretieji, ranginiai, nominalieji duomenys) turėtų tikti kiekvienam stulpeliui teoriškai? Atsakymą grįskite duomenų lentelės aprašyme (dokumentacijoje) pateikta informacija bei funkcijos glimpse() rezultatais. Kokiomis „R“ objektų klasėmis išsaugoti šie kintamieji iš tiesų? Ar pagal teorinį kintamųjų tipą (nominalusis, ranginis, diskretusis, tolydusis) „R“ klasės (factor, ordinal, numeric, integer ir kitos) parinktos tinkamai? Atsakymą apie kintamuosius surašykite į tokią lentelę: Lentelės pavadinimas Kintamojo pavadinimas Teorinis kintamojo duomenų tipas Kintamojo „R“ klasė Ar klasė duomenims parinkta teisingai? … … … … … … … … … … 9.6 Reikšmių perskaičiavimas ar perkodavimas (Medžiaga rengiama) 9.7 Grafikai Aprašomosios statistikos esmė – atlikti ir pateikti skaitines ar grafines duomenų suvestines, kurios glaustai perteikia esminius turimų duomenų bruožus. 9.7.1 Grafikų išsaugojimas redaguojamu formatu Jei grafikus braižote bazine „R“ sistema (paketas graphics) arba paketo ggplot2 funkcijomis (taip daro Rcmdr įskiepis RcmdrPlugin.KMggplot2), tokius grafikus galite išsaugoti redaguojamu formatu į „PowerPoint“ skaidrę. Tam naudojamas žemiau pateiktas programos kodas ir reikiamoje vietoje įkopijuojamas paveikslą braižantis kodas. # Užkraunami paketai --------------------------------------------------------- library(tidyverse) library(officer) library(rvg) # Išsaugome į PowerPoint ----------------------------------------------------- # Pasirinkite bet kokį pavadinimą, bet pabaiga privalo likti &quot;.pptx&quot;: pptx_bylos_pavadinimas &lt;- &quot;r_paveikslas.pptx&quot; # Išsaugojimas: bylos_vieta &lt;- read_pptx() %&gt;% add_slide(layout = &quot;Blank&quot;, master = &quot;Office Theme&quot;) %&gt;% ph_with_vg_at( left = 0, top = 0, width = 7, # &lt;--- Jei reikia, keisti paveikslo plotį height = 5, # &lt;--- Jei reikia, keisti paveikslo aukštį code = { # &lt;--- &quot;code&quot; arba &quot;gg&quot; # Paveikslo kodo rašymo pradžia ----------------------------------- # Paveikslo kodo rašymo pabaiga ----------------------------------- } ) %&gt;% print(target = pptx_bylos_pavadinimas) # Vieta, kur išsaugotas jūsų grafikas ---------------------------------------- print(bylos_vieta) # PowerPoint bylos atidarymas ------------------------------------------------ browseURL(bylos_vieta) Prieš įrašydami naują paveikslą į tą pačią „PowerPoint“ bylą, ją uždarykite. Kitaip nebus galima įrašyti. Įrašymo metu senasis paveikslas bus prarastas („PowerPoint“ byla ištrinta), tad jei reikia, bylą išsaugokite nauju pavadinimu. Pavyzdys 1: bazinis „R“ grafikas. # Užkraunami paketai --------------------------------------------------------- library(tidyverse) library(officer) library(rvg) # Išsaugome į PowerPoint ----------------------------------------------------- # Pasirinkite bet kokį pavadinimą, bet pabaiga privalo likti &quot;.pptx&quot;: pptx_bylos_pavadinimas &lt;- &quot;bazinis_paveikslas.pptx&quot; # Išsaugojimas: bylos_vieta &lt;- read_pptx() %&gt;% add_slide(layout = &quot;Blank&quot;, master = &quot;Office Theme&quot;) %&gt;% ph_with_vg_at( left = 0, top = 0, width = 7, # &lt;--- Jei reikia, keisti paveikslo plotį height = 5, # &lt;--- Jei reikia, keisti paveikslo aukštį code = { # &lt;--- &quot;code&quot; arba &quot;gg&quot; # Paveikslo kodo rašymo pradžia ----------------------------------- plot(x = 1:5) # Paveikslo kodo rašymo pabaiga ----------------------------------- } ) %&gt;% print(target = pptx_bylos_pavadinimas) # Vieta, kur išsaugotas jūsų grafikas ---------------------------------------- print(bylos_vieta) # PowerPoint bylos atidarymas ------------------------------------------------ browseURL(bylos_vieta) Pavyzdys 2: ggplot2 grafikas. Vietoje code, ggplot2 grafikams gali būti naudojamas argumentas gg. Arba turi būti panaudota funkcija print() – grafikas atspausdintas išreikštai. Taip pat grafiko spausdinimo kodo vietoje nenaudokite funkcijos require(). Dėl jos grafikas negalės būti išsaugotas. # Užkraunami paketai --------------------------------------------------------- library(tidyverse) library(officer) library(rvg) Sys.setlocale(locale = &quot;Lithuanian&quot;) # Išsaugome į PowerPoint ----------------------------------------------------- # Pasirinkite bet kokį pavadinimą, bet pabaiga privalo likti &quot;.pptx&quot;: pptx_bylos_pavadinimas &lt;- &quot;ggplot_paveikslas.pptx&quot; # Išsaugojimas: bylos_vieta &lt;- read_pptx() %&gt;% add_slide(layout = &quot;Blank&quot;, master = &quot;Office Theme&quot;) %&gt;% ph_with_vg_at( left = 0, top = 0, width = 7, # &lt;--- Jei reikia, keisti paveikslo plotį height = 5, # &lt;--- Jei reikia, keisti paveikslo aukštį gg = { # &lt;--- &quot;code&quot; arba &quot;gg&quot; # Paveikslo kodo rašymo pradžia ----------------------------------- qplot(iris$Species, color = I(&quot;black&quot;), ylab = &quot;Skaičius&quot;) # Paveikslo kodo rašymo pabaiga ----------------------------------- } ) %&gt;% print(target = pptx_bylos_pavadinimas) # Vieta, kur išsaugotas jūsų grafikas ---------------------------------------- print(bylos_vieta) # PowerPoint bylos atidarymas ------------------------------------------------ browseURL(bylos_vieta) 9.8 Programos kodo elementai 9.8.1 Duomenų lentelių sudarymas iš vektorių Duomenų sekų (vektorių) vertimas į duomenų lenteles vykdomas naudojant funkciją data.frame() (duomenų lentelė), tibble() iš paketo tibble ar pan. Iš principo tai tokios pat lentelės, tik atspausdinamos kitaip. library(tidyverse) vektorius &lt;- 1:3 (duom_lentele &lt;- data.frame(vektorius)) ## vektorius ## 1 1 ## 2 2 ## 3 3 colnames(duom_lentele) ## [1] &quot;vektorius&quot; (duom_lentele &lt;- data.frame(naujas_pavadinimas = vektorius)) ## naujas_pavadinimas ## 1 1 ## 2 2 ## 3 3 colnames(duom_lentele) ## [1] &quot;naujas_pavadinimas&quot; grupes &lt;- c(&quot;A&quot;, &quot;A&quot;, &quot;C&quot;) duom_lentele &lt;- data.frame(x = vektorius, gr = grupes) colnames(duom_lentele) ## [1] &quot;x&quot; &quot;gr&quot; duom_lentele ## x gr ## 1 1 A ## 2 2 A ## 3 3 C glimpse(duom_lentele) # Tekstas paverstas į faktorius ## Observations: 3 ## Variables: 2 ## $ x &lt;int&gt; 1, 2, 3 ## $ gr &lt;fct&gt; A, A, C duom_lentele_2 &lt;- tibble( x = vektorius, gr = grupes) colnames(duom_lentele_2) ## [1] &quot;x&quot; &quot;gr&quot; duom_lentele_2 ## # A tibble: 3 x 2 ## x gr ## &lt;int&gt; &lt;chr&gt; ## 1 1 A ## 2 2 A ## 3 3 C glimpse(duom_lentele_2) # Tekstas į faktorius nepaverstas ## Observations: 3 ## Variables: 2 ## $ x &lt;int&gt; 1, 2, 3 ## $ gr &lt;chr&gt; &quot;A&quot;, &quot;A&quot;, &quot;C&quot; 9.8.2 Duomenų lentelės stulpelių vertimas vektoriais Jei duomenų lentelės stulpelius norime analizuoti kaip vektorius, yra keli būdai: operatorius $; operatorius [[ ]]; funkcija with(). data(iris, package = &quot;datasets&quot;) # Užsikraukime mokomuosius duomenis „iris“ glimpse(iris) ## Observations: 150 ## Variables: 5 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,... ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1,... ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5,... ## $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1,... ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, s... Iš lentelės „iris“ pasirenkame stulpelį „Species“ ir paverčiame jį į vektorių: rusys &lt;- iris$Species head(rusys) ## [1] setosa setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica Kitas būdas: rusys_2 &lt;- iris[[&quot;Species&quot;]] head(rusys_2) ## [1] setosa setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica Jei naudojame [[ ]], pavadinimas nurodomas kabutėse. Funkcija with() naudojama pagal tokį šabloną: with(duomenu_lentele, funkcija(stulpelio_pavadinimas)) Pvz.: with(iris, table(Species)) ## Species ## setosa versicolor virginica ## 50 50 50 with(iris, qplot(Species)) with(iris, qplot(Species, color = I(&quot;red3&quot;), xlab = &quot;Rūšys&quot;, ylab = &quot;Skaičius&quot;)) 9.8.3 Jungimo operatorius %&gt;% Papildinio „R Commander“ įskiepis „RcmdrPlugin.biostat“ įprastai generuoja kodą, kuriame funkcijos sujungtos funkcijų jungimo į grandinę operatoriumi %&gt;% (angl., pipe ) iš paketo magrittr. Tad šis skyrius skirtas tam, kad geriau suprastumėte „R“ kodą. Sutrumpintai %&gt;% vadinsime tiesiog jungimo operatoriumi. „RStudio“ turi greitąją klavišų kombinaciją Ctrl+Shift+M, kuri įterpia operatorių. Norint operatorių naudoti privalo būti užkrautas paketas magrittr arba tidyverse: library(tidyverse) Naudojant %&gt;% kodą galima užrašyti žmogui suprantamesniu būdu. # Turime: duomenys &lt;- 1:10 # Iš užrašo įdėtiniu būdu (funkcija fikcijoje): exp(mean(duomenys)) ## [1] 244.6919 # Paverčiame į užrašą nuosekliu būdu: duomenys %&gt;% mean() %&gt;% exp() ## [1] 244.6919 Iš čia matome, kad sukurtą duomenų seką pirma susidukriname, po to įvykdome exp(). Toks užrašymas ypač patogus, kai turime žymiai sudėtingesnius veiksmus atliekančias funkcijas. Įprastinis operatoriaus naudojimas: rezultatas &lt;- duomenys %&gt;% pirmasis_veiksmas(papildomi_argumentai = &quot;reikšmės&quot;) %&gt;% antrasis_veiksmas() %&gt;% treciasis_veiksmas() Užrašas reiškia, kad pirma paimami duomenys „duomenys“, jiems atliekamas „pirmasis_veiksmas“ naudojant nurodytus argumentus. Šio veiksmo rezultatui – „antrasis_veiksmas“. Jo rezultatui – „treciasis_veiksmas“. Galiausiai paskutinis rezultatas išsaugomas kaip „rezultatas“. Tiek naudojant %&gt;%, tiek jo nenaudojant rezultatas turi būti identiškas. Dar keli pavyzdžiai: summary(1:5) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1 2 3 3 4 5 (1:5) %&gt;% summary() # Reikia skliaustų (1:5) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1 2 3 3 4 5 Prieš skliaustus iškeliame viską iki pirmojo kablelio, o kablelį ištriname: x &lt;- c(1:15, NA) mean(x, na.rm = TRUE) ## [1] 8 x %&gt;% mean(na.rm = TRUE) ## [1] 8 ats &lt;- round(sqrt(mean(x, na.rm = TRUE)), digits = 3) ats ## [1] 2.828 # Užrašymo būdas vienoje eilutėje: ats &lt;- x %&gt;% mean(na.rm = TRUE) %&gt;% sqrt() %&gt;% round(digits = 3) ats ## [1] 2.828 # Užrašymo būdas per kelias eilutes: ats &lt;- x %&gt;% mean(na.rm = TRUE) %&gt;% sqrt() %&gt;% round(digits = 3) ats ## [1] 2.828 Užrašius naudojant %&gt;% aiškesnė veiksmų seka bei kam priklauso argumentas digits = 3. Užduotis 9.4 Šias „R“ kodo eilutes užrašykite naudodami operatorių %&gt;%: summary(iris); mean(23:30); tail(iris, n = 20); summary(tail(data.table::fread(&quot;http://calcnet.mth.cmich.edu/org/spss/V16_materials/DataSets_v16/Diseaseoutbreak.txt&quot;))); mean(c(log(20*pi, base = 16), NA, 14, 24), na.rm = TRUE). "],
["skirstiniai.html", "10. Atsitiktiniai dydžiai ir skirstiniai 10.1 Apie pratybas 10.2 Tikimybių teorijos elementai 10.3 Tikimybiniai atsitiktinių dydžių modeliai 10.4 Skirstiniai programoje R 10.5 Programos GeoGebra tikimybių skaičiuoklė 10.6 Skirstiniai ir tikimybiniai uždaviniai", " 10. Atsitiktiniai dydžiai ir skirstiniai Šio skyriaus medžiaga nėra skirta šių metų kursui, todėl jos nenagrinėkite. 10.1 Apie pratybas Pratybų metu mokysimės (1) turimiems duomenims parinkti labiausiai tinkantį tikimybinį modelį (skirstinio tipą ir tinkamiausius jo parametrus) bei (2) spręsti tikimybinius uždavinius. Užsiėmimo tikslas – išmokti duomenims parinkti tinkamą teorinį atsitiktinio dydžio modelį (skirstinį) bei susipažinti su skirstinių taikymo principais tikimybiniams uždaviniams spręsti. 10.2 Tikimybių teorijos elementai Taikant aprašomosios statistikos metodus galima aprašyti bet kokią imtį (nekreipiant dėmesio į atsitiktinumą, atsirandantį sudarant imtį) ar net visą generalinę aibę (GA). Tačiau norint pagal imties duomenis daryti statistines išvadas (išvadas apie visą GA) būtina atsižvelgti į šį atsitiktinumą. Statistinių išvadų darymo metodai grindžiami tikimybių teorija. Tam, kad galiotų tikimybių teorijos dėsniai, imtis turi būti sudaryta tinkamai – tikimybiniu būdu, t. y., kiekvienam objektui tikimybė patekti į imtį turi būti vienoda, ir teoriškai idealiu laikomas – visiškai atsitiktinis grąžintinis imties sudarymo būdas. Šiame kurse dėstomi statistinių išvadų darymo metodai sukurti tik visiškai atsitiktinėms imtims ir tinka tik tada, jei imtis yra tikimybinė. 10.2.1 Tikimybiniai eksperimentai ir įvykiai Viena iš tikimybių teorijos sąvokų yra tikimybinis eksperimentas – tai toks bandymas, kuris gali turėti keletą atsitiktinių baigčių, ir negalima iš anksto pasakyti, kuri iš galimų baigčių įvyks šį kartą. Kiekvieno tikimybinio eksperimento rezultatas vadinamas (atsitiktiniu) įvykiu. Pvz., bandymas – auginamos ląstelės, įvykis – užaugusių ląstelių skaičius; bandymas – tiriama kūdikio lytis, įvykis – lytis yra mergaitė; bandymas – pasėjama 10 sėklų, įvykis – sudygo 8 sėklos; bandymas – vykdoma apklausa, įvykis – 91% studentų atsakė, kad jau atliko namų darbus; bandymas – ieškomas organų donoras iki tol, kol bus rastas tinkamas, įvykis (jei donoras rastas iš antro karto): pirmas donoras – netinkamas, antras – tinkamas; bandymas – sportininkas šauna į taikinį, įvykis – balų skaičius, surinktas pagal balų skaičiavimo taisykles. Įvykiai gali būti elementarieji (tokie, kurie negali būti suskaidyti į mažesnes dalis, pvz., viena sėkla gali arba sudygti, arba nesudygti) ir sudėtiniai (susidėti iš kelių elementariųjų įvykių, pvz., pasodinus 10 sėklų, kiekvienos iš jų sudygimas/nesudygimas – elementarusis įvykis, o bendras viso eksperimento rezultatas – sudygusių sėklų skaičius – sudėtinis įvykis). Įvykis – tai tikimybinio eksperimento rezultatas. 10.2.2 Atsitiktinis dydis Kita tikimybių teorijos sąvoka – atsitiktinis dydis (trumpinsime ats.d., angl. random variable) yra toks dydis, kuris po bandymo įgyja vieną konkrečią iš anksto nežinomą skaitinę reikšmę. Tam, kad atsitiktinio dydžio reikšmė taptų skaitinė, gali būti panaudota perkodavimo ar perskaičiavimo taisyklė, pagal kurią atsitiktiniam įvykiui priskiriama skaitinė reikšmė. Jei bandymo rezultatas nėra išreikštas kaip skaičius – tai nėra atsitiktinis dydis. Keletas ats.d. pavyzdžių: tiriame augalų aukštį, ats.d. – aukštis centimetrais; ištiriame n baltymo molekulių, ats.d. – pažeistų molekulių skaičius; pasėjame 20 sėklų, ats.d. – sudygusių sėklų skaičius po 3 dienų (įvykis – sėkla sudygo ar nesudygo – nėra ats.d., nes tai ne skaičius, o pavertimas į ats.d. – suskaičiavimas, kiek sėklų sudygo); ieškome naftos ir darome gręžinius, ats.d. – gręžinių, kuriuose neradome naftos, skaičius iki tol, kol padarėme gręžinį, kuriame atradome naftos (vėl kategorinio tipo – rado/nerado naftos – įvykiui pritaikoma tam tikra taisyklė, kaip paversti į skaičių); tiriame paukštį ir skaičiuojame parazitus, ats.d. – surastų parazitų skaičius. Atsitiktinio dydžio įgyjamos reikšmės visada yra skaičiai. Atsitiktiniai dydžiai dažnai žymimi didžiosiomis raidėmis, (pvz., \\(X\\), tarkim ilgis), o jų įgyjamos reikšmės – mažosiomis (\\(x\\), tarkim 6 cm). Atsitiktinio dydžio vidurkis žymimas \\(\\mathbf{E}X\\), o dispersija – \\(\\mathbf{D}X\\). Skaitiniai kintamieji būna tolydieji arba diskretieji, todėl ir atsitiktiniai dydžiai būna diskretieji arba tolydieji. Pav. 10.1: Ar įžvelgiate analogiją tarp diskrečiųjų ir tolydžiųjų ats.d. bei diskrečiųjų \\((A)\\) ir tolydžiųjų, gradientinių \\((B)\\) spalvų skalių? Daugiau apie atsitiktinius dydžius galite sužinoti šiame video paskaitų cikle (anglų kalba su subtitrais, kurių reikia ieškoti kortelėje „Transcript“): nuoroda . Visiems rekomenduoju peržiūrėti bent pirmąją dalį, kurios trukmė ~ 6 min. 10.2.3 Tikimybė Tikimybė (angl. probability) – skaitinis atsitiktinės įvykio baigties galimybės matas. Kinta nuo 0 (negalimas įvykis, kuris neįvyks) iki 1 (būtinasis įvykis, kuris tikrai įvyks). Tikimybė dažnai žymima kaip funkcija \\(P\\). Jei \\(A\\) yra mus dominantis įvykis, sakykime, \\(A\\) – gims mergaitė, tada užrašas „\\(P(A)\\)“ nurodo tikimybę, kad gims mergaitė, pvz., \\(P(A) = 0.49\\). Užrašas \\(P(X = x) = 0.1\\) reikštų, kad tikimybė, jog atsitiktinis dydis (\\(X\\) didžioji, sakykime, kolonijų skaičius) bus lygus konkrečiam skaičiui (\\(x\\) mažoji, tarkim, 20), lygi 0.1, t. y., 10%. Tikimybė gali būti užrašoma kaip skaičius tarp 0 ir 1 arba procentine išraiška nuo 0% iki 100%. Apie terminų vartojimą: terminas „tikimybė“ yra tinkamesnis kalbant apie generalinę aibę. O kalbant apie imties duomenis, tinkamesnis atitikmuo būtų „santykinis dažnis“. Generalinė aibė ↔ tikimybė Imtis ↔ santykinis dažnis 10.2.4 Skirstiniai Atsitiktinio dydžio reikšmių skirstinys (angl. probability distribution), arba tiesiog skirstinys, – yra būdas arba taisyklė, susiejanti atsitiktinio dydžio reikšmes su jų įgijimo tikimybėmis. Skirstinys gali būti pateiktas kaip formulė, lentelė arba grafikas. Priklausomai nuo ats.d. tipo, skirstiniai skirstomi į diskrečiuosius ir tolydžiuosius. Atsitiktinio dydžio skirstinys – tai atsitiktinio dydžio reikšmės ir su jomis susietos tikimybės. Kiekvienas skirstinys gali būti pateiktas dviem formomis (pav. 10.2): jei skirstinys diskretusis: tikimybių (tikimybės masės) funkcija (pvz., santykinių dažnių lentelė) – parodo konkrečios reikšmės įgijimo tikimybę, kuri įprastai žymima \\(P(X = x)\\); diskrečioji pasiskirstymo funkcija (pvz., sukauptųjų santykinių dažnių lentelė) – parodo tikimybę įgyti reikšmę, ne didesnę už kitą konkrečią reikšmę, vadinamą kvantiliu. Pasiskirstymo funkcija įprastai žymima \\(F(x)\\), kur \\(x\\) yra kvantilis, ir yra lygi išraiškai \\(P(X \\le x)\\). jei skirstinys tolydusis: tikimybės tankio funkcija (ar pamenate branduolių tankio grafiką?) – pasirinktame ats.d. reikšmių intervale plotas po šia kreive parodo tikimybę ats.d. reikšmei patekti į intervalą; tolydžioji pasiskirstymo funkcija – analogiškai kaip ir diskrečiojo skirstinio atveju, parodo tikimybę įgyti reikšmę, ne didesnę už kitą konkrečią reikšmę, vadinamą kvantiliu, taip pat žymima \\(F(x)\\) ir yra lygi \\(P(X \\le x)\\). Trumpas matematinių užrašų, tokių kaip \\(F(x)\\), \\(P(X=x)\\), \\(P(X&lt;x)\\), paaiškinimas. Sakykime, kad atliekame kūdikių svorio tyrimą. Užrašas, \\(F(3~kg)\\) atitiktų užrašą \\(P(Svoris \\le 3~kg)\\) bei sakinį „tikimybė, kad kūdikio svoris, tiriamasis atsitiktinis dydis \\(X\\), bus ne didesnis už \\(3~kg\\), t. y., už konkretų skaičių \\(x\\)“. Pav. 10.2: Diskrečiųjų ir tolydžiųjų skirstinių formos ir paaiškinimai, kaip jas atpažinti. Taškai žymi konkrečias ats.d. reikšmes ir su jomis susietas tikimybes. Pav. 10.3: Sąsaja tarp tolydžiojo ats.d. \\(X\\) kvantilio \\(x_\\alpha\\), su juo susietos tikimybės \\(\\alpha\\) bei tikimybės tankio ir tikimybės pasiskirstymo grafikų. Plotas po tankio grafiko kreive tam tikrame intervale nurodo tikimybę, kuri matoma ir pasiskirstymo funkcijos y ašyje. Plotas po visa tankio kreive lygus 1, tokio dydžio yra ir maksimali pasiskirstymo funkcijos y ašies reikšmė. Vaizduojamas normaliojo skirstinio pavyzdys. Pav. 10.4: Sąsaja tarp diskrečiojo ats.d. \\(X\\) kvantilio \\(x_{\\alpha}\\), su juo susietos tikimybės \\(\\alpha\\) bei tikimybių (masės) ir tikimybės pasiskirstymo grafikų. Vaizduojamas binominio skirstinio pavyzdys. Atsitiktiniai dydžiai įprastai gali būti aprašyti vienu iš kelių žinomų teorinių skirstinių, kurie modeliuoja tam tikrus procesus. Pvz., tolydieji ats.d. gali būti aprašomi normaliuoju (Gauso), log-normaliuoju, diskretieji – Puasono, binominiu, geometriniu, neigiamu binominiu ir kitais. Į teorinių skirstinių naudojimą galima žiūrėti kaip į mokslinį įrankį, skirtą įvertinti tikimybinių reiškinių neapibrėžtumą, apskaičiuoti paklaidas, analizuoti procesų kilmę (ar atitinka modelį, ar ne), atlikti kitokius skaičiavimus, kurie leistų priimti statistiniu modeliavimu pagrįstus sprendimus. Tarkime, jei modelis imties duomenims tinka pakankamai gerai, tada tarsi teigiama, kad modeliu aprašomas skirstinys būdingas generalinei aibei ir pagal jį galima daryti prognozes. Skirstiniai gali būti taikomi tokiose srityse, kaip: tikimybinių reiškinių, atsitiktinių dydžių modeliavimas (pvz., apskaičiuoti, kokia tikimybė, kad jūs turėsite bent 2 vaikus); pasikliauties intervalų sudarymas (pvz., iš apklausos duomenų reikia įvertinti, kuri visos Lietuvos vyrų reguliariai užsiima aktyvia fizine veikla); statistinių hipotezių tikrinimas (pvz., iš tyrimo duomenų reikia nuspręsti, kas Vilniaus universiteto studentams labiau pakelia nuotaiką: plytelė šokolado ar 15 minučių bėgimo). Šio užsiėmimo metu gilinsimės į pirmąją taikymo sritį. Keliuose tolimesniuose skyriuose apžvelgsime kelis dažniausiai naudojamus tikimybinius modelius. 10.3 Tikimybiniai atsitiktinių dydžių modeliai Šiame skyriuje panagrinėsime kelis žinomus teorinius skirstinius, kurie gali būti naudojami tikimybi6kai apra6yti tam tikrų bandymų rezultatus. 10.3.1 Binominis skirstinys Keletas terminų, susijusių su diskrečiaisiais skirstiniais: sėkmė (arba sėkmingas bandymas) – toks rezultatas, kai įvyko mus dominantis/mums palankus įvykis; nesėkmė (arba nesėkmingas bandymas) – toks rezultatas, kai neįvyko mus dominantis/mums palankus įvykis. Sakykime, kad vykdome bandymą tokiomis sąlygomis: atliekant bandymą galimos tik 2 baigtys, pvz., pavyko / nepavyko, sėkmė / nesėkmė, vyras / moteris, sudygo / nesudygo, skaičius / herbas; bandymus kartojame \\(n\\) kartų \\((n = ~1, ~2, ~3, ~...)\\): pvz., iš viso yra \\(n\\) objektų, gali įvykti \\(n\\) įvykių ir pan. vieno bandymo sėkmės tikimybė yra žinoma ir lygi \\(p\\) \\((0&lt;p&lt;1)\\); tikimybė \\(p\\) yra pastovi visų bandymų metu; kiekvieno bandymo rezultatai yra tarpusavyje nepriklausomi. Tokiu atveju ats.d. \\(X\\) – sėkmingų bandymų skaičius iš \\(n\\) galimų – bus diskretusis \\((k = 0,~ 1,~ 2,~ ... ,~ n)\\), pasiskirstęs pagal binominį dėsnį ir žymimas: \\[\\begin{equation} X \\sim \\mathcal{B}(n, ~ p) \\tag{10.1} \\end{equation}\\] Konkrečios reikšmės įgijimo tikimybė aprašoma lygtimi: \\[\\begin{equation} P(X = k) = \\binom{n}{k}p^kq^{n-k} \\tag{10.2} \\end{equation}\\] Čia \\(q = (1-p)\\), o \\(\\binom{n}{k} = \\frac{n!}{k!(n-k)!}\\) – binominis koeficientas. Matematinės binominio ats.d. savybės (vidurkis ir dispersija): \\[\\begin{equation} \\mathbf{E}X = np, ~~~ \\mathbf{D}X = npq \\tag{10.3} \\end{equation}\\] Biologinis pavyzdys: ats.d. – sudygusių sėklų skaičius, kai pasėjame 20. Jei \\(X\\) yra binominis ats.d., įprastai skirstinio parametrą \\(n\\) žinome (arba numanome) – nes žinome, kiek kartų atliktas eksperimentas. Mums dažniausiai reikia nustatyti sėkmės tikimybę \\(p\\). Atkreipkite dėmesį, kad binominio skirstinio parametras \\(n\\) nėra tas pats, kas imties dydis, kuris dažnai statistikoje žymimas ta pačia raide. Šio žymėjimo nekeičiau, nes jis plačiai paplitęs ir naudojamas programose, kuriomis atliksime skaičiavimus. Jei gerai išstudijuosite binominį modelį, sunkumų neturėtų kilti. 10.3.2 Puasono skirstinys Sakykime, kad vykdome bandymą tokiomis sąlygomis: atliekant bandymą skaičiuojami įvykiai, tenkantys vienam vienetui: objektui arba laiko, ilgio, ploto, erdvės ar kitokiam vienetui; vidutinis įvykių skaičius \\((\\lambda)\\) šiam vienetui yra žinomas; maksimalus galimas įvykių skaičius nėra apribotas; tikimybė, kad įvyks įvykis, ir vidutinis įvykių skaičius yra pastovūs ir nekinta; įvykiai tarpusavyje yra nepriklausomi. Tokiu atveju ats.d. \\(X\\) – įvykių skaičius, tenkantis objektui, laiko, erdvės ar pan. vienetui – yra diskretusis \\((k = 0,~ 1,~ 2,~ ... )\\), skirstosi pagal Puasono modelį ir žymimas: \\[\\begin{equation} X \\sim \\mathcal{P}(\\lambda) \\tag{10.4} \\end{equation}\\] Konkrečios reikšmės įgijimo tikimybė aprašoma lygtimi: \\[\\begin{equation} P(X = k) = \\frac{ \\lambda^k }{k!}e^{-\\lambda} \\tag{10.5} \\end{equation}\\] Puasono ats.d. savybės (vidurkis ir dispersija): \\[\\begin{equation} \\mathbf{E}X = \\lambda, ~~~ \\mathbf{D}X = \\lambda \\tag{10.6} \\end{equation}\\] Parametras \\(\\lambda\\) yra kartu ir vidurkis, ir dispersija. Biologiniai pavyzdžiai: ats.d. – mutacijų, įvykstančių vienoje chromosomoje, skaičius. ats.d. – retos ligos atvejų, įvykstančių populiacijoje per vienerius metus, skaičius. 10.3.3 Binominio skirstinio aproksimacija Puasono skirstiniu Sakykime, kad savo tyrimo rezultatą galime aprašyti binominio skirstinio modeliu \\(X \\sim \\mathcal{B}(n, ~ p)\\), tačiau \\(n\\) palyginus su \\(p\\) – labai didelis (tarkime, \\(n &gt; 1000\\)), o \\(p\\) – labai mažas (tarkime, \\(p&lt;0,001\\)). Tokiu atveju binominio skirstinio tikimybes pakankamai gerai atitinka Puasono skirstinio \\(\\mathcal{P}(np)\\) tikimybės: teorinį binominio skirstinio vidurkį prilyginame teoriniam Puasono skirstinio vidurkiui \\((np \\sim \\lambda)\\) ir skaičiavimus atliekame naudodami Puasono skirstinį. Įprastai šitokios aproksimacijos reikia, jei skaičiavimus atliekame ne kompiuteriu arba grafinės skaičiuoklės, tokios kaip „GeoGebra“, užstringa dėl didelių skaičių. Skaičiuojant programa „R“ problemų įprastai nekyla. 10.3.4 Geometrinis skirstinys Sakykime, kad vykdome bandymą tokiomis sąlygomis: atliekant bandymą galimos tik 2 baigtys, pvz., pavyks / nepavyks, vyras / moteris; bandymus kartojame tol, kol sulaukiame pirmos sėkmės; vieno bandymo sėkmės tikimybė yra žinoma ir lygi \\(p\\) \\((0&lt;p&lt;1)\\); tikimybė \\(p\\) yra pastovi visų bandymų metu; kiekvieno bandymo rezultatai yra tarpusavyje nepriklausomi. Tada ats.d. \\(X\\) galime apsibrėžti kaip nesėkmingų bandymų skaičių iki pirmos sėkmės (į \\(X\\) sėkmingų bandymų skaičius nėra įskaitytas). Toks ats.d. \\(X\\) yra diskretusis \\((k = 0, 1, 2, …)\\), skirstosi pagal geometrinį skirstinį ir žymimas: \\[\\begin{equation} X \\sim \\mathcal{Geom}(p) \\tag{10.7} \\end{equation}\\] Konkrečios reikšmės įgijimo tikimybė aprašoma lygtimi: \\[\\begin{equation} P(X = k) = pq^k \\tag{10.8} \\end{equation}\\] Čia \\(q =(1-p)\\). Geometrinio ats.d. savybės (vidurkis ir dispersija): \\[\\begin{equation} \\mathbf{E}X = \\frac{q}{p}, ~~~ \\mathbf{D}X = \\frac{q}{p^2} \\tag{10.9} \\end{equation}\\] Biologinis pavyzdys: ats.d. yra gimusių berniukų skaičius prieš gimstant pirmai mergaitei. Pastaba. Geometrinis skirstinys turi du susijusius, bet skirtingus matematinius apibrėžimus. Šiame skyriuje pasirinktas tas, kuris naudojamas programose R ir GeoGebra. Čekanavičiaus ir Murausko vadovėlyje pateiktas kitas matematinis geometrinio skirstinio apibrėžimas, tad formulės neatitinka. Tačiau rezultatus galime persiskaičiuoti. Pavyzdžiui, jei norime modeliuoti, kiek įvykių įvyko iš viso \\((\\)pažymėkime \\(X^*)\\), o žinome, kiek iš jų buvo nesėkmingi \\((X)\\), prie gautos konkrečios \\(X\\) reikšmės pridedame 1 (sėkmingų įvykių skaičių): \\(k^* = k + 1\\) (\\(k^*\\) – įvykių skaičius iš viso). Analogiškai ir prie vidurkio pridedame 1: \\(\\mathbf{E}X^* = \\mathbf{E}X + 1\\). Tačiau prie dispersijos nieko pridėti nereikia, nes prie kiekvienos reikšmės pridėta konstanta dispersijos nepakeičia: \\(\\mathbf{D}X^* = \\mathbf{D}X\\). Jei dėl geometrinių atsitiktinių dydžių kyla klausimų ar neaiškumų, siūlau peržvelgti šį šaltinį (nuoroda ), kuriame aprašomi skirtumai. 10.3.5 Neigiamas binominis skirstinys Sakykime, kad vykdome bandymą tokiomis sąlygomis: atliekant bandymą galimos tik 2 baigtys, pvz., pavyks / nepavyks; bandymus kartojame tol, kol sulaukiame \\(r\\) sėkmių \\((r &gt; 0)\\); vieno bandymo sėkmės tikimybė yra žinoma ir lygi \\(p\\) \\((0&lt;p&lt;1)\\); tikimybė \\(p\\) yra pastovi visų bandymų metu; kiekvieno bandymo rezultatai yra tarpusavyje nepriklausomi. Tada ats.d. \\(X\\) galime apsibrėžti kaip nesėkmingų bandymų skaičių iki \\(r\\)-tosios sėkmės (į \\(X\\) sėkmingų bandymų skaičius nėra įskaitytas). Toks ats.d. \\(X\\) yra diskretusis \\((k = 0, 1, 2, …)\\), skirstosi pagal neigiamą binominį skirstinį ir žymimas: \\[\\begin{equation} X \\sim \\mathcal{NB}(r, p) \\tag{10.10} \\end{equation}\\] Konkrečios reikšmės įgijimo tikimybė aprašoma lygtimi: \\[\\begin{equation} P(X = k) = \\binom{k+r-1}{r-1}p^r q^k \\tag{10.11} \\end{equation}\\] Čia \\(q =(1-p)\\). Neigiamo binominio ats.d. savybės (vidurkis ir dispersija): \\[\\begin{equation} \\mathbf{E}X = \\frac{qr}{p}, ~~~ \\mathbf{D}X = \\frac{qr}{p^2} \\tag{10.12} \\end{equation}\\] Biologinis pavyzdys: ats.d. yra gimusių berniukų skaičius prieš gimstant penktai mergaitei. Bendruoju atveju parametras \\(r\\) gali nebūti sveikasis skaičius. Kai jis yra sveikasis, neigiamas binominis skirstinys dar vadinamas Paskalio (Pascal) skirstiniu (t. y., tam tikras neigiamo binominio skirstinio atvejis). Geometrinis skirstinys – taip pat atskiras neigiamo binominio ir Paskalio skirstinių atvejis, kai \\(r = 1\\). \\[\\begin{equation} X \\sim \\mathcal{NB}(r = 1,~ p) = Geom(p) \\tag{10.13} \\end{equation}\\] Paskalio skirstinys – tai neigiamas binominis skirstinys, kai parametras \\(r\\) yra sveikasis skaičius. Geometrinis skirstinys – tai neigiamas binominis skirstinys, kai parametras \\(r = 1\\). Pastaba. Neigiamas binominis skirstinys turi keletą skirtingų matematinių formuluočių, o šiame skyriuje aprašyta ta, kuri naudojama programose R ir GeoGebra. Norėdami modeliuoti kitaip apibrėžtą atsitiktinį dydį, rezultatus galime persiskaičiuoti. Pavyzdžiui, jei norime modeliuoti, kiek įvykių įvyko iš viso \\((\\)pažymėkime \\(X^*)\\), o žinome, kiek iš jų buvo nesėkmingi \\((X)\\), prie gautos konkrečios \\(X\\) reikšmės pridedame sėkmingų įvykių skaičių \\(r\\): \\(k^* = k + r\\) (\\(k^*\\) – įvykių skaičius iš viso). Analogiškai ir prie vidurkio pridedame \\(r\\): \\(\\mathbf{E}X^* = \\mathbf{E}X + r\\). Tačiau prie dispersijos nieko pridėti nereikia, nes prie kiekvienos reikšmės pridėta konstanta dispersijos nepakeičia: \\(\\mathbf{D}X^* = \\mathbf{D}X\\). Jei kils neaiškumų dėl neigiamo binominio skirstinio apibrėžimų, siūlau peržiūrėti šį šaltinį (nuoroda ). 10.3.6 Normalusis skirstinys Normalusis skirstinys yra tolydusis. Tikimybių teorijoje tai pats svarbiausias skirstinys, nes juo galima aprašyti daugelį natūraliai vykstančių reiškinių. Atsitiktinis dydis \\(X\\), kuris skirstosi pagal normalųjį skirstinį, žymimas: \\[\\begin{equation} X \\sim \\mathcal{N}(\\mu, \\sigma^2) \\tag{10.14} \\end{equation}\\] Normaliojo atsitiktinio dydžio tikimybės tankis \\(p(x)\\) ties konkrečia reikšme \\(x\\) skaičiuojamas pagal formulę: \\[\\begin{equation} p(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}~e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} \\tag{10.15} \\end{equation}\\] Parametrai: \\(\\mu\\) – vidurkis \\((\\mu \\in \\mathbb{R})\\); \\(\\sigma^2\\) – dispersija \\((\\sigma^2 &gt; 0)\\). Statistinės programos paprastumo dėlei vietoje dispersijos dažnai naudoja standartinį nuokrypį. Normaliojo ats.d. savybės (vidurkis, dispersija ir standartinis nuokrypis): \\[\\begin{equation} \\mathbf{E}X = \\mu, ~~~ \\mathbf{D}X = \\sigma^2, ~~~ \\sqrt{\\mathbf{D}X} = \\sigma \\tag{10.16} \\end{equation}\\] Standartinis normalusis: \\[\\begin{equation} X \\sim \\mathcal{N}(0; 1) \\tag{10.17} \\end{equation}\\] Standartinio normaliojo skirstinio savybės – vidurkis lygus nuliui, dispersija ir standartinis nuokrypis lygūs vienetui: \\[\\begin{equation} \\mathbf{E}X = 0, ~~~ \\mathbf{D}X = 1, ~~~ \\sqrt{\\mathbf{D}X} = 1 \\tag{10.18} \\end{equation}\\] Jei skirstinys normalusis, galioja empirinės taisyklės (grafinė iliustracija: nuoroda ). 10.3.7 Log-normalusis skirstinys Jei atsitiktinis dydis gali įgyti tik teigiamas reikšmes \\((X&gt;0)\\), o atlikus logaritminę transformaciją jo skirstinys tampa normalusis, tada sakoma, kad atsitiktinis dydis \\(X\\) pasiskirstęs pagal log-normalųjį skirstinį: \\[\\begin{equation} log(X) \\sim \\mathcal{N}(\\mu, \\sigma^2) \\tag{10.19} \\end{equation}\\] Atlikę logaritminę transformaciją, su šiuo dydžiu galime elgtis kaip su įprastu normaliuoju. 10.4 Skirstiniai programoje R Programoje R skirstinius aprašančių funkcijų pavadinimai turi 2 dalis: funkcijos tipą (norimą skaičiavimą) aprašanti dalis (raidė d, p, q arba r); skirstinio tipą aprašanti dalis (trumpasis R skirstinio pavadinimas). Lentelė 10.1: Funkcijos tipą (norimą skaičiavimą) aprašanti R funkcijos pavadinimo dalis (pirmoji raidė). Pirmoji raidė Pavadinimas Apibūdinimas d…() Tikimybės tankio arba tikimybių (masės) funkcija Konkrečiai ats.d. reikšmei \\(x\\)¹ apskaičiuojamas tikimybės tankis (tolydiesiems ats.d.) arba reikšmės įgijimo tikimybė \\(P(X = x)\\) (diskretiesiems ats.d.). p…() Pasiskirstymo funkcija Pateiktam kvantiliui \\(q\\)¹ apskaičiuojama jį atitinkanti tikimybė \\(p\\), lygi \\(P(X \\le q)\\), jei lower.tail = TRUE² (pasirinkta pagal nutylėjimą) arba tikimybė \\(P(X&gt;q)\\), jei lower.tail = FALSE. q…() Kvantilių funkcija (atvirkštinė pasiskirstymo funkcijai) Pateiktai tikimybei \\(p\\)¹ apskaičiuojamas ją atitinkantis kvantilis \\(q\\). Jei lower.tail = TRUE, tai tikimybė yra \\(P(X \\le q)\\), jei lower.tail = FALSE, tada – \\(P(X&gt;q)\\). r…() Atsitiktinių reikšmių generavimo funkcija Sugeneruojamas nurodytas skaičius reikšmių, kurios paimtos iš pagal nurodytą dėsnį pasiskirsčiusios generalinės aibės. ¹ – gali būti viena reikšmė arba reikšmių seka. Jei seka – skaičiuojama kiekvienai reikšmei atskirai. ² – žiūrėti funkcijų dokumentacijoje, pvz., ?pnorm. Lentelė 10.2: Skirstinio tipą aprašanti R funkcijos pavadinimo dalis: tolydžiųjų skirstinių pavyzdžiai. Tolydusis skirstinys R pavadinimas Svarbiausi parametrai programoje R Normalusis (Gauso) norm mean – vidurkis, sd – standartinis nuokrypis. Log-normalusis lnorm meanlog – vidurkis (logaritminėje skalėje), sdlog – standartinis nuokrypis (logaritminėje skalėje). \\(\\chi^2\\) (chi kvadratu) chisq df – laisvės laipsniai (\\(df&gt;0\\), bet nebūtinai sveikieji). Stjudento (t) t df – laisvės laipsniai (\\(df&gt;0\\), bet nebūtinai sveikieji). Fišerio (F) f df1, df2 – laisvės laipsniai skaitiklyje ir vardiklyje. Logistinis logis location, scale – padėties ir sklaidos parametrai. Tolygusis unif min, max – apatinė ir viršutinė pasiskirstymo ribos. Lentelė 10.3: Skirstinio tipą aprašanti R funkcijos pavadinimo dalis: diskrečiųjų skirstinių pavyzdžiai, parametrai ir modeliuojamo atsitiktinio dydžio apibrėžimas. Diskretusis skirstinys R pavadinimas Svarbiausi parametrai ir ats.d. programoje R Binominis binom size – bandymų skaičius, prob – vieno bandymo sėkmės tikimybė,ats.d. – sėkmingų bandymų skaičius. Puasono pois lambda – įvykių skaičiaus vidurkis/dispersija, ats.d. – įvykusių įvykių skaičius. Geometrinis geom prob – vieno bandymo sėkmės tikimybė, ats.d. – nesėkmingų bandymų skaičius. Neigiamas binominis nbinom size – norimas sėkmių skaičius, prob – vieno bandymo sėkmės tikimybė, ats.d. – nesėkmingų bandymų skaičius. Hipergeometrinis hyper m – pirmos grupės objektų skaičius, n – antros grupės objektų skaičius, k – atsitiktiniu negrąžintiniu būdu pasirinktų/ištrauktų objektų skaičius, ats.d. – pirmos grupės objektų skaičius tarp pasirinktų. Apibendrinant 10.1, 10.2 ir 10.3 lentelėse pateiktą informaciją, pilni skirstinio tipą ir pagal jį norimą skaičiavimą vykdančių funkcijų pavadinimai bus, pavyzdžiui, tokie: pnorm() – pateikus kvantilį, skaičiuos su juo pagal normalųjį dėsnį susietą tikimybę, qbinom() – pateikus tikimybes, skaičiuos pagal binominį skirstinį su jomis susietus kvantilius. Kiekvienos funkcijos skliaustuose turi būti nurodomi konkretaus skirstinio parametrai. Apie tai rašoma kiekvienos funkcijos dokumentacijoje. 10.4.1 R Commander tikimybių skaičiuoklės Papildinio Rcmdr meniu juostoje yra skiltis Distributions. Joje galite rasti įvairias tikimybių skaičiuokles. 10.5 Programos GeoGebra tikimybių skaičiuoklė Programa „GeoGebra“ yra nemokamas įrankių rinkinys įvairiems matematiniams (geometriniams, statistiniams ir kitiems) skaičiavimams. Programą galima parsisiųsti į savo kompiuterį, planšetę arba naudoti internetinę versiją (internetinė skaičiuoklės versija: nuoroda ). Mums reikalingas įrankis – tikimybių skaičiuoklė, su kuria supažindinama video epizoduose 10.1, 10.2 bei perskaičius šias instrukcijas: „Probability Calculator“ – trumpa instrukcija, kaip naudotis tikimybių skaičiuokle (nuoroda ); „GeoGebra Probability and Statistics Quickstart“ – greitos pradžios gidas: instrukcijos ir pažintiniai pratimai (nuoroda ). Video epizodas 10.1 Programos „GeoGebra“ tikimybių skaičiuoklė: įvadas. Video epizodas 10.2 Bendrieji principai, kaip spręsti tikimybinius uždavinius programos „GeoGebra“ tikimybių skaičiuokle: konkrečių reikšmių įgijimo tikimybių, tikimybių įgyti reikšmę iš tam tikro intervalo, su tikimybėmis susietų kvantilių, ats.d. vidurkio ir standartinio nuokrypio apskaičiavimas. 10.6 Skirstiniai ir tikimybiniai uždaviniai Šiame skyriuje bus supažindinta, kaip sprendžiami tikimybiniai uždaviniai. Bendrosios rekomendacijos, kaip spręsti. Pirmiausia pagal uždavinio sąlygą reikia nuspręsti, ar uždaviniui spręsti apskirtai reikalingas skirstinys. Jei taip, tada nustatyti, ar atsitiktinis dydis yra tolydusis, ar diskretusis, bei koks galėtų būti jo skirstinio tipas ir parametrai. Po to spręsti, kas duota (kvantilis, konkreti reikšmė ar tikimybė) bei ką reikia apskaičiuoti (kvantilį, konkrečią reikšmę, reikšmių intervalą, tikimybę ar kokią nors kitą skirstinio savybę, pvz., vidurkį). Tada nuspręsti, ar naudoti tikimybių skaičiuokles, ar užtenka kurių nors skirstinio savybes, pvz., vidurkį aprašančių formulių. Svarbu patikrinti, ar rezultatas yra logiškas. 10.6.1 Žinome tikimybę, kaip rasti kvantilį? Nustatome, su kokio tipo ats.d. susidūrėme: tolydžiuoju ar diskrečiuoju. Pasirenkame tinkamą teorinio modelio (skirstinio) tipą: normalųjį, Puasono, binominį ar kitą. Apskaičiuojame modelio parametrus: jie gali būti nurodyti uždavinio sąlygoje. Nurodome tikimybę (skaitine išraiška); Pažymime, kuri tai tikimybė: Tikimybė „mažiau už“ (α, „lower tail“) ar Tikimybė „daugiau už“ (1-α, „upper tail“). Naudodami skaičiuoklę ar funkciją apskaičiuojame kvantilį (konkretų skaičių). Programoje R funkcijos, kurios skaičiuoja kvantilius, prasideda raide q(angl., quantile), po to seka sutrumpintas skirstinio pavadinimas: qnorm, qbinom, qpois, qt, … Kodą už mus gali parašyti Rcmdr. Uždavinį taip pat galima spręsti programa „GeoGebra“. Pav. 10.5: Kvantilių skaičiavimas papildiniu R Commander. Užduotis 10.1 Ar tiesa, kad: …kai Puasono skirstinio parametras \\(\\lambda = 3\\), tai skirstinio kvantilis, atitinkantis tikimybę \\(\\alpha=0.5\\), yra lygus 6? …kai geometrinio skirstinio sėkmės tikimybė (skirstinio parametras) \\(p = 1\\), tai kvantilis, atitinkantis tikimybę \\(1-\\alpha=0.4\\) yra lygus 4. 10.6.2 Žinome kvantilį, kaip rasti tikimybę? Nustatome, su kokio tipo ats.d. susidūrėme: tolydžiuoju ar diskrečiuoju. Pasirenkame tinkamą teorinio modelio (skirstinio) tipą: normalųjį, Puasono, binominį ar kitą. Apskaičiuojame modelio parametrus: jie gali būti nurodyti uždavinio sąlygoje. Nurodome kvantilį (skaitine išraiška); Pažymime, kuri tikimybė mus domina: Tikimybė „mažiau už“ (α, „lower tail“) ar Tikimybė „daugiau už“ (1-α, „upper tail“). Naudodami skaičiuoklę ar funkciją apskaičiuojame tikimybę (skaičių tarp 0 ir 1). Pav. 10.6: Principas, kaip apskaičiuoti tikimybes, kad reikšmė pateks į intervalą. Pav. 10.7: Tikimybių skaičiavimas papildiniu R Commander (tolydieji skirstiniai). Pav. 10.8: Tikimybių skaičiavimas papildiniu R Commander (diskretieji skirstiniai). R programoje funkcijos, kurios skaičiuoja tikimybes, kai žinomi kvantiliai, prasideda raide p (angl. probability), po to eina sutrumpintas skirstinio pavadinimas: pnorm, pbinom, ppois, pt, … Kodą už mus gali parašyti Rcmdr. Uždavinį taip pat galima spręsti programa „GeoGebra“. Užduotis 10.2 Kokia tikimybė, kad reikšmė, atsitiktinai pasirinkta iš Stjudento t skirstinio su 5 laisvės laipsniais, bus mažesnė už 1,3? 10.6.3 Žinome reikšmę, kaip rasti jos įgijimo tikimybę/tikimybės tankį? Programoje R funkcijos, kurios skaičiuoja konkrečios reikšmės įgijimo tikimybes/tikimybės tankį prasideda raide d (angl. density), po to eina sutrumpintas skirstinio pavadinimas: dnorm, dbinom, dpois, dt, … Pastaba: tikimybes skaičiuoja tik diskretiesiems dydžiams pagal tikimybės masės funkciją; tikimybės tankį skaičiuoja tik tolydiesiems dydžiams pagal tikimybės tankio funkciją. Užduotis 10.3 Žinoma, kad \\(X \\sim \\mathcal{P}(2)\\). Apskaičiuokite tikimybę \\(P(X = 4)\\). 10.6.4 Tikimybinių uždavinių pavyzdžiai Užduotis 10.4 Išspręskite šiuos uždavinius: Žąsų migracija. Daugiamečių stebėjimų duomenimis, žąsų migracija pavasarį užtrunka vidutiniškai 4 dienas (SD = 1,3 dienos). Darykime prielaidą, kad kelionės trukmės skirstinys yra normalusis. Kokia tikimybė, kad šiemet migracija: baigsis greičiau nei per 6 dienas? užtruks ilgiau nei 6 dienas? užtruks ne mažiau kaip 2, bet ne daugiau kaip 5 dienas? Koks migracijos trukmės 10% procentilis? SD – standartinis nuokrypis. Kelionė į paskaitą. Vidutiniškai kelionė į biostatistikos paskaitą užtrunka 40 min \\((\\sigma = 10~min)\\). Sakykime, kad kelionės trukmės skirstinys – normalusis. Kokia tikimybė, kad kelionė užtruks daugiau nei 50 min? Kokia tikimybė, kad kelionė užtruks mažiau nei 55 min? Nurodykite labiausiai tikėtinų kelionės trukmių intervalą (trumpiausią ir ilgiausią trukmę), atmetus 5% trumpiausių ir 5% ilgiausių kelionių. Nurodykite labiausiai tikėtinų kelionės trukmių intervalą, apibrėžiantį, kiek laiko įprastai užtrunka kelionė 95% kartų, atmetus vienodą kiekį išskirtinai trumpiausių ir išskirtinai ilgiausių kelionių. Kokia tikimybė, kad kelionė užtruks lygiai 30 min? Stjudento t skirstinys. Kokia tikimybė, kad atsitiktinai pasirinkta atsitiktinio dydžio, pasiskirsčiusio pagal Stjudento skirstinį su 5 laisvės laipsniais (df), reikšmė bus mažesnė už 0,5? Atsitiktinai pasirinka atsitiktinio dydžio, pasiskirsčiusio pagal Stjudento skirstinį, reikšmė. Įvertinkite, kada tikimybė, kad ši reikšmė bus mažesnė už -2, bus didesnė: kai skirstinio parametras df (laisvės laipsniai) lygus 10, 25 ar 50? Kada Stjudento skirstinio 5% procentilio reikšmė bus labiausiai nutolusi nuo 0: kai parametro df (laisvės laipsniai) reikšmė lygi 8, 22 ar 100? Kada Stjudento ir standartinis normalusis skirstiniai supanašėja? (Keiskite df reikšmes ir palyginkite.) df – nuo angl. degrees of freedom (laisvės laipsniai). Mergaitės trijų vaikų šeimoje. Kokia tikimybė, kad trijų vaikų šeimoje: bus bent viena mergaitė? visi vaikai bus mergaitės? bus dvi mergaitės? bus mažiau nei viena mergaitė? bus daugiau nei dvi mergaitės? pirmasis vaikas bus mergaitė? Kiek vidutiniškai mergaičių yra trijų vaikų šeimoje? Koks mergaičių skaičiaus trijų vaikų šeimoje standartinis nuokrypis? Neatvykimas į darbą. Vidutiniškai pirmadieniais į darbą neateina 3 darbuotojai. Kokia tikimybė, kad šį pirmadienį į darbą: ateis visi? neateis ne mažiau kaip 2 darbuotojai? neateis daugiau nei 5 darbuotojai? neateis nuo 2 iki 6 darbuotojų? Spontaninės mutacijos. Tyrimo su drozofilomis rezultatai siūlo, kad spontaninių žalingų mutacijų dažnis yra apie 1,2 mutacijos diploidiniam genomui. Darykime preliminarią prielaidą, kad žmogaus genome įvykstančių mutacijų pasiskirstymas atitinka Puasono dėsnį \\((X \\sim \\mathcal{P}(\\lambda = 1,2))\\). Kokia tikimybė, kad individas turės bent 12 spontaninių žalingų mutacijų? Genetinis nestabilumas. Tiriamas genetinis nestabilumas ir su juo susijęs vėžys. Paprastai, didelėje populiacijoje per metus suserga tik 1 pacientas iš 1000. Kokia tikimybė, kad šiemet šioje populiacijoje susirgs: tik 1 pacientas? susirgs bent 3 pacientai? ne mažiau kaip 2 pacientai? daugiau nei 5 pacientai? niekas nesusirgs? Kiek vidutiniškai pacientų susirgs šiemet? Sėklos – 1. Sėjant sėklas vienos sėklos sudygimo tikimybė – 75%. Įvertinkite, kiek vidutiniškai sėklų reikia pasėti, kad sudygtų 20, ir koks reikiamo pasėti sėklų skaičiaus standartinis nuokrypis. Kokia tikimybė, kad pasėjus 20 sėklų sudygs bent 75% iš jų? Naftos gręžiniai – 1. Naftos kompanijos atstovai žino, kad tiriamajame rajone 80% gręžinių naftos neturi. Kokia tikimybė, kad prieš atrandant naftos bus padaryti 2 nesėkmingi bandymai? Kokia tikimybė, kad nafta bus atrasta gręžiant penktą kartą? Kokia tikimybė, kad nafta bus atrasta išgręžus ne daugiau kaip 6 gręžinius be naftos? Kiek vidutiniškai gręžinių reikia išgręžti, kad būtų rasta naftos? Naftos gręžiniai – 2. Naftos kompanijos atstovai žino, kad tiriamajame rajone padarius gręžinį tikimybė rasti naftos 60%. Šiame regione yra suplanuota eksploatuoti 3 naftos platformas. Kiek vidutiniškai gręžinių reikės padaryti, norint įgyvendinti šį tikslą? Kokia tikimybė, kad visi 3 bandymai bus sėkmingi? Kokia tikimybė, kad iki tol, kol pasieks tikslą, kompanija padarys ne daugiau kaip 3 nesėkmingus bandymus? Recesyvinė liga ir būsimi vaikai. Vyras ir moteris yra recesyvinės ligos nešiotojai. Jie nori 5 vaikų. Kokia tikimybė, kad visi 5 vaikai šios ligos atžvilgiu bus sveiki? Kokia tikimybė, kad bent 4 vaikai iš penkių bus sveiki? "],
["skirstinio-parinkimas.html", "11. Skirstinio parinkimas duomenims 11.1 Skaitiniai būdai modelio ir duomenų suderinamumui vertinti 11.2 Paketas fitdistrplus teoriniam modeliui parinkti 11.3 Kelių modelių palyginimas (paketas fitdistrplus) 11.4 Jei duomenys pateikti kaip dažnių lentelė (fitdistrplus)", " 11. Skirstinio parinkimas duomenims Šio skyriaus medžiaga nėra skirta šių metų kursui, todėl jos nenagrinėkite. Skirstinio parinkimas – tai procedūra, kuomet statistiniai duomenys aprašomi geriausiai juos atitinkančiu teoriniu modeliu – skirstiniu. Modelio parinkimas prasideda tuo, kad pirmiausia nustatome, kokį atsitiktinį dydį modeliuosime – tolydųjį ar diskretųjį. Tada nusprendžiame, kurie skirstiniai (normalieji, binominiai, geometriniai ar kiti) geriausiai tiktų mūsų duomenims ir iškeltai mokslinei problemai spręsti. Išsirinkę skirstinius, apskaičiuojame tinkamiausius jų parametrus (pvz., \\(\\mathcal{N}(257; 35)\\), \\(\\mathcal{B}(7; 0,22)\\), \\(\\mathcal{P}(3)\\)). Galiausiai grafiškai ir/arba pagal suderinamumo kriterijus nustatome, ar bent vienas teorinis modelis pakankamai gerai aprašo duomenis, ir jei taip, tai kuris. Kai modelis sudarytas, juo galime naudotis. Norint išsirinkti tinkamą modelį, patartina išbandyti kelis variantus ir pažiūrėti, kuriuo atveju turimi empiriniai duomenys labiausiai atitinka teorinius. Gali būti, kad vienodai gerai tiks keli variantai. Tokiu atveju, rinkitės lengviausiai interpretuojamą modelį. Deja, gali netikti nei vienas. Prieš pereidami prie kito skyriaus, panagrinėkime diskrečiųjų duomenų pavyzdį, kuriems modelis parinktas naudojantis teorinėmis žiniomis ir literatūra (paveikslas 11.1). Duomenys – šešis vaikus auginančių šeimų apklausos rezultatai. Tyrimo metu siekta nustatyti, kiek berniukų auga tokiose šeimose (tiksliau, įvertinti berniukų skaičiaus pasiskirstymą). Teoriškai tokiai situacijai galima naudoti binominį modelį, pvz., \\(\\mathcal{B}(6; 0,51)\\). Modelio parametras \\(n = 6\\) parinktas todėl, kad šeimose yra 6 vaikai, tad vienoje šeimoje gali būti iki 6 berniukų, o parametras \\(p = 0,51\\) (tikimybė, kad gims berniukas), sakykime, paimtas iš literatūros. Jei vieno ar abiejų parametrų nežinome, juos galime pasirinkti grįsdami teorinėmis žiniomis, pvz., perskaityta literatūra, arba apskaičiuoti iš duomenų naudodami tolimesniuose skyriuose aprašytus metodus. Pav. 11.1: Pavyzdys: dešimties šeimų, kuriose auga šeši vaikai, apklausos rezultatai, jų apibendrinimas ir palyginimas su teoriniu modeliu. Duomenų lentelė – tai pradiniai duomenys. Dažnių lentelė – empirinių duomenų skirstinys. Grafike – empirinių santykinių dažnių (juodos linijos) palyginimas su teorinio binominio modelio \\(\\mathcal{B}(6; 0,51)\\) tikimybėmis (raudonos linijos). Galima numanyti, kad turint didesnę imtį empiriniai duomenys geriau atitiks modelį. Praktinė pastaba apie modelių parinkimą Turimiems duomenims modelius galima parinkti visiškai „mechaniškai“ naudojantis įvairiais algoritmais bei statistinių paketų funkcijomis. Visgi prisiminkite, kad tai tik įrankiai, padedantys išspręsti jūsų tyrimo metu suformuluotą mokslinę problemą. Tam, kad modelis būtų prasmingas, tiek modelio, tiek jo parametrų prasmę reiktų suprasti ir interpretuoti savo tyrimo kontekste (kartais tam gali prireikti papildomos literatūros analizės). Ši idėja glaudžiai siejasi su kita mintimi: jei galite rinktis iš kelių panašaus „gerumo“ modelių, rinkitės paprastesnį ir lengviau interpretuojamą. 11.1 Skaitiniai būdai modelio ir duomenų suderinamumui vertinti Statistikų (kriterijų), pagal kurias galima vertinti empirinių duomenų ir teorinio modelio atitikimo „gerumą“, yra daug (pvz., \\(\\chi^2\\) statistika, Kolmogorovo-Smirnovo D statistika, AIC – Akaikės informacinis kriterijus, BIC – Bajeso informacinis kriterijus ir kitos). Jos turi savų pliusų ir savų minusų priklausomai nuo duomenų savybių. Visgi, kaip žinoti, kuris modelis iš kelių lyginamų yra tinkamesnis, jei sprendžiame pagal skaitinius kriterijus? Bendras principas yra toks: įprastai statistikos (kriterijai) tam tikru būdu vertina skirtumus tarp teorinių modelių ir empirinių duomenų, tad kuo statistikos reikšmė arčiau nulio (t. y., kuo skirtumas yra mažesnis), tuo duomenys geriau atitinka modelį. Įprastai kuo statistikos ar kriterijaus, vertinančio modelio ir duomenų suderinamumą, reikšmė arčiau nulio, tuo duomenys labiau suderinami su modeliu. Prisiminkite, kad kriterijaus statistika ir statistinio testo p reikšmė – tai du skirtingi dalykai. Pavyzdys 1. Lyginami duomenys ir tolydieji skirstiniai („Modelis-1“, „Modelis-2“, „Modelis-3“). Gaunami rezultatai: ## Goodness-of-fit statistics ## Modelis-1 Modelis-2 Modelis-3 ## Kolmogorov-Smirnov statistic 0.1138 0.412 0.165 ## Cramer-von Mises statistic 0.0695 3.884 0.206 ## Anderson-Darling statistic 0.3590 18.609 1.160 ## ## Goodness-of-fit criteria ## Modelis-1 Modelis-2 Modelis-3 ## Akaike&#39;s Information Criterion 486 1022 496 ## Bayesian Information Criterion 490 1027 501 Žymėjimai: „Goodness-of-fit“ – suderinamumas. Labiausiai su duomenimis suderinamas „Modelis-1“, prasčiausiai – „Modelis-2“. Pavyzdys 2. Lyginami duomenys ir diskretieji skirstiniai („Modelis-A“, „Modelis-B“, „Modelis-C“). Gaunami rezultatai: ## Chi-squared statistic: 8.2 6.4 147 ## Degree of freedom of the Chi-squared distribution: 4 4 4 ## Chi-squared p-value: 0.086 0.17 8.1e-31 ## Chi-squared table: ## obscounts theo Modelis-A theo Modelis-B theo Modelis-C ## &lt;= 1 31 35 25 84 ## &lt;= 2 43 42 43 28 ## &lt;= 3 47 45 53 21 ## &lt;= 4 35 35 43 16 ## &lt;= 5 32 22 24 12 ## &gt; 5 12 21 12 39 ## ## Goodness-of-fit criteria ## Modelis-A Modelis-B Modelis-C ## Akaike&#39;s Information Criterion 756 760 921 ## Bayesian Information Criterion 759 763 925 Iš šių rezultatų matome, kad kiekvienam modeliui („Modelis-A“, „Modelis-B“, „Modelis-C“) \\(\\chi^2\\) statistikos reikšmės yra atitinkamai \\(8.16\\), \\(6.38\\) bei \\(147\\), o \\(\\chi^2\\) suderinamumo kriterijaus (statistinio testo) p reikšmės yra atitinkamai \\(0.0859\\), \\(0.172\\) bei \\(8.09\\cdot 10^{-31}\\). BIC ir AIC kriterijų reikšmes taip pat matome. Žymėjimai: „obscounts“ – empiriniai dažniai (angl. observed counts), „theo“ – teoriniai dažniai. Pagal \\(\\chi^2\\) statistikos reikšmę galime vertinti, kad empiriniai duomenys ir „Modelis-B“ suderinami labiausiai, o „Modelis-C“ – prasčiausiai (turbūt, apskritai nesuderinamas). Nors skirtumas tarp suderinamumo su A ir B modeliais – ganėtinai menkas. Funkcijos, kurios sugeneravo šiuos pavyzdžius, aprašomos skyriuje „Palyginimas naudojant skaitines statistikas“. Užduotis 11.1 Duomenims bandoma parinkti tinkamą tikimybinį modelį. Kiekvienam modeliui (pažymėkime juos raidėmis nuo A iki E) \\(\\chi^2\\) statistikos reikšmės yra 264, 12.6, 23, 103, 22.3. Išrikiuokite modelius nuo labiausiai iki prasčiausiai suderinamo su duomenimis. Kitiems dviems modeliams Kolmogorovo-Smirnovo D statistikos reikšmės yra 0.35 ir 0.115. Kuris modelis labiau suderinamas su duomenimis? 11.2 Paketas fitdistrplus teoriniam modeliui parinkti Duomenims teorinį modelį galima parinkti naudojant funkciją fitdist() iš paketo fitdistrplus. Ši funkcija tinka ir tolydiesiems, ir diskretiesiems skirstiniams parinkti. Darbo eiga daugmaž tokia: # Užkraunamas paketas library(fitdistrplus) # Įkeliami duomenys data(npk) dplyr::glimpse(npk) # Pasirenkamas analizuojamas kintamasis derlius &lt;- npk$yield # (Papildomas nebūtinas žingsnis) # Aprašomas skirstinys. # Pagal asimetrijos ir eksceso koeficientus nubraižoma, į kokį teorinį skirstinį # panašus mūsų duomenų pasiskirstymas. descdist(derlius, discrete = FALSE, boot = 1000) # Pasirenkamas skirtinio tipas. # Tada programa apskaičiuoja labiausiai tinkančius parametrus. # Sukuriamas modelio objektas. modelis_normal &lt;- fitdist(derlius, distr = &quot;norm&quot;) # Modelio suvestinė summary(modelis_normal) # Patikrinama, kokie modelio parametrai parinkti coef(modelis_normal) # Skaitinės modelio ir duomenų suderinamumo charakteristikos gof_rez &lt;- gofstat(modelis_normal) gof_rez # Chi-kvadratu suderinamumo testo p reikšmė. # Tinka tik didelėms imtims (didesnėms už 30), # jei p &lt; 0.05 - skirtumas tarp modelio ir duomenų statistiškai reikšmingas. # Apie praktinį reikšmingumą spręsti pagal grafikus. gof_rez$chisqpvalue # Grafinis palyginimas plot(modelis_normal) # Linijos turi būti panašios Dabar panagrinėkime šių funkcijų rezultatus. Užsikraukime paketą: library(fitdistrplus) Įsikeliame duomenis. Pavyzdyje duomenys iš paketo. Darbinėje situacijoje įprastai duomenis įsikelsime iš duomenų bylos. Įsikėlę duomenis peržiūrime naudodami glimpse ar panašią funkciją. data(npk) dplyr::glimpse(npk) ## Observations: 24 ## Variables: 5 ## $ block &lt;fct&gt; 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5,... ## $ N &lt;fct&gt; 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1,... ## $ P &lt;fct&gt; 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0,... ## $ K &lt;fct&gt; 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1,... ## $ yield &lt;dbl&gt; 49.5, 62.8, 46.8, 57.0, 59.8, 58.5, 55.5, 56.0, 62.8, 55... Paketo fitdistrplus funkcijos skirtos darbui su duomenų eilutėmis (vektoriais), o ne duomenų lentelėmis, kaip tidyverse sistemoje. Analizei naudosime kintamojo yield iš duomenų lentelės npk reikšmes, tad jas priskirsime duomenų eilutei derlius: derlius &lt;- npk$yield Sukuriame normaliojo ats.d. modelį ir pavadiname „modelis_normal“. Pavadinti galime kaip norime, bet rekomenduojamas prasmingas pavadinimas. modelis_normal &lt;- fitdist(derlius, distr = &quot;norm&quot;) Galime pasirinkti ir kitą modelį, parašydami trumpąjį jo pavadinimą. Pavadinimų pavyzdžiai pateikti lentelėse 10.2, 10.3. Jei norite daugiau pavyzdžių ir paaiškinimų, pastudijuokite funkcijos dokumentaciją surinkę komandą ?fitdist. Toliau dirbsime su sukurtuoju modeliu „modelis_normal“ ir tikrinsime, kaip gerai duomenys atitinka šį modelį. Modelio suvestinę atlieka funkcija summary(): summary(modelis_normal) ## Fitting of the distribution &#39; norm &#39; by maximum likelihood ## Parameters : ## estimate Std. Error ## mean 54.875000 1.2334776 ## sd 6.042782 0.8722003 ## Loglikelihood: -77.22727 AIC: 158.4545 BIC: 160.8106 ## Correlation matrix: ## mean sd ## mean 1.00000000000000 -0.00000000382215 ## sd -0.00000000382215 1.00000000000000 Pirmame sakinyje, prasidedančiame žodžiais „Fitting of the distribution“, nurodomas taikytas modelis (t. y., „norm“) ir parametrų apskaičiavimo metodas („maximum likelihood“ – didžiausio tikėtinumo metodas). Suvestinės skiltyje „Parameters:“ matome apskaičiuotus normaliojo skirstinio parametrų (mean – vidurkis ir sd – standartinis nuokrypis) įverčius ir jų standartines paklaidas (standartinės paklaidos yra šių įverčių standartiniai nuokrypiai). Taip pat kitus modelio „gerumo“ įverčius, kurių nenagrinėsime. Koreliacijos matricos („Correlation matrix:“) taip pat nenagrinėsime. Jei jus domina tik parinkti modelio parametrai, o ne visa suvestinė, naudokite funkciją coef(): coef(modelis_normal) ## mean sd ## 54.875000 6.042782 Įvairios statistikos, pagal kurias įvertinama, kaip gerai duomenys atitinka modelį, gali būti gautos naudojant funkciją gofstat() (nuo angl. goodness-of-fit statistics): gof_rez &lt;- gofstat(modelis_normal) gof_rez ## Goodness-of-fit statistics ## 1-mle-norm ## Kolmogorov-Smirnov statistic 0.09158520 ## Cramer-von Mises statistic 0.02949152 ## Anderson-Darling statistic 0.20037302 ## ## Goodness-of-fit criteria ## 1-mle-norm ## Akaike&#39;s Information Criterion 158.4545 ## Bayesian Information Criterion 160.8106 Tinkamiausios statistikos parenkamos pagal tai, kokį teorinį modelį (pvz., diskretųjį ar tolydųjį) taikome, nebent nurodysite kitaip (kaip tai padaryti skaitykite įvedę komandą ?gofstat). Įprastai norime, kad šių statistikų reikšmės būtų kuo arčiau nulio. Chi-kvadratu \\((\\chi^2)\\) suderinamumo testas (angl. chi-square goodness-of-fit test) skirtas patikrinti hipotezę, ar duomenys ir modelis pakankamai gerai suderinami. Apie šį statistinį kriterijų plačiau rašoma Čekanavičiaus ir Murausko vadovėlyje „Statistika ir jos taikymai I“. Jei tenkinamos \\(\\chi^2\\) kriterijui taikyti reikiamos prielaidos, didelė p reikšmė \\((p&gt;0,05)\\) rodo, kad duomenys ir modelis pakankamai gerai suderinami. round(gof_rez$chisqpvalue, 3) ## [1] 0.383 Grafiniam teorinio modelio ir empirinių duomenų palyginimui gali būti naudojamos funkcijos plotdist() arba tiesiog plot(). Taip bus nubraižomi 4 tipų grafikai: plot(modelis_normal) Šiame pavyzdyje raudonai žymima teorinė kreivė. Daugiau informacijos apie galimus parametrus skaitykite funkcijos dokumentacijoje (?plotdist). Kiekvieno tipo grafiką galima nubraižyti atskirai naudojant funkcijas cdfcomp (sukauptojo santykinio dažnio diagrama lyginama su teorine tikimybių pasiskirstymo kreive), denscomp (teorinis tikimybių tankio grafikas lyginamas su empirine histograma), ppcomp (tikimybių-tikimybių – p-p – diagrama) ir qqcomp (kvantilių-kvantilių – q-q – diagrama). Šių funkcijų parametras addlegend kontroliuoja, ar braižyti legendą. cdfcomp(modelis_normal, addlegend = FALSE) denscomp(modelis_normal) ppcomp(modelis_normal, addlegend = FALSE) qqcomp(modelis_normal, addlegend = FALSE) Analogiškai galime sukurti ir log-normalųjį ar kitokį modelį. Log-normaliąjam modeliui visos kintamojo reikšmės privalo būti teigiamos: \\((x_i&gt;0)\\). Užduotis 11.2 Naudodami kodą: fit_lognorm &lt;- fitdist(derlius, distr = &#39;lnorm&#39;) Sukurkite log-normalųjį modelį ir jį patyrinėkite aukščiau išvardintomis funkcijomis (summary(), plot() ir kitomis). Nuspręskite, kuris modelis – normalusis ar log-normalusis – šiems duomenims labiau tinka? (Tam papildomai reikia susikurti normalųjį modelį.) 11.3 Kelių modelių palyginimas (paketas fitdistrplus) Palyginimas grafiškai Duomenys toxocara – salose gyvenančių laukinių kačių parazitų tyrimas. data(toxocara) parazitu_skaicius &lt;- toxocara$number hist(parazitu_skaicius) summary(parazitu_skaicius) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 0.000 2.000 8.679 9.000 75.000 Grafiškai patikrinkime, kuris teorinis modelis labiau tinka parazitų skaičių katėse aprašyti – Puasono ar neigiamas binominis? # Modelių kūrimas model_p &lt;- fitdist(parazitu_skaicius, &quot;pois&quot;) model_nb &lt;- fitdist(parazitu_skaicius, &quot;nbinom&quot;) # Sudarome modelių sąrašą modeliu_sarasas &lt;- list(model_p, model_nb) # Susirašome modelių pavadinimus pavadinimai &lt;- c(&quot;Puasono&quot;, &quot;Neigiamas binominis&quot;) Palyginame grafiškai: plot(model_p) plot(model_nb) Lyginame grafiškai viename grafike (naudojant firdistrplus, diskretiesiems duomenims yra mažiau grafinio atvaizdavimo galimybių nei tolydiesiems): cdfcomp(modeliu_sarasas, legendtext = pavadinimai) Atrodo, kad neigiamas binominis modelis (žalia linija) labiau atitinka empirinius duomenis (juodi taškai), nei Puasono modelis (raudona linija). qqcomp(modeliu_sarasas, legendtext = pavadinimai) Jei išbandytumėte, pastebėtumėte, kad dvi kitos funkcijos nėra tinkamos mūsų turimiems diskretiesiems duomenims lyginti su teoriniais modeliais. denscomp(modeliu_sarasas, legendtext = pavadinimai, demp = TRUE) ppcomp(modeliu_sarasas, legendtext = pavadinimai) Palyginimas naudojant skaitines statistikas Jei norite lyginti pagal skaitines statistikas, galite naudoti funkciją gofstat(): gofstat(modeliu_sarasas) ## Chi-squared statistic: 31256.96 7.48606 ## Degree of freedom of the Chi-squared distribution: 5 4 ## Chi-squared p-value: 0 0.1123255 ## the p-value may be wrong with some theoretical counts &lt; 5 ## Chi-squared table: ## obscounts theo 1-mle-pois theo 2-mle-nbinom ## &lt;= 0 14 0.009014207 15.295027 ## &lt;= 1 8 0.078236512 5.808596 ## &lt;= 3 6 1.321767215 6.845015 ## &lt;= 4 6 2.131297776 2.407815 ## &lt;= 9 6 29.827829221 7.835196 ## &lt;= 21 6 19.626223732 8.271110 ## &gt; 21 7 0.005631339 6.537242 ## ## Goodness-of-fit criteria ## 1-mle-pois 2-mle-nbinom ## Akaike&#39;s Information Criterion 1017.067 322.6882 ## Bayesian Information Criterion 1019.037 326.6288 Tam, kad būtų paprasčiau suprasti, kur kuris modelis, galite nurodyti pavadinimus: gofstat(modeliu_sarasas, fitnames = pavadinimai) ## Chi-squared statistic: 31256.96 7.48606 ## Degree of freedom of the Chi-squared distribution: 5 4 ## Chi-squared p-value: 0 0.1123255 ## the p-value may be wrong with some theoretical counts &lt; 5 ## Chi-squared table: ## obscounts theo Puasono theo Neigiamas binominis ## &lt;= 0 14 0.009014207 15.295027 ## &lt;= 1 8 0.078236512 5.808596 ## &lt;= 3 6 1.321767215 6.845015 ## &lt;= 4 6 2.131297776 2.407815 ## &lt;= 9 6 29.827829221 7.835196 ## &lt;= 21 6 19.626223732 8.271110 ## &gt; 21 7 0.005631339 6.537242 ## ## Goodness-of-fit criteria ## Puasono Neigiamas binominis ## Akaike&#39;s Information Criterion 1017.067 322.6882 ## Bayesian Information Criterion 1019.037 326.6288 Atrodo, neigiamas binominis skirstinys tinka labiau. Kaip apie tai nusprendžiau rašoma 11.1 skyriuje. 11.4 Jei duomenys pateikti kaip dažnių lentelė (fitdistrplus) Jei dirbate su diskrečiaisiais duomenimis ir turite dažnių lentelę, tada ją reikia pasiversti į vektorių naudojant funkciją rep(). Pavyzdys. Nuskaitome duomenis: library(data.table) duomenys &lt;- fread( &quot;x dažnis 0 26 1 43 2 48 3 42 4 29 5 6 6 5 8 1&quot;) Dažnių lentelę pasiverčiame į duomenų eilutę (vektorių): vektorius &lt;- rep(x = duomenys$x, times = duomenys$dažnis) Toliau su duomenis analizuojame įprastiniu būdu. model_poisson &lt;- fitdist(vektorius, distr = &quot;pois&quot;) plot(model_poisson) summary(model_poisson) ## Fitting of the distribution &#39; pois &#39; by maximum likelihood ## Parameters : ## estimate Std. Error ## lambda 2.245 0.1059481 ## Loglikelihood: -358.8056 AIC: 719.6111 BIC: 722.9094 coef(model_poisson) ## lambda ## 2.245 Užduotis 11.3 Duota dažnių lentelė (k – kintamojo reikšmės, Freq – dažnis). Ją reikia pasiversti į vektorių ir patikrinti, kuris modelis – Puasono, binominis ar neigiamas binominis – labiau tinkamas. Naudokite paketą fitdistrplus. k Freq 0 79 1 72 2 38 3 10 5 1 Pastaba: jei modeliuojant binominį skirstinį kils nesklandumų, jo nebemodeliuokite. Darbui su kategoriniais duomenimis patogesnė funkcija vcd::goodfit(). Deja, šių pratybų metu paketo vcd funkcijų nenagrinėsime. "],
["pi-klasikiniai.html", "12. Pasikliautinieji intervalai (PI) klasikiniais metodais 12.1 Paketas DescTools 12.2 Nubraižyti lentele pateiktus PI 12.3 Klasikiniai metodai PI skaičiuoti 12.4 Vidurkio PI 12.5 Proporcijos PI", " 12. Pasikliautinieji intervalai (PI) klasikiniais metodais Šio skyriaus medžiaga vis dar rengiama arba neatnaujinta šių metų kursui, todėl kol kas jos nenagrinėkite. Statistinės išvados yra pagal imties (kuri yra mažesnė už generalinę aibę) duomenis padarytos išvados apie visą generalinę aibę (GA). Tam, kad išvados būtų teisingos, – pirmiausia, imtis privalo būti reprezentatyvi: sudaryta tinkamu būdu taip, kad atspindėtų esmines generalinės aibės savybes. Tada pagal duomenis ir iškeltą klausimą reikia pasirinkti tinkamą analizės metodą. Atkreipkite dėmesį, kad daugelis statistikos metodų sukurti darant prielaidą, kad GA yra be galo didelė. Tad mūsų GA turi būti pakankamai didelė, kad ši prielaida galiotų. Statistinės išvados daromos: tikrinant statistines hipotezes (taikant statistinius kriterijus); sudarant įverčius (taškinius įverčius ir pasikliauties intervalus). Pasikliauties intervalai dar vadinami pasikliautinaisiais intervalais. Šio užsiėmimo metu nagrinėsime pasikliauties intervalų (PI) sudarymo metodus. Darbui reikalingi R paketai: data.table, DescTools, pander, ggplot2, tidyverse. Korektiško vidurkio pasikliauties intervalo skaičiavimo žingsniai: Nusibraižome duomenis, įsitikiname, kad vidurkis yra prasmingas; Patikriname, ar nepažeidžiamos prielaidos (pvz., ar duomenys skirstosi normaliai, ar jų pakankamai daug ir kt.), kuriomis grindžiamas statistinis modelis (intervalo skaičiavimo būdas); Skaičiuojame pasikliauties intervalą. Šie žingsniai pritaikomi ir kitų, ne tik vidurkio, pasikliauties intervalų skaičiavimui. Svarbu nusibraižyti duomenis, patikrinti prielaidas ir tik po to atlikti skaičiavimus. 12.1 Paketas DescTools Šis skyrelis skirtas tam, kad sužinotumėte, kad daugelio parametrų (vidurkio, proporcijos ir t.t.) pasikliautiniesiems intervalams (klasikiniais ir savirankos būdais) skaičiuoti skirtas funkcijas galite rasti pakete DescTools. Funkcijų pavyzdžiai: DescTools::MeanCI(x) DescTools::MeanDiffCI(x, y) DescTools::MedianCI(x) DescTools::PoissonCI(x) DescTools::VarCI(x) DescTools::Gmean(x, conf.level = 0.95) DescTools::Hmean(x, conf.level = 0.95) DescTools::BinomCI(x, n) DescTools::BinomDiffCI(x1, x2, n1, n2) DescTools::MultinomCI(x) Apžvelkime detaliau. set.seed(20190401) x &lt;- rnorm(n = 50, mean = 180, sd = 20) y &lt;- rnorm(n = 50, mean = 165, sd = 30) set.seed(20190401) gr_names &lt;- c(&quot;Didelis&quot;, &quot;Mažas&quot;) gr_1 &lt;- sample(gr_names, size = 50, replace = TRUE, prob = c(0.2, 0.8)) gr_2 &lt;- sample(gr_names, size = 50, replace = TRUE, prob = c(0.3, 0.7)) gr_names_2 &lt;- c(&quot;Žalios&quot;, &quot;Rudos&quot;, &quot;Mėlynos&quot;, &quot;Pilkos&quot;) gr_spalvos &lt;- sample(gr_names_2, size = 50, replace = TRUE) table(gr_spalvos) ## gr_spalvos ## Mėlynos Pilkos Rudos Žalios ## 8 11 10 21 Funkcijų, skirtų kiekybiniams duomenims, pavyzdžiai: DescTools::MeanCI(x) # Vidurkio PI DescTools::MeanDiffCI(x, y) # Skirtumo tarp dviejų vidurkių PI DescTools::MedianCI(x) # Medianos PI DescTools::VarCI(x) # Dispersijos PI DescTools::Gmean(x, conf.level = 0.95) # Geometrinio vidurkio PI DescTools::Hmean(x, conf.level = 0.95) # Harmoninio vidurkio PI Čia x ir y – skaitinių reikšmių vektoriai. Funkcijų, skirtų nominaliesiems duomenims, pavyzdžiai: DescTools::BinomCI(x, n) # Dvireikšmės proporcijos PI DescTools::BinomDiffCI(x1, x2, n1, n2) # Skirtumo tarp dvireikšmių proporcijų PI DescTools::BinomRatioCI(x1, x2, n1, n2) # Santykio tarp dvireikšmių proporcijų PI Čia x (x1, x2) – mus dominančių įvykių arba dominančios kategorijos narių skaičius (pirmoje ir antroje grupėse); n (n1, n2) – įvykių (pirmoje ir antroje grupėse) skaičius iš viso arba (pirmosios ir antrosios) imties dydis. Tiek x tiek n dažniausiai yra vienas skaičius. Šie skaičiai įprastai gaunami susidarius dažnių lentelę. DescTools::MultinomCI(x, method = &quot;goodman&quot;) # Daugiareikšmės proporcijos PI Čia x – vektorius su kiekvienos kategorijos dydžiu. Pvz.: x &lt;- c(30, 22, 39) arba x &lt;- c(&quot;juodas&quot; = 30, &quot;rudas&quot; = 22, &quot;žalias&quot; = 39) 12.2 Nubraižyti lentele pateiktus PI Dažna užduotis analizuojant duomenis – vizualizuoti pasikliauties intervalus. Sakykime, kad duota lentelė, kurioje taškinis vidurkio įvertis ir jo pasikliauties intervalas. Šiuos duomenis reikia įsikelti į „R“ ir nubraižyti. Lentelė 12.1: Duomenys, kuriuos norime nubraižyti (1). Vidurkis PIviršutinis PIapatinis 162.0 122.3 182.8 Lentelė pateikta tinklapyje, tad ją patogu nukopijuoti ir nuskaityti naudojant funkciją fread() iš paketo data.table. Užkraukime reikiamus paketus. library(data.table) library(tidyverse) Sys.setlocale(locale = &quot;Lithuanian&quot;) Po to parašykime komandą fread(&quot;&quot;), jos skliaustuose padėkime kabutes. Tada pele pažymėkite visą lentelės 12.1 turinį, jį nukopijuokite ir įklijuokite į dokumentą tarp kabučių kaip rodoma pavyzdyje žemiau. Galime pridėti papildomų tarpų, kad sulygiuotume stulpelius, bet tai nėra būtina. Įvykdykime komandą ir patikrinkime, ar duomenys nuskaityti teisingai. duomenys1 &lt;- fread( &quot;Vidurkis PIviršutinis PIapatinis 162.0 122.3 182.8&quot;) glimpse(duomenys1) ## Observations: 1 ## Variables: 3 ## $ Vidurkis &lt;dbl&gt; 162 ## $ PIviršutinis &lt;dbl&gt; 122.3 ## $ PIapatinis &lt;dbl&gt; 182.8 duomenys1 ## Vidurkis PIviršutinis PIapatinis ## 1: 162 122.3 182.8 Kopijuojant lentelę iš tinklapio, stulpelių skirtukai yra tabuliacijos, kurias fread() atpažįsta automatiškai. Todėl lentelę nuskaito teisingai. Dabar šiuos duomenis atvaizduokime naudodami ggplot2. Paklaidų ir intervalų braižymui naudinga funkcija geom_errorbar(), kuriai reikia nurodyti apatinę ir viršutinę ribas, kurios surašytos atskirame duomenų lentelės stulpelyje. Turime tik vieną grupę, todėl x’ui suteikiame bet kokį pavadinimą kabutėse. ggplot(duomenys1, aes(x = &quot;duomenys&quot;)) + geom_point(aes(y = Vidurkis)) + geom_errorbar(aes(ymin = PIviršutinis, ymax = PIapatinis)) Šiek tiek padailinkime grafiką: ggplot(duomenys1, aes(x = &quot;duomenys&quot;)) + geom_point(aes(y = Vidurkis), size = 4) + geom_errorbar(aes(ymin = PIviršutinis, ymax = PIapatinis), width = .1, size = 1) + lims(y = c(100, 200)) + labs(x = &quot;&quot;) Apibendrinančias statistikas, tokias kaip vidurkis ar mediana, duomenų vizualizavimo ekspertai rekomenduoja atvaizduoti taškais ar linijomis, bet ne stulpeliais. Vidurkius ir medianas stulpeliais atvaizduoti nekorektiška, nes taip akcentuojama apatinė matavimo skalės dalis, kur duomenų galbūt nėra, ir ignoruojama viršutinė dalis, kur duomenys yra. Deja, centro padėties suvestinų atvaizdavimo būdas stulpeliais plačiai paplitęs. Lentelė 12.2: Duomenys, kuriuos norime nubraižyti (2): vidurkis ir jo pasikliautinasis intervalas. Sveikosios ir dešimtosios skaičiaus dalies skirtukas – kablelis. Vidurkis PIvirš PIapat 42,53 41,02 44,01 Jei sveikosios ir dešimtosios dalies skirtukas yra kablelis (pavyzdys – lentelė 12.2), programa automatiškai jo neatpažįsta, tad tai reikia nurodyti naudojant parametrą dec: duomenys2 &lt;- fread(dec = &quot;,&quot;, &quot;Vidurkis PIvirš PIapat 42,53 41,02 44,01&quot;) glimpse(duomenys2) ## Observations: 1 ## Variables: 3 ## $ Vidurkis &lt;dbl&gt; 42.53 ## $ PIvirš &lt;dbl&gt; 41.02 ## $ PIapat &lt;dbl&gt; 44.01 duomenys2 ## Vidurkis PIvirš PIapat ## 1: 42.53 41.02 44.01 Užduotis 12.1 Ką tik nuskaitytus duomenis „duomenys2“ atvaizduokite grafiškai. Lentelė 12.3: Duomenys, kuriuos norime nubraižyti (3): vidurkis ir jo pasikliautinasis intervalas grupėms. Grupė Vidurkis PIviršutinis PIapatinis Balti 25 22 28 Žali 19 17 24 Raudoni 45 30 52 Geltoni 33 30 36 Jei norime, kad fread() tekstinius kintamuosius nuskaitytų kaip kategorinius, reikia naudoti parametrą stringsAsFactors = TRUE: duomenys3 &lt;- fread(stringsAsFactors = TRUE, &quot;Grupė Vidurkis PIviršutinis PIapatinis Balti 25 22 28 Žali 19 17 24 Raudoni 45 30 52 Geltoni 33 30 36&quot;) glimpse(duomenys3) ## Observations: 4 ## Variables: 4 ## $ Grupė &lt;fct&gt; Balti, Žali, Raudoni, Geltoni ## $ Vidurkis &lt;int&gt; 25, 19, 45, 33 ## $ PIviršutinis &lt;int&gt; 22, 17, 30, 30 ## $ PIapatinis &lt;int&gt; 28, 24, 52, 36 duomenys3 ## Grupė Vidurkis PIviršutinis PIapatinis ## 1: Balti 25 22 28 ## 2: Žali 19 17 24 ## 3: Raudoni 45 30 52 ## 4: Geltoni 33 30 36 Užduotis 12.2 Ką tik nuskaitytus duomenis nuskaitykite dar kartą naudodami stringsAsFactors = FALSE, rezultatą pavadinkite „duomenys3chr“. Palyginkite, kuo skiriasi „duomenys3“ ir „duomenys3chr“. Bazinis kodas atvaizduoti duomenis. Pastebėkite, kad x ašyje išdėstytos stulpelio Grupė reikšmės, todėl šio stulpelio pavadinimas rašomas ne kabutėse. ggplot(duomenys3, aes(x = Grupė)) + geom_point(aes(y = Vidurkis)) + geom_errorbar(aes(ymin = PIviršutinis, ymax = PIapatinis)) Pagražintas grafikas: ggplot(duomenys3, aes(x = Grupė, color = Grupė)) + geom_errorbar(aes(ymin = PIviršutinis, ymax = PIapatinis), width = 0.2, size = 1) + geom_point(aes(y = Vidurkis), fill = &quot;black&quot;, size = 2, shape = 23) + labs(title = &quot;Vidurkis ir jo 95% pasikliauties intervalas&quot;) Užduotis 12.3 Lentelė 12.4: Nuskaitykite ir vizualizuokite duomenis. Lentelė 12.5: Nuskaitykite duomenis. Proporcijas ir jų pasikliauties intervalus atvaizduokite stulpeliais (geom_col()). Stulpelio spalva turi būti parinkta pagal medžio rūšį (Tree), o stulpelio apvadas privalo būti juodas. Įvardinkite, trūkumus, kuriuos pastebite šioje lentelėje. Lentelė 12.4: Plauko ilgio pasiskirstymas pagal spalvas. Spalva Vidurkis PI_viršutinis PI_apatinis Juoda 5,9 5,7 6,4 Ruda 5,5 5,2 5,8 Gelsva 5,3 4,9 5,6 Lentelė 12.5: Rūšinis medžių pasiskirstymas miške. Tree Count Total Proportion lower_ci upper_ci 1 Douglas fir 70 156 0.4487 0.369115906 0.53030534 2 Ponderosa pine 79 156 0.5064 0.425290653 0.58728175 3 Grand fir 3 156 0.0192 0.003983542 0.05516994 4 Western larch 4 156 0.0256 0.007029546 0.06434776 Jei lentelė 12.5 būtų pateikta tokiu pavidalu, kokį matote žemiau (be tabuliacijų), tada stulpelių, kuriuose yra keli žodžiai atskirti tarpu, reikšmes privalėtumėte rašyti kabutėse, pvz., &quot;Douglas fir&quot; arba \\&quot;Douglas fir\\&quot;. Kitu atveju duomenys būtų nuskaityti neteisingai arba apskritai nebūtų nuskaityti. ## V1 Tree Count Total Proportion lower_ci upper_ci ## 1: 1 Douglas fir 70 156 0.4487 0.369115906 0.53030534 ## 2: 2 Ponderosa pine 79 156 0.5064 0.425290653 0.58728175 ## 3: 3 Grand fir 3 156 0.0192 0.003983542 0.05516994 ## 4: 4 Western larch 4 156 0.0256 0.007029546 0.06434776 Jei stulpelyje yra keli žodžiai, juos reikia įterpti į papildomas dvigubas kabutes. Jei neįterpiama – nuskaitoma neteisingai: neteisingai &lt;- fread( &quot;Pavadinimas Reikšmė Pirmas 1 Du žodžiai 2 Keli žodžiai 3 &quot;) ## Warning in fread(&quot;Pavadinimas Reikšmė\\nPirmas 1\\nDu žodžiai 2\\nKeli žodžiai ## 3\\n&quot;): Stopped early on line 3. Expected 2 fields but found 3. Consider ## fill=TRUE and comment.char=. First discarded non-empty line: &lt;&lt;Du žodžiai ## 2&gt;&gt; neteisingai ## Pavadinimas Reikšmė ## 1: Pirmas 1 Keli variantai, kaip nuskaitymą atlikti teisingai: Visą tekstą dėti į viengubas kabutes, o reikiamų stulpelių reikšmes – į dvigubas: teisingai1 &lt;- fread( &#39;Pavadinimas Reikšmė Pirmas 1 &quot;Du žodžiai&quot; 2 &quot;Keli žodžiai&quot; 3 &#39;) teisingai1 ## Pavadinimas Reikšmė ## 1: Pirmas 1 ## 2: Du žodžiai 2 ## 3: Keli žodžiai 3 Visą tekstą dėti į dvigubas kabutes, o prieš stulpeliuose esančias dvigubas kabutes pridėti atgal pasvirusį brūkšnį (\\), kaip parodyta šiame pavyzdyje: teisingai2 &lt;- fread( &quot;Pavadinimas Reikšmė Pirmas 1 \\&quot;Du žodžiai\\&quot; 2 \\&quot;Keli žodžiai\\&quot; 3 &quot;) teisingai2 ## Pavadinimas Reikšmė ## 1: Pirmas 1 ## 2: Du žodžiai 2 ## 3: Keli žodžiai 3 12.3 Klasikiniai metodai PI skaičiuoti 12.4 Vidurkio PI Klasikiniai PI sudarymo metodai įprastai grindžiami prielaida, kad duomenys yra normalieji. Tokiems duomenis puikiai tinka įvairūs teoriniai modeliai, išvedamos formulės. Pliusai. Turint formulę, galima ją pertvarkyti taip, kad būtų galima apskaičiuoti bet kurį jos narį. Skaičiavimai atliekami greitai. Minusai. Reikia tenkinti normalumo ir kitas prielaidas. Tinka tik kai kurioms statistikoms, tokioms kaip vidurkis. Tačiau kvartiliams ir panašioms neparametrinėms statistikoms – tokių formulių nėra. Panagrinėkime pirmą pavyzdį. Iš normaliojo skirstinio su vidurkiu 50 ir standartiniu nuokrypiu 10 sugeneruoti duomenys: set.seed(98) x &lt;- rnorm(50, mean = 50, sd = 10) library(pander) panderOptions(&quot;keep.trailing.zeros&quot;, TRUE) RcmdrMisc::normalityTest(x, test = &quot;shapiro.test&quot;) ## ## Shapiro-Wilk normality test ## ## data: x ## W = 0.9601, p-value = 0.08974 Shapiro-Wilk kriterijumi testuojamas pasiskirstymo normalumas. Jei \\(p \\ge 0.05\\), tai skaitoma, kad nuokrypis nuo normalumo nėra statistiškai reikšmingas ir normalumo prielaida galioja. Jei turėtume labai dideles imtis, net maži nuokrypiai būtų pripažįstami statistiškai reikšmingais (t.y., nuokrypiai, stebimi duomenyse, tikėtina, egzistuoja ir visoje generalinėje aibėje). Tokiu atveju normalumas papildomai testuojamas grafiškai naudojant kvantilių-kvantilių diagramą (qq-grafiką), norint patikrinti, ar tas nuokrypis ne tik statistiškai, bet ir praktiškai reikšmingas. car::qqPlot(x) ## [1] 42 36 qplot(x, geom = &quot;histogram&quot;, bins = 6, color = I(&quot;black&quot;)) Visiškai normalieji duomenys išsidėsto į vieną tiesę. Nukrypimai nuo jos rodo nuokrypius nuo normaliojo pasiskirstymo. Natūralu, jei grafiko galuose atsiras vienas kitas šiek tiek nuo tiesės nukrypęs taškas. Ypač svarbu, kad tarp 1 ir 3 kvartilio esantys taškai išsidėstytų daugmaž vienoje tiesėje. (Apie šį grafiką rekomenduoju daugiau informacijos susirasti savarankiškai, naudingos nuorodos: nuoroda 1, nuoroda 2) Turint tik duomenų imtį (duomenis)ir jokios kitos papildomos informacijos), vidurkio PI skaičiavimas pagal Stjudento t-skirstiniu pagrįstą formulę yra universaliausias, jei duomenys normalieji: # 95% vidurkio pasikliauties intervalas DescTools::MeanCI(x = x) ## mean lwr.ci upr.ci ## 47.21401 44.38835 50.03966 Savirankos \\(BC_a\\) metodu vidurkio CI gali būti apskaičiuotas paketo DescTools funkcijas: set.seed(123456) DescTools::MeanCI(x = x, method = &quot;boot&quot;, type = &quot;bca&quot;, R = 2000) ## mean lwr.ci upr.ci ## 47.21401 44.48821 49.85862 Apie savirankos metodus ir čia naudotus parametrus bus daugiau aprašyta kitose šios pamokos skyriuose. 12.4.1 Vidurkio PI, kai GA dispersija žinoma Kai generalinės aibės dispersija žinoma, vidurkio PI galima skaičiuoti pagal formulę (12.1). Situacija, kai tikrasis vidurkis nežinomas, o išsisklaidymas aplink jį – dispersija – žinoma, yra tik hipotetinė. Tačiau formulė ganėtinai paprasta ir mokymosi tikslais iliustruoti, kaip konstruojamas PI, tinkama. Ši formulė taip pat naudojama, kai imties dydis pakankamai didelis. \\[\\begin{equation} \\hat{\\mu}_{1,2} = \\overline{X} \\mp z_{\\left(\\frac{1-Q}{2}\\right)}{\\sigma \\over \\sqrt{n}} \\tag{12.1} \\end{equation}\\] Formulėje: \\(\\hat{\\mu}_{1}\\) – apatinė vidurkio pasikliauties intervalo riba (mažesnis skaičius); \\(\\hat{\\mu}_{2}\\) – viršutinė vidurkio pasikliauties intervalo riba (didesnis skaičius); \\(\\overline{X}\\) – imties vidurkis; \\(\\sigma\\) – generalinės aibės standartinis nuokrypis (arba imties standartinis nuokrypis, jei duomenų pakankamai daug); \\(n\\) – imties dydis; \\(Q\\) – pasikliovimo lygmuo (tikimybė); \\({\\left(\\frac{1-Q}{2}\\right)}\\) – galime pažymėti kaip tikimybę \\(\\alpha\\); \\(z_{\\alpha}\\) – \\(z\\) koeficientas – daugiklis, dar vadinamas standartinio normaliojo skirstinio \\(1-\\alpha\\) lygmens kvantiliu (skaičius, priklausantis nuo norimo pasikliovimo lygmens). Jis imamas iš lentelių arba apskaičiuojamas programomis R, GeoGebra ar kitomis. Ši formulė tinka normaliai pasiskirsčiusiems duomenims, arba duomenims, kurių yra tiek daug, kad galioja centrinė ribinė teorema. Formulė susideda iš 3 dalių: taškinis vidurkio įvertis, koeficientas, priklausantis nuo norimo pasikliovimo lygmens, ir standartinė vidurkio paklaida. Ar matote jas visas? Siekiant apsiskaičiuoti reikiamą imties dydį, kad būtų pasiektas norimas tikslumas (intervalo ilgis), gali būti naudojama iš (12.1) formulės išvesta lygtis (12.3). Formulė su \\(z\\) koeficientu tinkama tada, kai žinome tikrąją generalinės aibės dispersiją \\((\\sigma^2)\\). Arba imtyje duomenų pakankamai daug – vienų autorių teigimu \\(n&gt;50\\), kitų – \\(n&gt;30\\). Galima alternatyva, kai imtis maža, bet pasiskirsčiusi normaliai – formulė, kurioje naudojamas \\(t\\) koeficientas. Jei norite skaičiuoti automatiškai, štai R kodas: data(npk) derlius &lt;- npk$yield # --- Keisti tik šias eilutes ------------------------------------------------ # Pasirenkame duomenų vektorių `x` ir pasikliovimo lygmenį – tikimybę `Q`. # Jei turite suvestinę, vietoje `x` įrašykite kintamųjų # `n`, `st_nuokrypis` ir `vidurkis` reikšmes. x &lt;- derlius Q &lt;- 0.95 # ---------------------------------------------------------------------------- n &lt;- length(x) st_nuokrypis &lt;- sd(x) vidurkis &lt;- mean(x) # --- Toliau esančio kodo nekeisti ------------------------------------------- # Taikome formulę su z koeficientu: z &lt;- qnorm((1 - Q) / 2, lower.tail = FALSE) paklaida &lt;- z * st_nuokrypis/sqrt(n) apatinė_riba &lt;- vidurkis - paklaida viršutinė_riba &lt;- vidurkis + paklaida # Rezultatai: vidurkio_pi_z &lt;- c(vidurkis = vidurkis, PI_apatine_riba = apatinė_riba, PI_virsutine_riba = viršutinė_riba) # ---------------------------------------------------------------------------- Rezultatas: vidurkio_pi_z ## vidurkis PI_apatine_riba PI_virsutine_riba ## 54.87500 52.40543 57.34457 Iki vieno skaičiaus po kablelio suapvalintas rezultatas: round(vidurkio_pi_z, digits = 1) ## vidurkis PI_apatine_riba PI_virsutine_riba ## 54.9 52.4 57.3 Užduotis 12.4 Išmatuotas \\(100\\) studentų cholesterolio kiekis kraujyje. Gautas vidurkis \\(310\\frac{\\mu mol}{l}\\). Koks cholesterolio kiekio kraujyje vidurkio \\(95\\%\\) pasikliauties intervalas, jeigu šio dydžio standartinis nuokrypis studentų populiacijoje yra \\(35\\frac{\\mu mol}{l}\\)? 12.4.2 Vidurkio PI, kai GA dispersija nežinoma Kai GA dispersija nežinoma, tada vidurkio PI skaičiavimo formulėje naudojame dispersiją, apskaičiuotą iš duomenų. Tokiu atveju vietoje z koeficiento reikia naudoti t koeficientą, kurio dydis priklauso nuo imties dydžio. Tad tokia formulė kaip (12.2) savo surinktiems duomenims analizuoti yra naudingesnė. \\[\\begin{equation} \\hat{\\mu}_{1,2} = \\overline{X} \\mp t_{\\left(\\frac{1-Q}{2}\\right)}(n-1) {S \\over \\sqrt{n}} \\tag{12.2} \\end{equation}\\] Formulėje: \\(\\hat{\\mu}_{1}\\) – apatinė vidurkio pasikliauties intervalo riba (mažesnis skaičius); \\(\\hat{\\mu}_{2}\\) – viršutinė vidurkio pasikliauties intervalo riba (didesnis skaičius); \\(\\overline{X}\\) – imties vidurkis; \\(S\\) – imties standartinis nuokrypis; \\(n\\) – imties dydis; \\(Q\\) – pasikliovimo lygmuo (tikimybė); \\({\\left(\\frac{1-Q}{2}\\right)}\\) – galime pažymėti kaip tikimybę \\(\\alpha\\); \\(t_{\\alpha}(n-1)\\) – daugiklis, dar vadinamas Stjudento koeficientu arba Stjudento skirstinio (su \\(n-1\\) laisvės laipsnių) \\(1-\\alpha\\) lygmens kvantiliu (skaičius, priklausantis nuo norimo pasikliovimo lygmens). Jis imamas iš lentelių arba apskaičiuojamas programomis R, GeoGebra ar kitomis. Ši formulė tinka normaliai pasiskirsčiusiems duomenims, arba duomenims, kurių yra tiek daug, kad galioja centrinė ribinė teorema. Pamenat, formulė susideda iš 3 dalių. Ar ir šiuo atveju matote jas visas? Štai R kodas, jei norite, kad R apskaičiuotų už jus: data(npk) derlius &lt;- npk$yield # --- Keisti tik šias eilutes ------------------------------------------------ # Pasirenkame duomenų vektorių `x` ir pasikliovimo lygmenį – tikimybę `Q`. # Jei turite suvestinę, vietoje `x` įrašykite kintamųjų # `n`, `st_nuokrypis` ir `vidurkis` reikšmes. x &lt;- derlius Q &lt;- 0.95 # ---------------------------------------------------------------------------- n &lt;- length(x) st_nuokrypis &lt;- sd(x) vidurkis &lt;- mean(x) # --- Toliau esančio kodo nekeisti ------------------------------------------- # Taikome formulę su t koeficientu: t &lt;- qt((1 - Q) / 2, df = (n - 1), lower.tail = FALSE) paklaida &lt;- t * st_nuokrypis/sqrt(n) apatinė_riba &lt;- vidurkis - paklaida viršutinė_riba &lt;- vidurkis + paklaida vidurkio_pi_t &lt;- c(vidurkis = vidurkis, PI_apatine_riba = apatinė_riba, PI_virsutine_riba = viršutinė_riba) # ---------------------------------------------------------------------------- Rezultatas: vidurkio_pi_t ## vidurkis PI_apatine_riba PI_virsutine_riba ## 54.87500 52.26848 57.48152 Iki vieno skaičiaus po kablelio suapvalintas rezultatas: round(vidurkio_pi_t, digits = 1) ## vidurkis PI_apatine_riba PI_virsutine_riba ## 54.9 52.3 57.5 Formulė su \\(t\\) koeficientu yra universalesnė, tinka, kai duomenų nedaug. Visgi, jų turi būti pakankamai, o ne vos keli taškai. Jei taškų iki 15 – pasiskirstymas privalo būti idealiai normalusis. Užduotis 12.5 Užsikraukite duomenis, naudodami komandą data(swiss). Duomenų lentelė swiss: Apskaičiuokite kintamojo Fertility reikšmių vidurkio 95% pasikliauties intervalą. Ar šie duomenys tenkina prielaidas vidurkio pasikliauties intervalui skaičiuoti naudojant formulę? Rcmdr vidurkio PI skaičiavimui Vidurkio pasikliauties intervalą pagal (12.2) lygtį galime skaičiuoti naudodami Rcmdr įskiepį RcmdrPlugin.EZR.as.menu (diegimo instrukcijos šios knygos prieduose). Užkrovus šį įskiepį atsiranda mygtukas pavadinimu „EZR“ (pav. 12.1). Pav. 12.1: RcmdrPlugin.EZR.as.menu meniu mygtukas R Commander meniu juostoje. Pav. 12.2: Vidurkio pasikliauties intervalo skaičiavimas pagal (12.2) formulę naudojant Rcmdr. Atsidariusioje lentelėje įrašome reikiamus skaičius: vidurkį, standartinį nuokrypį ir imties dydį. Sveikąją ir dešimtąją skaičiaus dalį reikia atskirti tašku (pvz., 10.254), o ne kableliu. 12.4.3 Imties dydžio skaičiavimas norimam vidurkio PI ilgiui Iš formulės (12.1) galima išsireikšti imties dydį, kurio reikia norimam tikslumui pasiekti. Tai aprašo lygtis (12.3): \\[\\begin{equation} n = \\left( {2 \\cdot \\sigma\\cdot z_{\\left(\\frac{1-Q}{2}\\right)} } \\over \\Delta\\hat{\\mu} \\right)^2 \\tag{12.3} \\end{equation}\\] Formulėje: \\(n\\) – imties dydis; \\(\\Delta\\hat{\\mu}\\) – vidurkio pasikliauties intervalo ilgis; \\(\\sigma\\) – (hipotetinis) standartinis nuokrypis; \\(Q\\) – pasikliovimo lygmuo (tikimybė); \\({\\left(\\frac{1-Q}{2}\\right)}\\) – galime pažymėti kaip tikimybę \\(\\alpha\\); \\(z_{\\alpha}\\) – \\(z\\) koeficientas – daugiklis, dar vadinamas standartinio normaliojo skirstinio \\(1-\\alpha\\) lygmens kvantiliu (skaičius, priklausantis nuo norimo pasiliovimo lygmens). Rezultatą apvaliname iki sveikųjų skaičių į didesniąją pusę, tarkim 60,02 → 61. Kitu atveju intervalas bus per trumpas. Šio tipo skaičiavimą galima atlikti papildiniu Rcmdr (pav. 12.3). Pav. 12.3: Papildinio RcmdrPlugin.EZR.as.menu naudojimas reikiamo imties dydžio skaičiavimui norimam pasikliauties intervalo pločiui gauti. Užduotis 12.6 Išmatuota 93 studentų cholesterolio koncentracija kraujyje. Gautas vidurkis yra \\(308\\frac{\\mu mol}{l}\\). Koks yra cholesterino kiekio kraujyje 99% pasikliauties intervalas, jeigu imties standartinis nuokrypis – \\(35\\frac{\\mu mol}{l}\\)? Kokio imties dydžio reikia, kad intervalo ilgis būtų \\(30\\frac{\\mu mol}{l}\\)? Kokio imties dydžio reikia, kad intervalo ilgis būtų \\(2\\) vienetais mažesnis, nei gautas (a) punkte? 12.5 Proporcijos PI Kategoriniai kintamieji gali būti skirstomi į: dvireikšmius – galinčius įgyti dvi skirtingas reikšmes, pvz., gėrimas tik „šiltas“ arba „šaltas“ \\((k = 2)\\); daugiareikšmius – galinčius įgyti daugiau nei 2 skirtingas reikšmes, pvz., driežas „raudonas“, „juodas“, „geltonas“, „žalias“ \\((k &gt; 2)\\). Čia \\(k\\) – kategorijų skaičius. Todėl proporcijos taipogi skirstomos į dvireikšmių kintamųjų proporcijas (arba binominėmis proporcijomis, angl., binomial proportion) ir daugiareikšmių kintamųjų proporcijas (arba multinominėmis proporcijomis, angl., binomial proportion) Primenu, kad norint skaičiuoti PI imtis turi būti sudaryta atsitiktinai. kitaip PI neturi prasmės. Pradedantiesiems rekomenduojama tokia proporcijos PI pasirinkimo schema: kai \\(k=2\\) rinkitės koreguotą Wilson metodą. Jis tinka ir tada, kai proporcija p maža (netoli 0) arba didelė (netoli 1). kai \\(k&gt;2\\) ir kai kiekvienoje grupėje bent po 6 (geriausia bent po 10) narių ir grupių skaičius ne per didelis (sakykim, \\(k&lt;10\\)), rinkitės Goodman metodą (šis metodas tinkamas daugeliui praktiškai pasitaikančių situacijų); kai \\(k&gt;2\\) kiekvienoje grupėje daugmaž vienodas skaičius narių, rinkitės Sison-Glaz metodą. Metodas ypač tinka tada, kai grupėse narių mažai, o grupių labai daug. Bet jei yra bent viena pagal narių skaičių dominuojanti grupė, tada metodas duoda prastus rezultatus ir jo reiktų nesirinkti. Šie metodai pasiekiami naudojant paketo DescTools funkcijas. Norint naudoti binominės proporcijos metodus, reikia žinoti, kiek mūsų imtyje yra narių iš viso (n), ir kiek iš jų turi mums dominančią savybę (x). x &lt;- 30 # Imtyje pasitaikiusių šaltų gėrimų skaičius n &lt;- 66 # Imties dydis # Wilson metodas: DescTools::BinomCI(x, n, method = &quot;wilson&quot;) ## est lwr.ci upr.ci ## [1,] 0.4545455 0.3402413 0.5738499 # Koreguotas Wilson metodas: DescTools::BinomCI(x, n, method = &quot;modified wilson&quot;) ## est lwr.ci upr.ci ## [1,] 0.4545455 0.3402413 0.5738499 Rezultatas yra matrica (todėl vėliau ją versime į duomenų lentelę), kurios stulpeliai: est – proporcijos taškinis įvertis, lwr.ci ir upr.ci – proporcijos pasikliauties intervalo apatinė ir viršutinė ribos. Multinominių proporcijų skaičiavimui reikia žinoti, kiek kurios grupės narių pasitaikė. # Imtyje pasitaikė 24 juodi, 52 raudoni, 26 žali ir 43 geltoni driežiukai x_2 &lt;- c(24, 52, 26, 43) DescTools::MultinomCI(x_2, method = &quot;goodman&quot;) ## est lwr.ci upr.ci ## [1,] 0.1655172 0.09685563 0.2683888 ## [2,] 0.3586207 0.25715494 0.4745463 ## [3,] 0.1793103 0.10742403 0.2839959 ## [4,] 0.2965517 0.20314729 0.4107643 Kiekvienai grupei (juodi, raudoni, žali, geltoni) skirta atskira eilutė. # Imtyje pasitaikė 24 juodi, 22 raudoni, 26 žali ir 23 geltoni driežiukai x_3 &lt;- c(24, 22, 26, 23) DescTools::MultinomCI(x_3, method = &quot;sisonglaz&quot;) ## est lwr.ci upr.ci ## [1,] 0.2526316 0.1578947 0.3661081 ## [2,] 0.2315789 0.1368421 0.3450555 ## [3,] 0.2736842 0.1789474 0.3871608 ## [4,] 0.2421053 0.1473684 0.3555818 12.5.1 Pavyzdys 1: triušiai Sakykime, visiškai atsitiktinai sudarytoje imtyje 150 triušių ir 50 iš jų yra margi. Tad margų triušių dalies generalinėje aibėje 95% pasikliauties intervalas yra 0,26-0,41: (prop_pi &lt;- DescTools::BinomCI(x = 50, n = 150, method = &quot;wilson&quot;)) ## est lwr.ci upr.ci ## [1,] 0.3333333 0.2628876 0.4121024 prop_pi_df &lt;- as.data.frame(prop_pi) ggplot(prop_pi_df, aes(x = &quot;Margi triušiai&quot;)) + geom_col(aes(y = est), color = &quot;black&quot;, fill = &quot;skyblue1&quot;, width = 0.5) + geom_errorbar(aes(ymin = lwr.ci, ymax = upr.ci), size = 2, width = 0.1) + labs(x = &quot;&quot;, y = &quot;Dalis&quot;, title = &quot;Margų triušių dalis populiacijoje&quot;, subtitle = &quot;Įvertis ir 95% pasikliauties intervalas&quot;) 12.5.2 Pavyzdys 2: rasinė įvairovė library(tidyverse) library(DescTools) Įsikeliame duomenis. data(birthwt, package = &quot;MASS&quot;) Sudarome norimo požymio (rasės) dažnių lentelę. birthwt %&gt;% count(race) ## # A tibble: 3 x 2 ## race n ## &lt;int&gt; &lt;int&gt; ## 1 1 96 ## 2 2 26 ## 3 3 67 Rasių atžvilgiu duomenys buvo surinkti visiškai atsitiktinai, todėl pagal imtį galime spręsti apie pasiskirstymą generalinėje aibėje – sudaryti pasikliautinuosius intervalus. Rasių kodų reikšmės: 1 – baltoji rasė, 2 – juodoji rasė, 3 – kitos rasės. Norėdami išlaikyti grupių pavadinimus, duomenis pateikiame tokiu formatu – \"pavadinimas\" = skaičius: rasiu_pi_matrica &lt;- DescTools::MultinomCI( x = c(&quot;baltoji&quot; = 96, &quot;juodoji&quot; = 26, &quot;kitos&quot; = 67), method = &quot;goodman&quot;) rasiu_pi_matrica ## est lwr.ci upr.ci ## baltoji 0.5079365 0.42005803 0.5953273 ## juodoji 0.1375661 0.08730632 0.2100988 ## kitos 0.3544974 0.27499693 0.4429394 Duomenų matricą paverčiame į duomenų lentelę, eilučių pavadinimus perkeliame į stulpelį „rasė“. rasiu_pi_lentele &lt;- as.data.frame(rasiu_pi_matrica) %&gt;% rownames_to_column(&quot;rasė&quot;) rasiu_pi_lentele ## rasė est lwr.ci upr.ci ## 1 baltoji 0.5079365 0.42005803 0.5953273 ## 2 juodoji 0.1375661 0.08730632 0.2100988 ## 3 kitos 0.3544974 0.27499693 0.4429394 Duomenis atvaizduojame. ggplot(rasiu_pi_lentele, aes(x = rasė, color = rasė)) + geom_errorbar(aes(ymin = lwr.ci, ymax = upr.ci), width = 0.2, size = 1) + geom_point(aes(y = est), size = 2) + labs(title = &quot;Proporcija ir jos 95% pasikliauties intervalas&quot;) + ylim(0, 0.7) 12.5.3 Pavyzdys 3: grupės pagal ūgį Šiek tiek įdomesnis pavyzdys, kaip apsiskaičiuoti multinominės proporcijos pasikliauties intervalą iš duomenų. Kad būtų aiškiau, duomenis susigeneruokime. set.seed(100) ugiu_pogrupiai &lt;- data.frame( ugiai = c(rep(&quot;Aukštas&quot;, 80), rep(&quot;Vidutinis&quot;, 120), rep(&quot;Žemas&quot;, 100)), x = rnorm(n = 300, mean = 90, sd = 5), y = rnorm(n = 300, mean = 110, sd = 6)) glimpse(ugiu_pogrupiai) ## Observations: 300 ## Variables: 3 ## $ ugiai &lt;fct&gt; Aukštas, Aukštas, Aukštas, Aukštas, Aukštas, Aukštas, Au... ## $ x &lt;dbl&gt; 87.48904, 90.65766, 89.60541, 94.43392, 90.58486, 91.593... ## $ y &lt;dbl&gt; 98.86733, 103.88861, 103.72933, 106.09227, 112.29610, 11... head(ugiu_pogrupiai) ## ugiai x y ## 1 Aukštas 87.48904 98.86733 ## 2 Aukštas 90.65766 103.88861 ## 3 Aukštas 89.60541 103.72933 ## 4 Aukštas 94.43392 106.09227 ## 5 Aukštas 90.58486 112.29610 ## 6 Aukštas 91.59315 116.19140 dazniu_lentele &lt;- ugiu_pogrupiai %&gt;% group_by(ugiai) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(is_viso = sum(n)) pander(dazniu_lentele) ugiai n is_viso Aukštas 80 300 Vidutinis 120 300 Žemas 100 300 Dabartinė pander versija turi problemų su tarptautinių (t.p. ir lietuviškų) simbolių dekodavimu. rez &lt;- data.frame(DescTools::MultinomCI(x = dazniu_lentele$n, method = &quot;goodman&quot;)) pander(rez) est lwr.ci upr.ci 0.2667 0.2092 0.3333 0.4000 0.3334 0.4705 0.3333 0.2706 0.4026 Skaičių formatavimas gali būti vykdomas funkcija sprintf. Formatas %.2f: % reiškia, kad bus formato aprašymas .2 – du skaičiai po kablelio f – fiksuotas skaičių formatas (mūsų atveju, visą laiką 2 skaičiai po kablelio). rez %&gt;% transmute(pi_graziau = sprintf(&quot;%.2f (%.2f–%.2f)&quot;, est, lwr.ci, upr.ci)) ## pi_graziau ## 1 0.27 (0.21–0.33) ## 2 0.40 (0.33–0.47) ## 3 0.33 (0.27–0.40) Dabar visą analizę sujunkime į vieną grandinę. Joje yra funkcija do() kuri naudojama vietoje summarize(), kai vienu metu reikia apskaičiuoti daugiau nei vieną skaičių (šiuo atveju, proporcijos įvertį ir pasikliauties intervalą). prop_pi &lt;- ugiu_pogrupiai %&gt;% group_by(ugiai) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(is_viso = sum(n)) %&gt;% do(data.frame(ugiai = .$ugiai, n = .$n, DescTools::MultinomCI(x = .$n, method = &quot;goodman&quot;)) ) %&gt;% mutate(ivertis_graziau = sprintf(&quot;%.1f%%&quot;, 100*est), pi_graziau = sprintf(&quot;(%.1f–%.1f)&quot;, 100*lwr.ci, 100*upr.ci)) Rezultatas: glimpse(prop_pi) ## Observations: 3 ## Variables: 7 ## $ ugiai &lt;fct&gt; Aukštas, Vidutinis, Žemas ## $ n &lt;int&gt; 80, 120, 100 ## $ est &lt;dbl&gt; 0.2666667, 0.4000000, 0.3333333 ## $ lwr.ci &lt;dbl&gt; 0.2091875, 0.3333785, 0.2705523 ## $ upr.ci &lt;dbl&gt; 0.3332834, 0.4705376, 0.4026412 ## $ ivertis_graziau &lt;chr&gt; &quot;26.7%&quot;, &quot;40.0%&quot;, &quot;33.3%&quot; ## $ pi_graziau &lt;chr&gt; &quot;(20.9–33.3)&quot;, &quot;(33.3–47.1)&quot;, &quot;(27.1–40.3)&quot; head(prop_pi) ## ugiai n est lwr.ci upr.ci ivertis_graziau pi_graziau ## 1 Aukštas 80 0.2666667 0.2091875 0.3332834 26.7% (20.9–33.3) ## 2 Vidutinis 120 0.4000000 0.3333785 0.4705376 40.0% (33.3–47.1) ## 3 Žemas 100 0.3333333 0.2705523 0.4026412 33.3% (27.1–40.3) Pasikliauties intervalus nusibraižykime: ggplot(prop_pi, aes(x = ugiai, fill = ugiai)) + geom_col(aes(y = est), color = &quot;black&quot;, width = 0.5) + geom_errorbar(aes(ymin = lwr.ci, ymax = upr.ci), color = &quot;black&quot;, size = 1, width = 0.2) + geom_text(aes(y = -0.02, label = ivertis_graziau), fontface = &quot;bold&quot;) + geom_text(aes(y = -0.06, label = pi_graziau)) + coord_cartesian(ylim = c(-0.06, 0.55), expand = TRUE) + geom_hline(yintercept = 0, color = &quot;black&quot;, linetype = 2) + labs( x = &quot;Ūgio grupė&quot;, fill = &quot;Ūgio grupė&quot;, y = &quot;Procentinė dalis&quot;, title = &quot;Pasiskirstymas pagal ūgį&quot;, subtitle = &quot;Pasikliauties intervalai apskaičiuoti Goodman metodu&quot; ) + scale_y_continuous(labels = function(x){ paste0(100 * x, &quot;%&quot;) }) + theme_bw() Proporcijas vaizduoti stulpeliu yra korektiška. Bet vidurkį, medianą ir pan. – didelė klaida, nes atsiranda dviprasmybė. Jiems vietoje stulpelio rinkitės tašką. "],
["pi-saviranka.html", "13. Pasikliautinieji intervalai savirankos metodais 13.1 Paketas DescTools 13.2 Savirankos metodai 13.3 Teorinė medžiaga 13.4 Savirankos metodai ir imties dydis 13.5 Baziniai principai 13.6 Paketas „boot“", " 13. Pasikliautinieji intervalai savirankos metodais Šio skyriaus medžiaga neįtraukta į šių metų kursą, todėl jos nenagrinėkite. Statistinės išvados yra iš imties (kuri yra mažesnė už generalinę aibę) duomenų padarytos išvados apie visą generalinę aibę (GA). Tam, kad išvados būtų teisingos – pirmiausia, imtis privalo būti reprezentatyvi: sudaryta tinkamu būdu taip, kad atspindėtų esmines generalinės aibės savybes. Tada pagal duomenis ir iškeltą klausimą reikia pasirinkti tinkamą analizės metodą. Beje, daugelis statistikos metodų sukurti darant prielaidą, kad GA yra be galo didelė. Tad mūsų GA turi būti pakankamai didelė, kad ši prielaida galiotų. Statistinių išvadų darymo metodų grupės: statistinių kriterijų taikymas (t. y., statistiniai testai); taškinių įverčių skaičiavimas; pasikliauties intervalų (t. y., intervalinių įverčių) skaičiavimas. Pasikliauties intervalai dar vadinami pasikliautinaisiais intervalais. Šio užsiėmimo metu nagrinėsime pasikliauties intervalų (PI) sudarymo metodus. Darbui reikalingi reikalingi R paketai: boot, DescTools, pander, RcmdrMisc, car, ggplot2, tidyverse. 13.1 Paketas DescTools Šis trumpas skyrelis skirtas tam, kad sužinotumėte, kad daugelio parametrų (vidurkio, proporcijos ir t.t.) pasikliautiniesiems intervalams (klasikiniais ir savirankos būdais) skaičiuoti skirtas funkcijas galite rasti pakete DescTools. Funkcijų pavyzdžiai: DescTools::MeanCI(x) DescTools::MeanDiffCI(x, y) DescTools::MedianCI(x) DescTools::PoissonCI(x) DescTools::VarCI(x) DescTools::Gmean(x, conf.level = 0.95) DescTools::Hmean(x, conf.level = 0.95) DescTools::BinomCI(x, n) DescTools::BinomDiffCI(x1, x2, n1, n2) DescTools::MultinomCI(x) 13.2 Savirankos metodai Saviranka (angl. statistical bootstrap) – tai grąžintinis imies sudarymo būdas su pakartojimu. Savirankos metodai – tai neparametrinių (t.y., tuo teorinio skirstinio ir jo parametrų nepriklausomų) metodų šeima, skirta statistinėms išvadoms daryti. 13.3 Teorinė medžiaga Teorinės medžiagos galite rasti: Procentilių savirankos metodas su paslinktumo ir asimetrijos korekcija (\\(BC_a\\)) pasikliauties intervalams (PI) skaičiuoti (anglų kalba); Savirankos būdu apskaičiuoti PI: tinkamas ir netinkamas taikymas (anglų kalba); Savirankos būdu apskaičiuoti PI: principai (anglų kalba); Savirankos būdu apskaičiuoti PI: kaip atlikti? (R programos kodai, demonstruojantys skaičiavimo princinus) (anglų kalba); 13.4 Savirankos metodai ir imties dydis Savirankos metodai tinka ir mažoms imtims. Visgi, imties dydis turėtų būti pakankamai didelis, pvz., 20 ar daugiau tiriamųjų/stebėjimų. Kitu atveju gali būti gauti klaidingi rezultatai (įprastai pernelyg siauras intervalas) dėl mažo imties dydžio ir nepakankamai reprezentatyvios imties. Jei jūsų imtis itin maža, siūlau temą apie savirankos metodą ir imties dydį panagrinėti išsamiau. 13.5 Baziniai principai Šiame pavyzdyje pavaizduosiu patį paprasčiausią savirankos metodo pasikliauties intervalams taikyti variantą – savirankos procentilių metodą. Jis tinka statistikoms, tokioms kaip vidurkis (kai duomenys tenkina tam tikras sąlygas). Metodas tinkamas, kai jūsų imtyje arba tiriamame poaibyje yra bent 20 taškų. Kitu atveju intervalas bus per siauras. Naudosime duomenis (faithful), kuriuose registruotas laikas tarp geizerio išsiveržimų (waiting) ir išsiveržimo trukmė (eruptions). data(faithful) Hmisc::describe(faithful) %&gt;% Hmisc::html() .earrows {color:silver;font-size:11px;} fcap { font-family: Verdana; font-size: 12px; color: MidnightBlue } smg { font-family: Verdana; font-size: 10px; color: &#808080; } hr.thinhr { margin-top: 0.15em; margin-bottom: 0.15em; } span.xscript { position: relative; } span.xscript sub { position: absolute; left: 0.1em; bottom: -1ex; } faithful 2 Variables   272 Observations eruptions .hmisctable998352 { border: none; font-size: 85%; } .hmisctable998352 td { text-align: center; padding: 0 1ex 0 1ex; } .hmisctable998352 th { color: MidnightBlue; text-align: center; padding: 0 1ex 0 1ex; font-weight: normal; } nmissingdistinctInfoMeanGmd.05.10.25.50.75.90.95 272012613.4881.2661.8001.8522.1634.0004.4544.7004.817 lowest : 1.600 1.667 1.700 1.733 1.750 , highest: 4.933 5.000 5.033 5.067 5.100 waiting .hmisctable418583 { border: none; font-size: 85%; } .hmisctable418583 td { text-align: center; padding: 0 1ex 0 1ex; } .hmisctable418583 th { color: MidnightBlue; text-align: center; padding: 0 1ex 0 1ex; font-weight: normal; } nmissingdistinctInfoMeanGmd.05.10.25.50.75.90.95 2720510.99970.915.3748515876828689 lowest : 43 45 46 47 48 , highest: 91 92 93 94 96 Pasirenkam vieną kintamąjį x &lt;- faithful$waiting 13.5.1 Analizė: I etapas Iš turimos duomenų imties (o ne visos generalinės aibės, GA) pakartotinai imame imtis grąžintiniu imties sudarymo būdu (žemiau esančioje funkcijoje tai apibrėžia parametras replace = TRUE) – vykdome pakartotinę atranką (pakartotinai atrenkame, t. y., sudarome, imtis). Jas vadinkime pakartotinėmis imtimis (angl. resamples). Sudarykime \\(1\\cdot10^4\\) tokių imčių, kiekvienos jų dydis toks, kaip pradinės imties (\\(n\\)). Pakartotines imtis įrašykime į atskirą matricos eilutę. set.seed(1) n &lt;- length(x) # Rezultatas yra įrašomas į vektorių, # t.y., į vieną eilutę x_r &lt;- sample(x, replace = TRUE, size = 1e4 * n) # Vektorių paverčiame į matricą su n stulpelių # ir 1*10^4 eilučių. pakartotines_imtys &lt;- matrix(x_r, ncol = n) 13.5.2 Analizė: II etapas Kiekvienai eilutei (žemiau – MARGIN = 1, pagal ES taisyklę, 1 = E = eilutės, 2 = S = stulpeliai), t. y., pakartotinei imčiai, apskaičiuojame po vidurkį (FUN = mean). vidurkiai_saviranka &lt;- apply(pakartotines_imtys, MARGIN = 1, FUN = mean) Dabar turime 10 tūkst. vidurkių. Pasižiūrime į jų pasiskirstymą: car::qqPlot(vidurkiai_saviranka) ## [1] 876 5383 13.5.3 Analizė: III etapas Skirstinys yra pakankamai simetriškas Apskaičiuojame skirstinio kvantilius ties 2,5% ir 97,5% (tarp jų kaip tik telpa 95%). Tai ir bus pasikliauties intervalas (73.5-77.0). pasikliauties_intervalas &lt;- quantile(vidurkiai_saviranka, c(.025, 0.975)) pasikliauties_intervalas ## 2.5% 97.5% ## 69.27564 72.49642 Šie kvantiliai grafike atvaizduoti punktyrinėmis linijomis 13.6 Paketas „boot“ R turi specializuotą paketą boot skirtą savirankos metodu atlikti analizę. Jis įdiegiamas kartu su R, tačiau automatiškai neužkraunamas. Pavyzdžių, kaip naudoti šį paketą rasite šiame tinklapyje (nuoroda). library(boot) Naudotis pagrindinėmis funkcijomis ganėtinai intuityvu išskyrus tai, kad patiems reikia susidaryti norimos statistikos skaičiavimo funkciją θ(·). Ši funkciją privalo turėti 2 argumentus: pirmasis – duomenys, antrasis – indeksai. Pvz.: mean_boot &lt;- function(x, indeksai) { mean(x[indeksai]) } Šiame pavyzdyje naudosime procentilių savirankos metodą su paslinktumo ir asimetrijos korekcija (\\(BC_a\\), angl. bias corrected and accelerated) pasikliauties intervalui skaičiuoti. Sprendžiant nemažą dalį statistikos uždavinių, šis metodas laikomas vienu tiksliausių PI įvertinimui, nes, atliekant skaičiavimus, automatiškai atsižvelgiama į netikslumus, kylančius dėl statistikos skirstinio paslinktumo (angl. bias) ir asimetrijos. (Aišku, reiktų prisimininti, kad bet kokį statistinį įrankį naudojant „aklai“ ir iki galo nesuprantant, ką jis daro, galima pridaryti klaidų.) 13.6.1 Pavyzdys: vidurkio PI library(boot) duomenys &lt;- faithful glimpse(duomenys) ## Observations: 272 ## Variables: 2 ## $ eruptions &lt;dbl&gt; 3.600, 1.800, 3.333, 2.283, 4.533, 2.883, 4.700, 3.6... ## $ waiting &lt;dbl&gt; 79, 54, 74, 62, 85, 55, 88, 85, 51, 85, 54, 84, 78, ... Parašome reikiamą funkciją vidurkiui skaičiuoti: mano_vidurkis &lt;- function(d, i) { mean(d[i], na.rm = TRUE) } Analizė (I ir II etapai) Pasirenkame 1000 pakartojimų # Atkartojamumui set.seed(1) boot_rez &lt;- boot(duomenys$eruptions, statistic = mano_vidurkis, R = 1000) Pasižiūrime į tarpinius rezultatus boot_rez ## ## ORDINARY NONPARAMETRIC BOOTSTRAP ## ## ## Call: ## boot(data = duomenys$eruptions, statistic = mano_vidurkis, R = 1000) ## ## ## Bootstrap Statistics : ## original bias std. error ## t1* 3.487783 -0.003152077 0.06643604 Diagnostinis grafikas plot(boot_rez) Analizė (III etapas): pasikliauties intervalai Intervalai skaičiuojami keliais būdais. Mus labiausiai domina “bca” (t.y., \\(BC_a\\)). boot_ci_rez &lt;- boot.ci(boot.out = boot_rez, type = c(&quot;norm&quot;, &quot;basic&quot;, &quot;perc&quot;, &quot;bca&quot;)) boot_ci_rez ## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS ## Based on 1000 bootstrap replicates ## ## CALL : ## boot.ci(boot.out = boot_rez, type = c(&quot;norm&quot;, &quot;basic&quot;, &quot;perc&quot;, ## &quot;bca&quot;)) ## ## Intervals : ## Level Normal Basic ## 95% ( 3.361, 3.621 ) ( 3.355, 3.618 ) ## ## Level Percentile BCa ## 95% ( 3.358, 3.620 ) ( 3.368, 3.638 ) ## Calculations and Intervals on Original Scale Rezultatų objekto struktūra str(boot_ci_rez) ## List of 7 ## $ R : int 1000 ## $ t0 : num 3.49 ## $ call : language boot.ci(boot.out = boot_rez, type = c(&quot;norm&quot;, &quot;basic&quot;, &quot;perc&quot;, &quot;bca&quot;)) ## $ normal : num [1, 1:3] 0.95 3.36 3.62 ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:3] &quot;conf&quot; &quot;&quot; &quot;&quot; ## $ basic : num [1, 1:5] 0.95 975.98 25.03 3.36 3.62 ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:5] &quot;conf&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ percent: num [1, 1:5] 0.95 25.03 975.98 3.36 3.62 ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:5] &quot;conf&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ bca : num [1, 1:5] 0.95 37.26 984.53 3.37 3.64 ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:5] &quot;conf&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;bootci&quot; Matote, kad \\(BC_a\\) pasikliauties intervalai pasiekiami panaudojus tokį kodą: boot_ci_rez$bca[4:5] ## [1] 3.367887 3.637698 13.6.2 Pavyzdys: medianos PI duomenys &lt;- faithful mano_mediana &lt;- function(d, i) { median(d[i], na.rm = TRUE) } set.seed(1) boot_rez &lt;- boot(duomenys$eruptions, statistic = mano_mediana, R = 1000) Pasižiūrime į tarpinius rezultatus boot_rez ## ## ORDINARY NONPARAMETRIC BOOTSTRAP ## ## ## Call: ## boot(data = duomenys$eruptions, statistic = mano_mediana, R = 1000) ## ## ## Bootstrap Statistics : ## original bias std. error ## t1* 4 -0.017738 0.07703336 Diagnostinis grafikas plot(boot_rez) boot_ci_rez &lt;- boot.ci(boot.out = boot_rez, type = c(&quot;norm&quot;, &quot;basic&quot;, &quot;perc&quot;, &quot;bca&quot;)) boot_ci_rez ## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS ## Based on 1000 bootstrap replicates ## ## CALL : ## boot.ci(boot.out = boot_rez, type = c(&quot;norm&quot;, &quot;basic&quot;, &quot;perc&quot;, ## &quot;bca&quot;)) ## ## Intervals : ## Level Normal Basic ## 95% ( 3.867, 4.169 ) ( 3.900, 4.167 ) ## ## Level Percentile BCa ## 95% ( 3.833, 4.100 ) ( 3.800, 4.083 ) ## Calculations and Intervals on Original Scale 13.6.3 Pavyzdys: koreliacijos koeficiento PI duomenys &lt;- faithful Parašome reikiamą funkciją koeficientui skaičiuoti funkcija_kendall &lt;- function(d, i){ # Funkcija skaičiuoja Kendall koreliacijos koef. # tarp i-tųjų elementų. d2 &lt;- d[i,] cor(d2$eruptions, d2$waiting, method = &quot;kendall&quot;) } Taip pat funkciją, kuri iš bootci objekto paima tik \\(BC_a\\) būdu apskaičiuotas pasikliauties intervalo ribas. get_bca_ci &lt;- function(boot_ci_obj) { boot_ci_obj$bca[4:5] } Apskaičiuojame pasikliauties intervalą (2 skaičių po kablelio tikslumu). set.seed(1) # Atkartojamumui boot(duomenys, funkcija_kendall, R = 1000) %&gt;% boot.ci(type = &quot;bca&quot;) %&gt;% get_bca_ci() %&gt;% round(2) ## [1] 0.52 0.62 Tad Kendall’o \\(\\tau\\) koreliacijos koeficiento 95% pasikliauties intervalas yra nuo 0,52 iki 0,62. "],
["ht-ivadas.html", "14. Hipotezių tikrinimas: įvadas 14.1 Svarbiausios sąvokos 14.2 Prielaidos ir reikalavimai 14.3 Parametriniai ir neparametriniai kriterijai 14.4 Schemos metodams pasirinkti 14.5 Praktiniai patarimai 14.6 Rezultatų aprašymo principai", " 14. Hipotezių tikrinimas: įvadas Užsiėmimo tikslas – susipažinti su dažnai praktikoje naudojamais statistinių hipotezių tikrinimo metodais vienai ir dviems imtims. Jūsų mokymosi tikslai: Žinoti rekomenduojamus analizės žingsnius: Klausimas → Grafikas → Prielaidų tikrinimas → Analizė (tinkamo modelio parinkimas); Mokėti nusibraižyti grafiką, kuris pagal duomenis padėtų atsakyti į išsikeltą klausimą; Suprasti pagrindines su statistinių hipotezių tikrinimu susijusias sąvokas; Žinoti, kokias prielaidas reikia tikrinti, prieš atliekant daugelį analizių; Mokėti teisingai interpretuoti rezultatus pagal \\(p\\) reikšmę; Žinoti, kas yra efektas ir efekto dydis; Žinoti pagrindinius statistinės analizės rezultatų aprašymo principus. 14.1 Svarbiausios sąvokos Efektu galime pavadinti tai, ką tiriame: skirtumą, nuokrypį ar sąsają (ryšį) tarp kintamųjų. Efekto dydis – kiekybinis tiriamo dalyko (pvz., skirtumo dydžio, ryšio stiprumo) įvertis. Statistinių hipotezių tikrinimas yra procedūra, kurios metu pasirenkame tarp nulinės (žymima \\(H_0\\)) ir alternatyvios (žymima \\(H_1\\) arba \\(H_a\\)) hipotezės. Alternatyvi hipotezė dažnai vadinama tiesiog alternatyva. Nulinė hipotezė. Bendrasis principas – statistinė nulinė hipotezė teigia, kad skirtumas, nuokrypis ar ryšio stiprumas yra lygus nuliui. T. y., kad, pvz., kad kelių grupių lyginamieji parametrai yra lygūs, skirtumo, nuokrypio ar efekto nėra. Ją formuluojant matematiškai gali būti naudojama lygybė arba negriežtos nelygybės \\((=, ~\\le, ~\\ge)\\). Norint pabrėžti, kad skirtumo nėra, įprastai rašoma tik lygybė \\((=)\\). Nulinės statistinės hipotezės patvirtinti ar įrodyti neįmanoma, bet galima teigti, kad jos atmesti nėra pagrindo. O jei yra pagrindo ją atmesti, tada galime taip ir padaryti bei priimti alternatyviąją hipotezę. Galima sau išsivesti tokią analogiją: nulinė hipotezė \\(H_0\\) taip vadinama todėl, kad įprastai teigia, jog skirtumas ar ryšio stiprumas yra lygus nuliui. Alternatyva, atvirkščiai, teigia, kad parametrai skiriasi, skirtumas, nuokrypis ar efektas yra, ir alternatyvą užrašant matematiškai naudojamos tik griežtos nelygybės \\((\\ne,~&lt;,~&gt;)\\). Alternatyvos būna vienpusės \\((&lt;,~&gt;)\\) arba dvipusės \\((\\ne).\\) Jei neturime pagrindo rinktis kitaip, privalome rinktis dvipusę. p reikšmė. Su hipotezių tikrinimu glaudžiai susijęs dydis yra p reikšmė. P reikšmė, negriežtai kalbant,– tai tikimybė vien dėl atsitiktinumo (o ne dėl tiriamo efekto) gauti bent tokio dydžio skirtumą ar ryšio stiprumą, kokį gavome tyrimo metu, jei iš tiesų skirtumo ar ryšio nėra. Perfrazuojant, p reikšmė yra sąlyginė tikimybė vien tik dėl atsitiktinumo gauti nemažesnį efektą, nei tas, kurį gavome savo tyrimo metu, jei iš tiesų to efekto nėra (t. y., jei \\(H_0\\) yra teisinga). Tikimybė yra sąlyginė todėl, kad modeliuojame tik vieną situaciją – kai tiriamo efekto nėra. Reikšmingumo lygmuo \\(\\alpha\\). P reikšmes lyginame su reikšmingumo lygmeniu, žymimu \\(\\alpha\\), kuris moksle įprastai lygus \\(0,05\\), t. y., 1/20 (medicinoje gali būti 0,01, inžinerijoje – 0,10). Tai subjektyviai pasirinkta sutartinė reikšmė. Jei neturite pagrindo daryti kitaip, jūs turėtumėte rinktis šį skaičių (0,05). Išvadų formulavimas. Jei p reikšmė didelė \\((p \\ge \\alpha)\\), tada teigiame, kad skirtumas, nuokrypis, ryšys ar kitoks efektas yra statistiškai nereikšmingas (pastaba: nekorektiška teigti, kad skirtumo, nuokrypio, ryšio ar kitokio efekto nėra: jis yra, tik laikome, kad statistiškai nereikšmingas). Kai p reikšmė yra maža \\((p&lt;\\alpha)\\), tada teigiame, kad tokį skirtumą, nuokrypį ar efektą gauti vien dėl atsitiktinumo yra mažai tikėtina, ir sakome, kad rezultatas yra statistiškai reikšmingas. Kai \\(p&lt;\\alpha\\) (sakykime \\(\\alpha=0,05\\)), rezultatas laikomas statistiškai reikšmingu. \\(p\\) reikšmė nėra tikimybė, kad \\(H_0\\) yra teisinga. \\(p\\) reikšmė parodo, kaip labai tikėtina gauti tokį rezultatą (pvz., nemažesnį skirtumą nei gautasis), jei \\(H_0\\) yra teisinga (neformalus paaiškinimas). Galimi du tikrovės variantai: skirtumas iš tiesų yra arba jo nėra. Darydami išvadas mes galime būti teisūs, bet galime ir apsirikti. Pirmos rūšies klaida – klaidingai atrasti (pvz., „nėščias vyras“ – klaidingai nustatytas nėštumas): teigti, kad skirtumas yra, kai iš tiesų jo nėra (t.y., kai nulinė hipotezė yra teisinga). Pirmos rūšies klaidos tikimybę žymėsime \\(\\alpha\\) (tai tas pats reikšmingumo lygmuo). Antros rūšies klaida – klaidingai nepastebėti, „pražiopsoti“ (pvz., nėščiai moteriai pasakyti, kad ji nesilaukia): teigti, kad skirtumo nėra, kai iš tiesų jis yra (t. y., kai alternatyvioji hipotezė yra teisinga). Antros rūšies klaidos tikimybę žymėsime \\(\\beta.\\) Kriterijaus galia, \\((1-\\beta)\\) – tikimybė atmesti antros rūšies klaidą. Toje pačioje situacijoje, kuo labiau sumažiname reikšmingumo lygmenį \\(\\alpha\\) (didėja tikimybė padaryti I rūšies klaidą), tuo kriterijaus galia tampa didesnė (mažėja tikimybė padaryti II rūšies klaidą). Hipotezių tikrinimas ir imties dydis: kuo imtis mažesnė, tuo \\(H_0\\) atmetama rečiau. Dažna priežastis – per maža kriterijaus galia. Kuo mažesnė imtis, tuo daugiau vietos atsitiktinumui. kuo imtis didesnė, tuo \\(H_0\\) atmetama dažniau. Priežastis – didėjant imčiai ir esant tam pačiam reikšmingumo lygmeniui kriterijaus galia auga. Kuo didesnė imtis, tuo labiau pasitikime tyrimo metu gautu rezultatu, nes mažėja paklaidos. Deja, labai didelėms imtims statistiškai reikšmingais gali būti pripažįstami net labai maži skirtumai (maži efektai). Statistinis reikšmingumas \\(\\ne\\) praktinė nauda. Statistinis reikšmingumas netapatus praktinei naudai (praktiniam reikšmingumui). Statistinis reikšmingumas parodo, kaip labai tikėtina gauti ne mažesnį skirtumą nei gautasis, bet nieko nesako apie tai, kokio dydžio tas skirtumas. Dėl šios priežasties be statistinio reikšmingumo būtina įvertinti ir efekto dydį (standartizuota ar nestandartizuota išraiška). Pirmos ir antros rūšies klaidų tikimybės, imties dydis ir efekto dydis yra susiję: jei turime tinkamą statistinį modelį, žinant ar numanant tris dydžius, ketvirtą galimą įvertinti. Įprastai tuo ketvirtuoju būna arba imties dydis, arba antros rūšies klaidos tikimybė. Kuo skiriasi statistiniai kriterijai 1-2 imtims ir kriterijai daugiau nei 2 imtims? 1 ar 2 imčių kriterijai dažnai gali turėti ir dvipuses, ir vienpuses alternatyvas. T. y., tinka tokiems klausimas, kur reikia patikrinti, ar, pvz., viena grupė pagal tam tikrą požymį yra ne mažesnė už kitą; 2 ir daugiau imčių kriterijai įprastai turi tik dvipuses alternatyvas, o pats kriterijus rodo, ar bent dvi grupės skiriasi tarpusavyje, bet neberodo, kurios tiksliai. Tad jei tokio analizės metu gauname reikšmingą rezultatą, analizę tęsiame toliau norėdami išsiaiškinti, kurios grupių poros skiriasi tarpusavyje arba kurios grupės skiriasi nuo kontrolės. Tokia analizė po pagrindinio kriterijaus taikymo gavus statistiškai reikšmingus rezultatus vadinama post-hoc analize (skaitoma „post-hok“). Post-hoc analizė įprastai atliekama tik tada, jei pagrindinės analizės rezultatas yra statistiškai reikšmingas. 14.2 Prielaidos ir reikalavimai Jau pastebėjote, kad tikrinant hipotezes yra skaičiuojamos tikimybės. Realioms situacijoms tikimybes apskaičiuoti tiksliai yra sudėtingas uždavinys. Todėl sudarant įvairius statistinius kriterijus daromos tam tikros prielaidos, kurioms galiojant tikimybės apskaičiuojamos pakankamai tiksliai. Jei prielaidos pažeidžiamos, kriterijų naudoti nekorektiška. Todėl turite pasirinkti tą kriterijų, kuris tinka būtent jūsų duomenims. Dažnai daromos tokios prielaidos: duomenys yra reprezentatyvūs generalinei aibei (tyrimas atliktas ir duomenys surinkti korektiškai, imtis tikimybinė, o duomenų kiekvienoje grupėje pakankamai daug); tiriamieji yra tarpusavyje nepriklausomi; kiekvienos grupės pasiskirstymas yra normalusis; grupių dispersijos yra lygios. Taip pat pagal tai, kaip suplanavome eksperimentą, duomenų imtys/grupės būna arba nepriklausomos, arba kartotinės. Toliau, nustatome, kiek tų grupių turime analizės metu, kokie grupių dydžiai bei kokie kiekvieno kintamojo duomenų tipai. Kartais svarbu ir tai, ar grupės vienodo dydžio. Nuo šių savybių priklauso, kokius analizės metodus rinksimės. 14.3 Parametriniai ir neparametriniai kriterijai Statistiniai kriterijai (angl. statistical tests) skirstomi į parametrinius ir neparametrinius. Jei kriterijus išvestas grindžiant prielaida, kad tiriami duomenys yra pasiskirstę pagal tam tikrą žinomą teorinį skirstinį (pvz., normalųjį) – toks kriterijus vadinamas parametriniu. Tad norint gauti korektišką rezultatą, duomenys turėtų tenkinti šią prielaidą. Ir jei: duomenų pasiskirstymas bent vienoje imtyje/grupėje nėra normalusis: kai imtys labai didelės, kai kuriems kriterijams gali būti taikomos išlygos, duomenys yra ranginiai, duomenų imtys/grupės labai mažos (tarkime, \\(n_i &lt; 20\\), kur \\(n_i\\) yra i-tosios grupės dydis), duomenyse yra aiškių išskirčių, tada naudojami neparametriniai kriterijai. Dažnai neparametrinių kriterijų statistinė galia yra mažesnė, tad jei galite rinktis, naudokite parametrinį kriterijų. Verta žinoti, kad taikant tiek parametrinius, tiek ir neparametrinius kriterijus, duomenys privalo tenkinti tam tikras sąlygas (reiktų atidžiai perskaityti naudojamo kriterijaus aprašymą). 14.4 Schemos metodams pasirinkti Tolimesniuose skyriuose bus pateiktos schemos, gelbstinčios, kaip pasirinkti tinkamą statistinį kriterijų ar kitokį analizės metodą. Įprastai jose naudojamas pav. 14.1 pavaizduotas ženklinimas. Schemos: spalvinio žymėjimo reikšmės 14.1; normalumo prielaidos tikrinimas 16.1; dispersijų (sklaidos) lyginimas 17.1; skirstinių padėties (pvz., vidurkių) lyginimas: pradinė bendroji schema 18.1; 1 ar 2 grupėms (imtims) 18.2 arba 18.3; kelioms nepriklausomoms grupėms (imtims) 19.1. ryšys tarp dviejų kintamųjų: koreliacija 20.2. Pav. 14.1: Įprastinis schemų, skirtų pasirinkti statistinius kriterijus, elementų spalvinis ženklinimas. 14.5 Praktiniai patarimai Pagrindiniai rekomenduojami korektiškos statistinių hipotezių tikrinimo analizės etapai pateikti pav. 14.2. Su šiais etapais susiję patarimai pateikti žemiau esančiuose poskyriuose. Pav. 14.2: Rekomenduojama statistinių hipotezių tikrinimo analizės eiga. 14.5.1 Duomenų nuskaitymas naudojant RStudio Norėdami nuskaitydami mokomuosius tekstinio formato duomenis galite naudoti RStudio įrankį „From Text (base)…“ (pav. 14.3). Daugelis nuskaitymo parametrų įprastai parenkami teisingai. Tačiau kiekvieną kartą įsitikinkite, ar tikrai stulpeliai turi teisingus pavadinimus (juos vaizduoja pirmoji, pajuodinta, eilutė lange „Data Frame“) ir kiekvienas stulpelis nuskaitomas kaip atskiras stulpelis. Jei duomenyse yra lietuviškų ar kitokių ne angliškų simbolių, gali reikti pasirinkti UTF-8 koduotę. Pav. 14.3: Duomenų nuskaitymas. \\(A_1\\), \\(A_2\\), \\(A_3\\) – tekstinių duomenų nuskaitymo meniu atidarymas. \\(B\\) – norimos tekstinių duomenų bylos pasirinkimas. Tam, kad pirma duomenų eilutė būtų nuskaityta kaip pavadinimai, ties užrašu „Heading“ turi būti pasirinkta „Yes“ (\\(C_1\\)). RStudio taip pat turi įrankius ir kitokio tipo (pvz., Excel formatų) byloms nuskaityti. 14.5.2 Grafinis grupių palyginimas Prieš analizę būtinai duomenis nusibraižykite. Jei lyginate grupes, jas palyginkite tarpusavyje: pirmiausia paanalizuokite (centro) padėtį, sklaidą ir imties dydį (tuos pačius dalykus, kuriuos reikia apsirašyti atliekant aprašomąją statistiką). Taip pat panagrinėkite kiekvienos grupės savybes atskirai. Keletas pavyzdžių pateikta žemiau (pav. 14.4-14.7). Šie grafikai nubraižyti naudojant paketo DescTools funkciją Desc() tokia sintakse: library(DescTools) plot(Desc(y ~ grupe, data = mano_duomenys)) Pav. 14.4: Grupės, kurių sklaida skiriasi, o skirstinio padėtis – panaši. Grafikas nubraižytas funkcija DescTools::Desc(). Pav. 14.5: Grupės, kurių sklaida daugmaž vienoda, o skirstinio padėtis – skirtinga. Pav. 14.6: Grupės, kurių ir sklaida, ir skirstinio padėtis skiriasi. Vėliau paanalizuokite detaliau: centro padėtį: kokie centrai matomi? ar centrai labai nutolę vienas nuo kito? kurios grupės reikšmės vidutiniškai didžiausios, kurios – mažiausios? viso skirstinio padėtį: ar grupių reikšmės (skirstiniai) smarkiai persidengia? sklaidą: ar visų grupių sklaida daugmaž vienoda? imties dydį: ar apskritai duomenų yra pakankamai daug? T. y., ar galiu pasitikėti tuo, ką vaizduoja grafikas? ar visos grupės pakankamo dydžio? ar grupių dydžiai daugmaž vienodi? skirstinio formą: ar vidų grupių forma daugmaž vienoda? ar simetriška? jei ne, kokia asimetrija? ar asimetrija smarki? viena ar kelios viršūnės? ar yra labai didelių išskirčių, kurios paveiks rezultatus? kitus ypatingus ar neįprastus bruožus, jei tokių yra. Jei reikia, savo pastebėjimus patikslinkite žiūrėdami į aprašomųjų statistikų lentelę, kurioje kiekviena grupė aprašyta atskirai (pvz., pav. 14.7 ir lentelė 14.1). Pav. 14.7: Duomenys (grupės A-H), kurie buvo atvaizduoti aukščiau esančiuose grafikuose. Lentelė 14.1: Grupių aprašomosios statistikos. Grupė n Praleista Vidurkis SD Mediana MAD IQR Asimetrija A 30 0 82.3 11.0 83.5 7.9 9.6 0.48 B 30 0 81.5 29.1 87.3 21.4 30.9 -0.31 C 25 0 144.5 10.2 144.2 7.6 11.9 0.39 D 25 0 127.6 8.8 129.4 7.2 12.8 -0.22 E 31 0 96.4 32.5 99.8 24.0 28.4 0.52 F 31 0 70.2 8.2 71.8 7.0 9.5 -0.26 14.6 Rezultatų aprašymo principai Patarimų, kaip biomedicinos srityje dirbantiems aprašyti dažniausiai pasitaikančias statistines analizes rasite straipsnyje (Lang ir Altman 2015). Jei žurnalo, į kurį rašote straipsnį, kursinio darbo ar darbo grupės reikalavimai kitokie, tada laikykitės jų, o ne šiame skyriuje išvardintų. Visgi paminėsiu keletą pagrindinių principų: Žmogus, turintis pakankamai žinių, pagal jūsų pateiktą aprašymą turėtų galėti atkartoti jūsų analizę ir nagrinėdamas rezultatus turėtų tiksliai suprasti, kaip jie buvo gauti. Išsamiame statistinių rezultatų aprašyme turi matytis, kas buvo analizuota, pateikta išvada („statistiškai reikšmingas/nereikšmingas“) ir jos pagrindimas: tikslus kriterijaus pavadinimas, alternatyva (vienpusė/dvipusė), kriterijaus statistika (\\(t, F, \\chi^2\\) ar kita), parametrai ir, būtinai, p reikšmė. P reikšmes rekomenduoju rašyti arba 3 arba 4 skaičių po kablelio tikslumu. Jei p labai maža, rašykite, pvz., \\(p&lt;0,001\\), jei labai didelė – \\(p&gt;0,999\\). Turi būti paaiškinti visi trumpiniai. Pvz., kad „95% PI“ yra 95% pasikliautinasis intervalas. Visos to paties atsitiktinio dydžio statistikos (vidurkiai, medianos, standartiniai nuokrypiai, kvantiliai, pasikliautinieji intervalai, …), kurie matuojami tais pačiais matavimo vienetais, privalo būti suapvalinti tuo pačiu tikslumu. Iš aprašymo turi matytis, koks yra efekto dydis. Pvz., jei lyginama skirstinių padėtis ir taikomi parametriniai kriterijai (lyginami vidurkiai) – tada turi būti pateikti kiekvienos grupės vidurkiai. Taip pat gali būti pateiktas vidurkių skirtumas ir jo pasikliautinasis intervalas. Jei tam pačiam uždaviniui taikomi neparametriniai metodai – aprašyme pateikiamos medianos. Jei lyginamos dispersijos – turi būti pateiktos dispersijos. Jei lyginamos proporcijos – pateikiamos proporcijos. Jei grupių daug, rezultatai gali būti pateikti lentele pateikiant nuorodą tekste. Taip pat pateikiamas grupių palyginimo grafikas (grupių histogramos, stačiakampės, branduolinio tankio, sklaidos, mozaikinės ar kitos tinkamos diagramos). Dažnai reikalaujama, kad aprašyme (pagrindiniame tekste), lentelėje ir grafiškai pateikta informacija nesidubliuotų (skirtingi pateikimo būdai turi vienas kitą papildyti, o ne dubliuoti). Metodų dalyje tiksliai aprašomas naudotas metodas, geriausia, cituojant šaltinį, kuriame metodas yra aprašytas. Taip pat nurodoma programa, kuria atlikti skaičiavimai, jos versija. Jei dirbant „R“ naudotas papildomai atsisiųstas paketas, nurodoma, iš kokio paketo paimta analizės funkcija. Taip pat nurodykite tikslią paketo versiją, nes kitaip rezultatai gali būti neatkartojami. Informacijos šaltiniai "],
["ht-suderinamumas-ir-proporcijos.html", "15. Suderinamumo ir proporcijų homogeniškumo tikrinimas 15.1 Suderinamumo uždavinys 15.2 Proporcijų homogeniškumo tikrinimas", " 15. Suderinamumo ir proporcijų homogeniškumo tikrinimas Šio skyriaus medžiaga vis dar rengiama arba neatnaujinta šių metų kursui, todėl kol kas jos nenagrinėkite. 15.1 Suderinamumo uždavinys … 15.2 Proporcijų homogeniškumo tikrinimas … "],
["ht-normalumas.html", "16. Normalumo tikrinimas 16.1 Pasirinkimų schema 16.2 Statistiniai kriterijai normalumui tikrinti 16.3 Grafiniai būdai normalumui tikrinti 16.4 Kaip atlikti kompiuteriu? 16.5 Uždaviniai", " 16. Normalumo tikrinimas Normalumu statistikoje vadinama situacija, kai duomenys yra pasiskirstę pagal normalųjį (Gauso) skirstinį. Normalumo prielaida – tai reikalavimas, kad duomenys skirstytųsi (daugmaž) normaliai. Daugelis klasikinės statistikos metodų, pvz., parametrinių kriterijų, sukurti grindžiant šia prielaida. Tad prieš taikant tokius kriterijus reikia įsitikinti, kad reikalavimas yra tenkinamas. Statistiniai normalumo tikrinimo kriterijai padeda įvertinti, ar duomenų pasiskirstymo nukrypimas nuo normaliojo yra statistiškai reikšmingas, grafiniai būdai – nustatyti nuokrypio pobūdį ir dydį. 16.1 Pasirinkimų schema Normalumo prielaidai tikrinti yra keletas būdų, kurių pavyzdžiai pateikti pav. 16.1. Rekomenduoju įsiminti kvantilių palyginimo (qq) diagramą ir Shapiro-Wilk kriterijų. Pav. 16.1: Metodai pasiskirstymo normalumui tikrinti. Spalvinio žymėjimo reikšmės pateiktos skyriuje „14.4 Schemos metodams pasirinkti“. Schemoje 16.1 skaičiais pažymėtų punktų paaiškinimai: 1 Šis apribojimas galioja kriterijų taikant programa „R“. Apskritai, jei imtis per maža (pvz., \\(n_i &lt; 20\\)), kriterijus gali nekorektiškai rodyti, kad normalumo prielaida nepažeidžiama (trūks duomenų statistiniam reikšmingumui pasiekti). 2 Pvz., histogramos ir teorinės normaliosios kreivės palyginimas. Įprastai duomenų normalumą reikia tikrinti ne visiems turimiems duomenims iš karto, o kiekvienam tiriamam pogrupiui atskirai. Normalumo prielaida yra tenkinama tik tada, jei padarome išvadą, kad kiekvienos grupės pasiskirstymas yra daugmaž normalusis. 16.2 Statistiniai kriterijai normalumui tikrinti Yra keletas kriterijų (angl. statistical tests) pasiskirstymo normalumui tikrinti: Shapiro-Wilk’o, Anderson-Darling, Kolmogorovo-Smirnovo su Lilliefor’o pataisa ir kiti. Tikrinant prielaidą reikia pasirinkti tik vieną. Taikant šiuos kriterijus, statistinės hipotezės formuluojamos taip: \\(H_0\\): pasiskirstymas yra normalusis \\(X \\sim \\mathcal{N}(\\mu, ~\\sigma^2)\\) (nuokrypio nuo normalumo nėra); \\(H_1\\): pasiskirstymas nėra normalusis, \\(X \\not\\sim \\mathcal{N}(\\mu, ~\\sigma^2)\\) (nuokrypis nuo normalumo yra). Kiekvienas iš statistinių kriterijų naudoja skirtingą nuokrypio nuo normalumo matą. Visgi bet kurio iš šių kriterijų gautą rezultatą vertiname pagal \\(p\\) reikšmę (p-value). Normalumo tikrinimo atveju \\(p\\) reikšmė yra tikimybė gauti tokio dydžio nuokrypį nuo normaliojo pasiskirstymo, kokį stebime savo duomenyse, arba dar didesnį, jei GA, iš kurios sudarėme imtį, pasiskirstymas iš tiesų yra normalusis. T. y., kokia tikimybė gauti tokį nuokrypį nuo normalumo arba dar didesnį, jei iš tiesų pasiskirstymas yra normalusis. - Įprastai reikšmingumo lygmuo (tikimybė \\(\\alpha\\)) – riba, kurią pasirenkame sprendimui priimti – yra lygi \\(\\alpha = \\frac{1}{20 } =\\) 0,05. Jei imtis didelė, o analizės metodas, kurį naudosime, nėra labai jautrus mažam ar vidutiniam nuokrypiui nuo normalumo, gali būti naudojamas ir mažesnis reikšmingumo lygmuo (pvz., 0,001). Įprastai sakoma, kad: jei \\(p \\ge\\) 0,05, duomenų pasiskirstymo nuokrypis nuo normaliojo yra statistiškai nereikšmingas ir normalumo prielaida tenkinama; jei \\(p &lt;\\) 0,05, duomenų pasiskirstymo nuokrypis nuo normaliojo modelio yra statistiškai reikšmingas ir normalumo prielaida netenkinama. Hipotezė apie skirstinių normalumą tikrinama kiekvienai grupei atskirai, tad gaunama tiek \\(p\\) reikšmių, kiek yra lyginamų grupių. 16.3 Grafiniai būdai normalumui tikrinti 16.3.1 Kvantilių palyginimo (qq) diagrama Kvantilių palyginimo, arba kvantilių-kvantilių (qq), diagrama (angl. quantile-quantile plot, qq plot) yra grafinis būdas, skirtas palyginti, ar empirinių – ypač tolydžiųjų – duomenų pasiskirstymas atitinka teoriniu (pvz., normaliuoju) modeliu aprašomą pasiskirstymą. QQ diagramos x ašyje įprastai atidedami teorinio modelio kvantiliai, o y ašyje – empirinių duomenų kvantiliai (kai kuriose programose x ir y ašys gali būti sukeistos vietomis). X ašyje gali būti tiek labiausiai jūsų duomenis atitinkančio normaliojo skirstinio (pav. 16.2), tiek ir standartinio normaliojo (pav. 16.3) skirstinio kvantiliai. Visais atvejais, kuo qq diagramos taškų išsidėstymas panašesnis į tiesę, einančią ties grafiko įstrižaine, tuo duomenys geriau atitinka modelį. Ypač svarbu, kad vienoje tiesėje būtų duomenų taškai, esantys tarp pirmojo \\((Q_1)\\) ir trečiojo \\((Q_3)\\) kvartilių. Visi kiti orientyrai (papildoma atskaitos tiesė ir jos pasikliautinieji intervalai, kaip pav. 16.3) yra tik pagalbiniai dalykai. Pav. 16.2: Įprasta kvantilių-kvantilių (qq) diagrama. Pav. 16.3: Kvantilių-kvantilių (qq) diagrama su atskaitos tiese ir šios tiesės pasikliautinuoju intervalu. Kuo labiau pasiskirstymas skiriasi nuo teorinio, tuo labiau taškai nukrypsta nuo išsidėstymo vienoje tiesėje ties įstrižaine. Keletas pavyzdžių, kaip atrodo skirstinį atitinkantys ir aiškiai jo neatitinkantys duomenys, vaizduojama pav. 16.4. Palyginimui pateikti pav. 16.5 ir 16.6. Pav. 16.4: Normalioji qq (kvantilių palyginimo) diagrama lygina duomenis su teoriniu normaliuoju skirstiniu. Jei duomenys daugmaž normalieji, taškai išsidėsto daugmaž į vieną tiesę ties grafiko įstrižaine. Nuokrypis nuo šios kreivės rodo nuokrypį nuo normalumo. Duomenys tie patys, kaip ir 8.7-8.12 paveiksluose: A-D – normalieji duomenys, E – dvi viršūnės, F – dešinioji asimetrija, G – kairioji asimetrija, H – dvi galimos išskirtys. Pav. 16.5: Duomenys atvaizduoti histogramomis. Duomenys tie patys, kaip ir 8.7-8.12 paveiksluose: A-D – normalieji duomenys, E – dvi viršūnės, F – dešinioji asimetrija, G – kairioji asimetrija, H – dvi galimos išskirtys. Pav. 16.6: Duomenys atvaizduoti stačiakampėmis diagramomis Duomenys tie patys, kaip ir 8.7-8.12 paveiksluose: A-D – normalieji duomenys, E – dvi viršūnės, F – dešinioji asimetrija, G – kairioji asimetrija, H – dvi galimos išskirtys. 16.3.2 Tikimybių palyginimo (pp) diagrama Tikimybių palyginimo (tikimybių-tikimybių, pp) diagrama interpretuojama taip pat, kaip ir qq diagrama. Tik joje atidedami ne kvantiliai, o teorinės ir empirinės tikimybės (pav. 16.7). Pav. 16.7: PP diagramos pavyzdys. 16.3.3 Kitų tipų grafikai Pav. 16.8: Grafiko, kuriame lyginama teorinė (raudona linija) ir empirinė (juodi taškai) kreivės, pavyzdys. \\(CDF\\) – tikimybių pasiskirstymo funkcija (angl. cumulative distribution function). 16.4 Kaip atlikti kompiuteriu? Bazinės programos „R“ funkcijos (shapiro.test(), qqplot(), qqline()) normalumą leidžia tikrinti vienu metu tik vienam pogrupiui. Dėl to kartu reiktų naudoti funkcijas by(), tapply() arba kitokiu būdu parengti duomenis. Dėl šitos priežasties norint kad analizė būtų kuo paprastesnė rekomenduojama naudoti paketus car, RcmdrMisc, Rcmdr, RcmdrPlugin.biostat. Instrukcija, kaip įsidiegti RcmdrPlugin.biostat, pateikta paketo tinklapyje . Likusius paketus galite įsidiegti naudodami funkciją install.packages(). 16.4.1 Programos kodas normalumui tikrinti Normaliąją qq diagramą braižysime paketo car funkcija qqPlot(). car::qqPlot(x) car::qqPlot(y ~ grupe, data = mano_duomenys) ?car::qqPlot Rezultatas bus analogiškas pateiktam pav. 16.3 (nubraižytas ne ggplot2, o bazine R sistema). Apie kitus būdus braižyti qq grafikus galite rasti tinklalapyje aloy.github.io/qqplotr/. Normalumo kriterijų taikysime paketo RcmdrMisc funkcija normalityTest(). RcmdrMisc::normalityTest(x) RcmdrMisc::normalityTest(y ~ grupe, data = mano_duomenys, test = &quot;shapiro.test&quot;) ?RcmdrMisc::normalityTest „R“ atspausdins daugmaž tokį rezultatą (sutrumpinta versija): -------- grupe = A Shapiro-Wilk normality test data: reiksme W = 0.99599, p-value = 0.7703 &lt;--------------- -------- /... sutrumpinta .../ -------- grupe = H Shapiro-Wilk normality test data: reiksme W = 0.95282, p-value = 0.000000295 -------- p-values adjusted by the Holm method: unadjusted adjusted A 0.770291 1.00000 &lt;--------------- B 0.432737 1.00000 C 0.659252 1.00000 D 0.082357 0.32943 E 4.1177e-15 2.4706e-14 F &lt; 2.22e-16 &lt; 2.22e-16 G &lt; 2.22e-16 &lt; 2.22e-16 H 2.9496e-07 1.4748e-06 Žiūrime ten, kur parašyta „p-value“ (pažymėta rodykle viršuje) arba „unadjusted“ (pastebėkite, kad tai ta pati \\(p\\) reikšmė). Grupėms E, F, G ir H nuokrypiai nuo normalumo yra reikšmingi (t. y., mažai tikėtina, kad įvyko dėl atsitiktinumo). Praktinį nuokrypio dydį analizuojame QQ diagramomis. 16.4.2 R Commander normalumui tikrinti Normalumui tikrinti gali būti naudojamos ir standartinio „R Commander“ meniu (pav. 16.9, 16.10) funkcijos. Pav. 16.9: Normalumo tikrinimas pogrupiams statistiniu kriterijumi naudojant standartinį „R Commander“ meniu. Pav. 16.10: Normaliosios qq diagramos braižymas naudojant standartinį „R Commander“ meniu. Taip pat ir „BioStat“ režimo (pav. 16.11) arba „BioStat’19“ meniu komandos (reikiama paketo versija 0.0.33 ar naujesnė): Rcmdr meniu → BioStat’19 → Analysis → Tests → Test normality (univariate…). Privalumai tokie: viename lange galime pasirinkit ir grafiką, ir statistinį kriterijų; duomenis į pogrupius galime skaidyti daugiau nei pagal vieną grupavimo kintamąjį. Pav. 16.11: Normalumo prielaidos tikrinimas pogrupiams papildiniu R Commander naudjant „BioStat“ režimą (RcmdrPlugin.biostat versija 0.0.33 ar naujesnė). Prisiminkite, kad normalumą rekomenduojama tikrinti keliais būdais (grafiškai ir formaliai): Kvantilių-kvantilių (QQ) grafiku (tad būtinai uždėkite varnelę ties „Draw normal QQ plot“). Shapiro-Wilk (Šapiro-Vilko) kriterijumi. BioStat’19 versijos grafinis rezultatas bus analogiškas tam, kuris pavaizduotas pav. 16.4, o skaitinis bus daugmaž toks (mus domina stulpelis p.value): grupe statistic p.value method ------ ---------- -------- ---------------------------- A 0.996 0.770 Shapiro-Wilk normality test B 0.981 0.433 Shapiro-Wilk normality test C 0.995 0.659 Shapiro-Wilk normality test D 0.990 0.082 Shapiro-Wilk normality test E 0.845 0.000 Shapiro-Wilk normality test F 0.754 0.000 Shapiro-Wilk normality test G 0.719 0.000 Shapiro-Wilk normality test H 0.953 0.000 Shapiro-Wilk normality test 16.5 Uždaviniai Užduotis 16.1 Užsikraukite duomenis „barley“ (miežiai) iš paketo „lattice“: data(&quot;barley&quot;, package = &quot;lattice&quot;) Nustatykite, ar kintamojo „derlius“ („yield“) reikšmių pasiskirstymas yra normalusis kiekviename iš pogrupių. Į pogrupius skirstykite pagal: įvairovę (kintamasis „variety“); vietoves (kintamasis „site“); metus (kintamasis „year“). Sąsiuvinyje apsirašykite savo pastebėjimus. Užduotis 16.2 Užsikraukite duomenis: data(npk); data(swiss): Daroma prielaida, kad duomenų lentelės „npk“ kintamojo „yield“ reikšmių pasiskirstymas yra normalusis. Grafiškai įvertinkite, ar ši prielaida yra pagrįsta? Grafiškai įvertinkite ir išvardinkite kintamuosius iš duomenų lentelės „swiss“, kurių reikšmės yra pasiskirsčiusios daugmaž normaliai, o kurių – ne normaliai. Užduotis 16.3 Užsikraukite duomenis „cabbages“ iš paketo „MASS“. Skirstydami į pogrupius (žiūr. 3 punktą), nustatykite, ar šių kintamųjų reikšmės skirstosi normaliai: svoris (HeadWt); vitamino C kiekis (VitC ). Į pogrupius skirstykite: pagal veisles (Cult); pagal sėjos dieną (Date); iš karto ir pagal veislę, ir pagal sėjos dieną. Sąsiuvinyje apsirašykite savo pastebėjimus. "],
["ht-sklaida.html", "17. Sklaidos lyginimas 17.1 Pasirinkimų schema 17.2 Statistinės hipotezės lyginant dispersijas 17.3 Kaip atlikti kompiuteriu? 17.4 Rezultatų aprašymas: sklaida", " 17. Sklaidos lyginimas Dispersija, standartinis nuokrypis, MAD, IQR yra skaidos matai. Hipotezėms tikrinti įprastai yra naudojama dispersija. Kriterijus, kuriuo siekiama patikrinti, ar skirtumai tarp dispersijų yra statistiškai reikšmingi, gali būti taikomas ir kaip pagrindinis kriterijus (pvz., jei norima įvertinti kokybę, pastovumą arba stabilumą), ir kaip prielaidos apie lygias dispersijas tikrinimo kriterijus. Situacija, kai kelių grupių dispersijos yra lygios, vadinama dispersijų homogeniškumu arba homoskedastiškumu. Tikrinant prielaidas pradedantiesiems rekomenduoju Levene’o (skaitoma „Ly-vy-no“) kriterijų su Brown-Forsythe (Brauno-Forsaito) pataisa (centras – mediana) (Brown ir Forsythe 1974), nes jis tinka ir normaliesiems, ir nuo normalumo nukrypusiems duomenims. Šis ir kiti pagrindiniai dispersijų lyginimo kriterijai pateikti pav. 17.1 esančioje schemoje. Vertindami skirtumus tarp dispersijų kliaukitės ne tik statistiniais kriterijais, bet būtinai atlikite ir aprašomąją statistiką: apskaičiuokite dispersijas, taip pat standartinius nuokrypius, IQR ir/arba MAD kiekvienai lyginamai grupei. Pažiūrėkite, kaip smarkiai skiriasi mažiausia ir didžiausia reikšmės. Pvz., ar skirtumas mažesnis nei 3 kartai, ar didesnis. Taip pat nusibraižykite grafiką ir palyginkite, sakykime, stačiakampės diagramos dėžučių plotį. Grafinis palyginimo pavyzdys patektas paveiksluose 14.4, 14.5, 14.6. 17.1 Pasirinkimų schema Pav. 17.1: Schema, rekomenduojanti, kurį dispersijų lyginimo metodą pasirinkti. Įprastai prielaidų tikrinimui tinkamiausias yra Levene/Brown-Forsythe metodas, kai kiekvienos grupės centru laikoma mediana. Spalvinio žymėjimo reikšmės pateiktos skyriuje „14.4 Schemos metodams pasirinkti“. Schemoje 17.1 skaičiais pažymėtų punktų paaiškinimai: 1 \\(\\chi^2\\) skaitoma „chi kvadratu“. 2 Yra keli Levene/Brown-Forsythe kriterijaus variantai: Klasikinis Levene‘o kriterijus, kai duomenų centru laikomas vidurkis. Labiausiai tinka, kai duomenų pasiskirstymas nedaug nukrypsta nuo normalumo; Brown-Forsythe kriterijus (t.y., Levene‘o kriterijus su Brown-Forsythe pataisa), kai duomenų centru laikoma mediana. Tinka ir tada, kai duomenys yra asimetriški. Tai pagrindinis kriterijaus variantas jį atliekant programa „R“ ir „R Commander“; Šio varianto „R Commander“ neatlieka. 17.2 Statistinės hipotezės lyginant dispersijas Kai naudojamas F kriterijus hipotezei apie dviejų grupių dispersijų lygybę tikrinti, statistinės hipotezės formuluojamos taip: \\(H_0\\): dispersijos lygios, \\(\\sigma^2_1 = \\sigma^2_1\\) (skirtumo nėra); \\(H_1\\): arba dispersijos skiriasi, \\(\\sigma^2_1 \\ne \\sigma^2_1\\) (dvipusė alternatyva), arba \\(\\sigma^2_1 &lt; \\sigma^2_1\\), arba \\(\\sigma^2_1 &gt; \\sigma^2_1\\) (vienpusės alternatyvos). Jei naudojami kriterijai, kuriais tikrinama hipotezė apie kelių (2 ar daugiau) dispersijų lygybę, hipotezės: \\(H_0\\): dispersijos lygios, \\(\\sigma^2_1 = \\sigma^2_1 = ... = \\sigma^2_n\\) (skirtumo nėra); \\(H_1\\): bent dviejų grupių (neaišku kurių) dispersijos skiriasi, \\(\\sigma^2_i \\ne \\sigma^2_j\\) (dvipusė alternatyva). Kriterijus lygina iš karto visų grupių dispersijas, todėl gaunama viena \\(p\\) reikšmė. Jei reikšmingumo lygmuo \\(\\alpha = 0,05\\), tai, kai: \\(p\\ge\\) 0,05, teigiame, kad skirtumas tarp dispersijų yra statistiškai nereikšmingas (neatmetame \\(H_0\\)); \\(p&lt;\\) 0,05, teigiame, kad skirtumas tarp dispersijų yra statistiškai reikšmingas (priimame \\(H_1\\)). Įprastai, kai \\(p \\ge\\) 0,05, laikoma, kad lygių dispersijų prielaida tenkinama (nes skirtumai tarp dispersijų nėra statistiškai reikšmingi). 17.3 Kaip atlikti kompiuteriu? Šiame skyriuje naudosime paketus car, DescTools ir Rcmdr. Juos galite įsidiegti naudodami funkciją install.packages(). 17.3.1 \\(\\chi^2\\) kriterijus vienos imties dispersijai lyginti su reikšme Yra \\(\\chi^2\\) (chi-kvadratu) kriterijaus variantas, skirtas vienos imties dispersijos lyginimui su konkrečia reikšme. Tinka, jei duomenys griežtai normalieji ir imtis pakankamo dydžio. Reikiama duomenų struktūra: vienas skaitinis kintamasis. Pvz.: mano_duomenys_v &lt;- read.table(header = TRUE, text = &quot; y 2.2 2.5 2.7 2.6 2.9 2.8 &quot;) mano_duomenys_v ## y ## 1 2.2 ## 2 2.5 ## 3 2.7 ## 4 2.6 ## 5 2.9 ## 6 2.8 lyginama_reiksme &lt;- 2.5 with(mano_duomenys_v, DescTools::VarTest(y, sigma.squared = lyginama_reiksme)) 17.3.2 F kriterijus dviejų imčių dispersijoms lyginti \\(F\\) kriterijus skirtas lygiai dviejų imčių dispersijoms lyginti, jei duomenys griežtai normalieji ir kiekviena imtis pakankamo dydžio. jei duomenys bus ne normalieji, tai kriterijus labiau vertins nuokrypį nuo normalumo, jei nuokrypį nuo lygių dispersijų. Reikiama duomenų struktūra: vienas skaitinis ir vienas dvireikšmis kategorinis kintamasis. Pvz.: mano_duomenys_n &lt;- read.table(header = TRUE, text = &quot; y grupe 2.2 grupe-1 2.5 grupe-1 2.7 grupe-1 2.6 grupe-2 2.9 grupe-2 2.8 grupe-2 &quot;) mano_duomenys_n ## y grupe ## 1 2.2 grupe-1 ## 2 2.5 grupe-1 ## 3 2.7 grupe-1 ## 4 2.6 grupe-2 ## 5 2.9 grupe-2 ## 6 2.8 grupe-2 var.test(y ~ grupe, data = mano_duomenys_n) Apie kitokios struktūros duomenų analizės galimybes skaitykite funkcijos dokumentacijoje. 17.3.3 Bartlett kriterijus kelių imčių dispersijoms lyginti Bartlett (Bartleto) kriterijus skirtas kelių imčių dispersijų lyginimui, jei duomenys griežtai normalieji ir kiekviena imtis pakankamo dydžio. Reikiama duomenų struktūra: vienas skaitinis ir vienas kategorinis kintamasis. bartlett.test(y ~ grupe, data = mano_duomenys_n) 17.3.4 Levene ir Brown-Forsythe kriterijai kelių imčių dispersijoms lyginti Levene/Brown-Forsythe kriterijai tinka ir tada, kai duomenys nukrypę nuo normalumo. Kai centras – vidurkis, kriterijus turėtų vadintis Levene’o, kitais atvejais – Brown-Forsythe vardu. Reikiama duomenų struktūra: vienas skaitinis ir vienas kategorinis kintamasis. car::leveneTest(y ~ grupe, data = mano_duomenys_n) 17.3.5 R Commander dispersijoms lyginti Papildinyje „R Commander“ dispersijoms lyginti galime rasti F kriterijų 2 imčių dispersijoms lyginti ir Bartlett bei Levene/Brown-Forsythe kriterijus kelių imčių dispersijoms lyginti 17.2. Pav. 17.2: Levene ir Brown-Forsythe kriterijai naudojant R Commander. 17.3.6 Rezultatų pavyzdys Pav. 17.3: Levene ir Brown-Forsythe kriterijų rezultatai. Kriterijaus taikymas programiškai: car::leveneTest(weight ~ group, data = PlantGrowth) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 2 1.1192 0.3412 ## 27 Levene’o / Brown-Forsythe kriterijaus rezultatų lentelėje labiausiai mus dominantis dalykas yra \\(p\\) reikšmė. Ji pateikta stulpelyje Pr(&gt;F) ir yra lygi 0.34 (suapvalinta). Šis rezultatas rodo, kad skirtumas tarp dispersijų nėra statistiškai reikšmingas (lygių dispersijų prielaida tenkinama). Kitas pavyzdys: var.test(y ~ grupe, data = mano_duomenys_n) ## ## F test to compare two variances ## ## data: y by grupe ## F = 2.7143, num df = 2, denom df = 2, p-value = 0.5385 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 95 percent confidence interval: ## 0.06959707 105.85714286 ## sample estimates: ## ratio of variances ## 2.714286 Čia turėtume pamatyti, kam lygi \\(p\\) reikšmė ties p-value. 17.4 Rezultatų aprašymas: sklaida Jei kriterijus taikomas kaip pagrindinis analizės metodas, aprašydami rezultatus laikykitės skyriuje „14.6 Rezultatų aprašymo principai“ išdėstytų principų. Jei taikomas kaip prielaidų tikrinimo metodas, įprastai užtenka teigti, kad „dispersijų homogeniškumo prielaida buvo tenkinama“ arba „visos modeliui keliamos prielaidos buvo tenkinamos“. Informacijos šaltiniai "],
["ht-padetis.html", "18. Padėties lyginimas (1-2 imtims) 18.1 Statistinės hipotezės: parametriniai kriterijai 18.2 Statistinės hipotezės: neparametriniai kriterijai 18.3 Pasirinkimų schema 18.4 Kaip atlikti kompiuteriu? 18.5 Rezultatų aprašymas: padėties lyginimas", " 18. Padėties lyginimas (1-2 imtims) Sakykime, turime kurią nors iš šių situacijų: sporto klube mums siūlo treniruočių programą, kuri, kaip teigia treneriai, per pirmąjį mėnesį padeda sulieknėti vidutiniškai bent 5 kilogramais; farmacininkai teigia sukūrę naują vaistą, kuris pailgina miego trukmę; norime sužinoti, kas greičiau įsimena informaciją – vyrai ar moterys; norime patikrinti, kuris standartinės priedas – gliukozė ar fruktozė – leidžia užauginti daugiau ląstelių; fermeris nori ištirti, kuriuo iš 6 pašarų geriausia šerti viščiukus, kad jie per 6 savaites užaugtų didžiausi. Visoms šioms situacijoms bendra tai, kad galime atlikti tyrimą, kurio metu galime surinkti vieną ar kelias kiekybinių duomenų grupes. O tose grupėse, žiūrint matematiškai, mums reikia palyginti, ar kažkurios grupės reikšmės yra linkusios būti didesnės, nei kitos grupės: ar tikrai vidutiniškai numetama daugiau nei 5 kg svorio? ar tikrai vartojant vaisto miegama ilgiau, nei nevartojant? ar tikrai skiriasi vyrų ir moterų per 1 minutę įsimintų žodžių skaičius? ar tikrai terpėje su gliukoze ir fruktoze užauga skirtingas ląstelių skaičius? ar tikrai viščiukų svoris skiriasi, jei juos šeriame skirtingais pašarais? Turime kelias kiekybinių reikšmių grupes ir lyginame jų padėtį tarpusavyje. Tad norint atsakyti į išsikeltus klausimus, mums reikia taikyti statistinius skirstinio padėties lyginimo kriterijus, kurie padeda įvertinti, ar tuos skirtumus, kuriuos gavome tyrimo metu, labiau tikėtina gauti vien tik dėl atsitiktinumo, ar labiau tikėtina, kad, pvz., mūsų sporto klubo treniruotės iš tiesų tokios veiksmingos. Tai vieni dažniausiai naudojamų statistinių kriterijų, tad apie jų taikymą, kai turime 1 ar 2 duomenų grupes (imtis) bus kalbama ir šiame, o kai turime kelias – kitame („19 ANOVA ir jos analogai“) skyriuje. Tiriame, ar skirtumai tarp grupių padėties yra statistiškai reikšmingi. Tinkamą analizės metodą pasirinksime pagal konkrečių duomenų savybes. Viena iš svarbiausių – normalumas: ar kiekviena grupė skirstosi daugmaž pagal normalųjį skirstinį (plačiau skaitykite skyriuje „16 Normalumo tikrinimas“). Jei grupė pakankamo dydžio ir skirstosi normaliai, tada naudosime parametrinius metodus, kitu atveju – neparametrinius. 18.1 Statistinės hipotezės: parametriniai kriterijai Jei taikome parametrinius kriterijus, tada situacija labai paprasta: tikriname, ar skirtumai tarp vidurkių (arba vidurkio ir skaičiaus) yra reikšmingi. Vidurkiai ir yra tas skirstinio parametras, kurį lyginame. Tad dviejų grupių atveju statistinės hipotezės formuluojamos taip: \\(H_0\\): vidurkiai yra lygūs, \\(\\mu_1=\\mu_2\\) (skirtumo nėra); \\(H_1\\): arba vidurkiai skiriasi \\(\\mu_1 \\ne \\mu_2\\) (dvipusė alternatyva), arba \\(\\mu_1&gt;\\mu_2\\) (vienpusė alternatyva), arba \\(\\mu_1&lt;\\mu_2\\) (vienpusė alternatyva). Tad pasirenkame vieną iš 3 galimų hipotezių porų. (Apie tai nusprendžiame tyrimo planavimo etape.) Jei reikšmingumo lygmuo \\(\\alpha = 0,05\\), tai, kai: \\(p\\ge0,05\\), teigiame, kad skirtumas tarp vidurkių yra statistiškai nereikšmingas ir nulinės hipotezės \\(H_0\\) atmesti nėra pagrindo; \\(p&lt;0,05\\), priimame, kad labiau tikėtina \\(H_1\\). T. y., teigiame: arba kad skirtumas tarp vidurkių yra statistiškai reikšmingas (jei dvipusė alternatyva), arba kad pirmos grupės vidurkis yra statistiškai reikšmingai didesnis nei antros (jei vienpusė alternatyva), arba kad pirmos grupės vidurkis yra statistiškai reikšmingai mažesnis nei antros (jei vienpusė alternatyva). Jei turime tik vieną grupę ir skaičių, tai hipotezėse vietoje antrosios grupės vidurkio įrašome tą skaičių. Aprašant rezultatus turi būti pateikti vidurkiai. 18.2 Statistinės hipotezės: neparametriniai kriterijai Jei situacijai tinka neparametriniai kriterijai, tada formuluojamos bendresnės hipotezės: ne apie konkretų parametrą, bet apskritai apie bendrą skirtumą tarp skirstinių padėties. Tarkime, lyginamos dvi duomenų grupės. Tada: \\(H_0\\): poslinkis tarp skirstinių padėties yra lygus nuliui (skirtumo nėra); \\(H_1\\): arba poslinkis tarp skirstinių padėties nelygus nuliui (kažkurios iš grupių reikšmės yra linkusios būti didesnės), skirstinių padėtis skiriasi (jei dvipusė alternatyva), arba pirmos grupės reikšmės yra linkusios būti didesnės nei antrosios (jei vienpusė alternatyva), arba pirmos grupės reikšmės yra linkusios būti mažesnės nei antrosios (jei vienpusė alternatyva). Tad pasirenkame vieną iš 3 galimų hipotezių porų. (Apie tai nusprendžiame tyrimo planavimo etape.) Jei reikšmingumo lygmuo \\(\\alpha = 0,05\\), tai, kai: \\(p\\ge0,05\\), teigiame, kad poslinkis (skirtumas) tarp skirstinių yra statistiškai nereikšmingas nėra pagrindo atmesti \\(H_0\\); \\(p&lt;0,05\\), priimame, kad labiau tikėtina \\(H_1\\). T. y., teigiame, arba kad poslinkis (skirtumas) tarp skirstinių yra statistiškai reikšmingas ir kažkurios grupės reikšmės yra linkusios būti didesnės (jei dvipusė alternatyva); arba kad pirmos grupės reikšmės yra linkusios būti didesnės nei antrosios (jei vienpusė alternatyva), arba kad pirmos grupės reikšmės yra linkusios būti mažesnės nei antrosios (jei vienpusė alternatyva). Jei turime tik vieną grupę ir skaičių, tai hipotezes formuluojame taip, kaid būtų tikrinama, ar grupės reikšmės yra linkusios būti mažesnės/didesnės nei pateiktoji reikšmė. Jei visų grupių skirstinių formos yra vienodos (vienoda asimetrijos kryptis, daugmaž vienodas asimetrijos stiprumas bei sklaida) ir skirstiniai skiriasi tik poslinkio parametru (tokiems duomenims šie neparametriniai kriterijai yra galingiausi), tada hipotezes galime formuluoti apie medianų skirtumus (pvz., \\(H_0\\) – medianos vienodos, \\(H_1\\) – medianos skiriasi). Aprašant rezultatus turi būti pateiktos medianos. 18.3 Pasirinkimų schema Šiame skyriuje pateikiamos schemos, padedančios pasirinkti analizės metodą. Pav. 18.1 pateikti pirmieji kriterijaus pasirinkimo žingsniai (tad juos išnagrinėkite pirmiausiai). Pav. 18.2 ir 18.3 pateikta detalesnė pasirinkimo schema, kai turime 1 arba 2 grupes. Schema yra supaprastinta ir tik rekomendacinio pobūdžio. Jos tikslas – būti „atspirties tašku“ renkantis analizės metodą. Konkrečiu atveju gali būti išlygų, papildomų sąlygų arba pasirinkimo variantų, kurie schemoje nepažymėti. Pav. 18.1: Bendroji schema, rekomenduojanti, kurį skirstinių padėties lyginimo metodą pasirinkti. Paaiškinimai: 1 toliau žiūrėti schemą 18.2 arba 18.3; 2 toliau žiūrėti schemą 19.1 (kitame skyriuje). Pav. 18.2: Schema, rekomenduojanti, kurį skirstinio padėties lyginimo metodą pasirinkti, kai lyginamos 1-2 imtys (grupės). Supaprastintas schemos variantas pateiktas – 18.3. Spalvinio žymėjimo reikšmės pateiktos skyriuje „14.4 Schemos metodams pasirinkti“. Pav. 18.3: Supaprastinta schema, rekomenduojanti, kurį skirstinio padėties lyginimo metodą pasirinkti, kai lyginamos 1-2 imtys (grupės). Paaiškinimai tie patys, kaip schemoje 18.2. Spalvinio žymėjimo reikšmės pateiktos skyriuje „14.4 Schemos metodams pasirinkti“. Schemose 18.2 ir 18.3 skaičiais pažymėtų punktų paaiškinimai: 1 Pasiskirstymo normalumas tikrinamas kiekvienai grupei atskirai. Pvz., nusibraižant normaliąją qq diagramą ir taikant normalumo (pvz., Shapiro-Wilk) kriterijų. Apie normalumo tikrinimą rašoma 16 skyriuje; 2 Prielaidos gali būti tikrinamos porų/pakartojimų skirtumų skirstiniui. Apie priklausomų imčių analizės ypatumus plačiau rašoma skyriuje „Priklausomų imčių analizės ypatumai“; 3 Sprendžiant „iš akies“, skirtumas tarp didžiausios ir mažiausios dispersijos neturėtų būti didesnis kaip 3 kartus. Lygių dispersijų prielaidai tikrinti įprastai naudojamas Levene‘o kriterijus su Brown-Forsythe pataisa (centras – mediana). Apie tai plačiau rašoma skyriuje 17. 4 Šiuo atveju skirstinių forma laikoma panašia, kai visų grupių asimetrija yra vienos krypties ir panašaus stiprumo, o sklaida – daugmaž vienoda; 5 Jei grupių skirstinių forma panaši ir skiriasi tik poslinkio parametru, t. y., skiriasi skirstinio padėtis (tokiems duomenims ir rekomenduojamas Mann-Whitney-Wilcoxon kriterijus), tada galime daryti išvadas apie grupių medianas: tokiu atveju rezultatai informatyvesni nei 6 punkto atveju; 6 Jei lyginamų grupių skirstinių forma skirtinga (skiriasi dispersijos, būdinga skirtingos krypties asimetrija), išvadas darome tik apie tai, ar kažkurios grupės reikšmės linkusios būti statistiškai didesnės, bet ne apie medianas: šiuo atveju rezultatai mažiau informatyvūs nei 5 punkto atveju. 7 Nereikalaujama, kad dispersijos būtų lygios. 8 Žiūrėti schemą 19.1 (kitame skyriuje). 18.4 Kaip atlikti kompiuteriu? Programa „R“ 1 ar 2 grupių padėties lyginimas atliekamas funkcijomis t.test() ir wilcox.test(). Tai bazinės „R“ sistemos funkcijos, tad norint jas naudoti paildomų paketų nereikia. Visgi rekomenduojami paketai yra šie: tidyverse, Rcmdr, RcmdrPlugin.biostat, RcmdrPlugin.as.menu. Instrukcija, kaip įsidiegti RcmdrPlugin.as.menu bei RcmdrPlugin.biostat, pateikta pastarojo paketo tinklapyje . Likusius galite įsidiegti naudodami funkciją install.packages(). 18.4.1 Analizės eiga Konkreti analizės eiga priklauso nuo išsikelto klausimo ir duomenų savybių. Visgi laikykitės eigos, išdėstytos skyriuje „14.5 Praktiniai patarimai“. Ypatingai svarbu rezultatus atvaizduoti grafiškai („14.5.2 Grafinis grupių palyginimas). 18.4.2 Vienos imties padėties lyginimas su skaičiumi programa R Reikiama duomenų struktūra Reikiama duomenų struktūra: vienas skaitinis kintamasis. Pvz.: mano_duomenys_v &lt;- read.table(header = TRUE, text = &quot; y 2.2 2.5 2.7 2.6 2.9 2.8 &quot;) mano_duomenys_v ## y ## 1 2.2 ## 2 2.5 ## 3 2.7 ## 4 2.6 ## 5 2.9 ## 6 2.8 Parametrinis kriterijus Jei duomenys normalieji ir imtis pakankamo dydžio. with(mano_duomenys_v, t.test(y)) Neparametrinis kriterijus Jei duomenys nebūtinai normalieji ar imtis maža. with(mano_duomenys_v, wilcox.test(y)) 18.4.3 Priklausomų imčių padėties lyginimas programa R Reikiama duomenų struktūra Reikiama duomenų struktūra: du skaitiniai kintamieji (su poriniais ar kartotiniais matavimais). mano_duomenys_p &lt;- read.table(header = TRUE, text = &quot; x y 2.0 2.2 2.2 2.5 2.6 2.7 2.3 2.9 1.9 2.8 &quot;) mano_duomenys_p ## x y ## 1 2.0 2.2 ## 2 2.2 2.5 ## 3 2.6 2.7 ## 4 2.3 2.9 ## 5 1.9 2.8 Galima ir kitokia duomenų struktūra. Apie tai skaitykite funkcijų dokumentacijoje: ?t.test bei ?wilcox.test. Priklausomų imčių analizės ypatumai Norint kartotinių ar porinių imčių duomenis nusibraižyti grupėmis, juos iš plačiojo formato reikia pasiversti į ilgąjį. Principas, kaip tai daroma, pavaizduotas pav. 18.4. Pav. 18.4: Duomenų vertimas iš plačiojo formato į ilgąjį. Ilgojo formato duomenys yra tinkami braižyti taip, kaip tai darytume su nepriklausomų imčių duomenimis. Duomenų formato keitimui naudokite funkciją gather() iš paketo tidyr, kuris yra tidyverse sistemos dalis. library(tidyverse) Funkcijoje sukuriame kategorinio kintamojo pavadinimą (key), reikšmių kintamojo pavadinimą (value), kurie atsiras naujai pertvarkytoje lentelėje, kintamuosius (šiuo atveju x ir y), kuriuos norime pertvarkyti, bei tai, kad key stulpelis turi būti paverstas į kategorinį kintamąjį (factor_key = TRUE). Nurodyta kintamųjų iš senosios lentelės (x, y) eilės tvarka yra svarbi, nes tokia tvarka išdėliojamos kategorijos. duomenys_braizymui &lt;- mano_duomenys_p %&gt;% gather(key = &quot;grupes&quot;, value = &quot;reiksmes&quot;, x, y, factor_key = TRUE) duomenys_braizymui ## grupes reiksmes ## 1 x 2.0 ## 2 x 2.2 ## 3 x 2.6 ## 4 x 2.3 ## 5 x 1.9 ## 6 y 2.2 ## 7 y 2.5 ## 8 y 2.7 ## 9 y 2.9 ## 10 y 2.8 Kai dvi imtys yra kartotinės arba porinės, galima apskaičiuoti skirtumą tarp dviejų kiekvieno tiriamojo reikšmių ir toliau tirti šį skirtumą taip, tarsi tai būtų vienos imties lyginimo su nuliu uždavinys: skirtumui patikrinti normalumą ir jam atlikti tolimesnę analizę. mano_duomenys_p &lt;- mano_duomenys_p %&gt;% dplyr::mutate(skirtumas = x - y) mano_duomenys_p ## x y skirtumas ## 1 2.0 2.2 -0.2 ## 2 2.2 2.5 -0.3 ## 3 2.6 2.7 -0.1 ## 4 2.3 2.9 -0.6 ## 5 1.9 2.8 -0.9 Kokiu būdu beanalizuotume, atsakymas bus tas pats, nes priklausomų imčių atveju padėties lyginimo funkcijos pačios apskaičiuoja skirtumą. Parametrinis kriterijus Jei duomenys normalieji ir imtis pakankamo dydžio. # Tiriame kaip skirtumą with(mano_duomenys_p, t.test(skirtumas)) # Tiriame kaip priklausomas imtis with(mano_duomenys_p, t.test(x, y, paired = TRUE)) Neparametrinis kriterijus Jei duomenys ne normalieji ar maža imtis. # Tiriame kaip skirtumą with(mano_duomenys_p, wilcox.test(skirtumas)) # Tiriame kaip priklausomas imtis with(mano_duomenys_p, wilcox.test(x, y, paired = TRUE)) 18.4.4 Nepriklausomų imčių padėties lyginimas programa R Reikiama duomenų struktūra Reikiama duomenų struktūra: vienas skaitinis ir vienas dvireikšmis kategorinis kintamasis. Pvz.: mano_duomenys_n &lt;- read.table(header = TRUE, text = &quot; y grupe 2.2 grupe-1 2.5 grupe-1 2.7 grupe-1 2.6 grupe-2 2.9 grupe-2 2.8 grupe-2 &quot;) mano_duomenys_n ## y grupe ## 1 2.2 grupe-1 ## 2 2.5 grupe-1 ## 3 2.7 grupe-1 ## 4 2.6 grupe-2 ## 5 2.9 grupe-2 ## 6 2.8 grupe-2 Parametrinis kriterijus Jei abiejų grupių duomenys normalieji ir grupės pakankamo dydžio, taikomas Welch \\(t\\) kriterijus. t.test(y ~ grupe, data = mano_duomenys_n) Jei dispersijos lygios, gali būti taikomas Stjudento \\(t\\) kriterijus. t.test(y ~ grupe, data = mano_duomenys_n, var.equal = TRUE) Neparametrinis kriterijus Jei bent vienos grupės duomenys nebūtinai normalieji ar bent viena grupė mažo dydžio, taikomas Mann-Whitney-Wilcoxon kriterijus. wilcox.test(y ~ grupe, data = mano_duomenys_n) 18.4.5 R Commander padėčiai lyginti Pasirengimas Jei prieš atliekant analizę reikia skaičiuoti skirtumus tarp imčių, naudokite pav. 18.5 pavaizduotą metodą. Pav. 18.5: Kintamojo reikšmių perskaičiavimo pavyzdys naudojant „BioStat“ režimą. Analogišką funkciją galima rasti ir klasikiniame „R Commander“ meniu. Jei norite duomenis pasiversti į ilgąjį formatą (principas vaizduojamas pav. 18.4), galite naudoti metodą, pavaizduotą 18.6. Pav. 18.6: Duomenų vertimas iš plačiojo formatą į ilgąjį naudojant „BioStat“ režimą. Analogišką funkciją galima rasti ir klasikiniame „R Commander“ meniu (pav. 18.7). Pav. 18.7: Duomenų vertimas iš plačiojo formato į ilgąjį naudojant standartinį „R Commander“ meniu. Jei po šios procedūros kategorijos yra išdėliotos netinkama tvarka, pertvarkykite jas (pav. 18.8). Pav. 18.8: Kategorijų eilės tvarkos keitimas naudojant „BioStat“ režimą. Analogišką funkciją galima rasti ir klasikiniame „R Commander“ meniu. Kriterijų taikymas Kai išsirinksite kriterijų, naudodami „R Commander“ jį galėsite taikyti savo duomenims (pav. 18.9, 18.10). Programa „R“ sugeneruotų rezultatų pavyzdys su paaiškinimais pateiktas pav. 18.11. Pav. 18.9: Skirstinių padėties lyginimo metodų pasirinkimas naudojant standartinį meniu papildinyje „R Commander“: \\(P_1\\) ir \\(N_1\\) – vienos imties, \\(P_2\\) ir \\(N_2\\) – priklausomų imčių, \\(P_3\\) ir \\(N_3\\) – nepriklausomų imčių kriterijai. \\(P\\) – parametriniai, \\(N\\) – neparametriniai. Pav. 18.10: Skirstinių padėties lyginimo metodų pasirinkimas naudojant „EZR“ meniu papildinyje „R Commander“: \\(P_1\\) ir \\(N_1\\) – vienos imties, \\(P_2\\) ir \\(N_2\\) – priklausomų imčių, \\(P_3\\) ir \\(N_3\\) – nepriklausomų imčių kriterijai. \\(P\\) – parametriniai, \\(N\\) – neparametriniai. 18.4.6 Rezultatų, kuriuos pateikia R, pavyzdys Pav. 18.11: Programa „R“ pateiktų Welch (Velčo) \\(t\\) kriterijaus taikymo rezultatų pavyzdys. Panašios formos rezultatai gaunami taikant ir kitus šiame skyriuje pateiktus kriterijus. Šiuo konkrečiu atveju lyginamas ląstelių terpių, kuriose yra skirtingas anglies šaltinis, optinis tankis (OD) ties 600 nanometrų. Laikoma, kad kuo OD didesnis, tuo terpėje daugiau ląstelių. 18.5 Rezultatų aprašymas: padėties lyginimas Rezultatų aprašymo pavyzdys: „Lygintas dviejų terpių su ląstelėmis optinis tankis ties 600 nm. Skirtumas tarp terpės D (vidurkis 5,19) ir terpės GR (vidurkis 5,09) optinių tankių buvo statistiškai reikšmingas (Welch \\(t\\), dvipusė alternatyva, \\(t\\)(114,2) = 2,41, \\(p\\) = 0,017; vidurkių skirtumas yra 0,10, 95% PI 0,02–0,18).“ Apie statistinių rezultatų aprašymo principus skaitykite skyriuje 14.6. "],
["ht-anova-ir-analogai.html", "19. ANOVA ir jos analogai 19.1 Kurį vienfaktorės ANOVA variantą ar analogą pasirinkti? 19.2 Išsamios ANOVA analizės aspektai 19.3 Kaip atlikti kompiuteriu? 19.4 Pagrindinė analizė kompiuteriu 19.5 Post-hoc analizė kompiuteriu 19.6 Rezultatų aprašymas 19.7 Nuorodos", " 19. ANOVA ir jos analogai Užsiėmimo tikslas – susipažinti su statistinių hipotezių tikrinimo būdais kelioms nepriklausomoms imtims taikant dispersinę analizę (ANOVA) ar jai analogiškus statistinius kriterijus. ANOVA yra trumpasis dispersinės analizės (angl. ANalysis Of VAriance) pavadinimas. Ši analizė arba jos analogai skirti lyginti kelių nepriklausomų grupių skirstinių padėtis. Paprasčiau sakant, skirta atsakyti į tokius klausimus: ar kelių skirtingų irisų rūšių vidutiniai žiedlapių dydžiai skiriasi? ar kelių gydymo metodų efektyvumas skiriasi? kurią iš terpių geriausia naudoti kituose eksperimento etapuose (t. y., ar ląstelės, auginamos keliose skirtingose terpėse, yra linkusios būti skirtingo dydžio?); kurį pašarą iš 6 turimų naudoti efektyviausia norint didžiausių viščiukų? Klasikinis ANOVA variantas – tai \\(t\\) kriterijaus analogas, kai norima palyginti dviejų ar daugiau nepriklausomų imčių (grupių) vidurkius. Sakykime, kad lyginame \\(k\\) grupių. Nulinė analizės hipotezė teigia, kad visų grupių vidurkiai lygūs, o jos alternatyva – bent dviejų grupių (kurių tiksliai – pasakyti negalima) vidurkiai skiriasi: Čia \\(i\\) ir \\(j\\) – lyginamų grupių numeriai. Atlikdami ANOVA pagal dispersijas tikriname, ar skirtumai tarp vidurkių yra statistiškai reikšmingi. Jei norime patikrinti, ar skirtumai tarp dispersijų yra reikšmingi, naudojame Levene (Livyno) kriterijų. Atkreipkite dėmesį, kad yra keli ANOVA variantai. Kai lyginimas atliekamas pagal vieną kategorinį kintamąjį (t. y., pagal vieną faktorių), ANOVA vadinama vienfaktore (angl. one-way ANOVA arba one factor ANOVA). Jei pagal du – dvifaktorė ir t.t. Yra ir specialių ANOVA variantų, skirtų priklausomoms imtims, pvz., blokuotųjų duomenų ANOVA. Taip pat yra neparametrinių variantų, tokių kaip Kruskal-Wallis kriterijus, kuris lygina nebe vidurkius, o tai, ar bent viena grupė yra linkusi turėti kitokias (didesnes arba mažesnes) reikšmės, nei visos kitos. Šiame skyriuje metu mokysimės taikyti tik vienfaktorės ANOVA modelį, skirtą nepriklausomoms duomenų imtims, bei šio modelio analogus, kai pažeidžiamos klasikinio vienfaktorės ANOVA modelio prielaidos (pvz., normalumas ar dispersijų homogeniškumas). 19.1 Kurį vienfaktorės ANOVA variantą ar analogą pasirinkti? Vienfaktorė ANOVA analizė grindžiama šiomis prielaidomis: Grupių duomenys yra nepriklausomi; Kiekvienos grupės kintamieji pasiskirstę normaliai (\\(X_{gr} \\sim \\mathcal{N}(\\mu_{gr},\\sigma^2_{gr})\\)); Grupių dispersijos yra lygios. Tad prieš atliekant ANOVA, reikia patikrinti duomenims keliamas prielaidas ir pasirinkti tinkamą analizės variantą ar neparametrinį jos analogą (pav. 19.1). Kai duomenų grupės yra nepriklausomos ir jų yra bent 3, įprastai renkamasi tarp klasikinės vienfaktorės ANOVA analizės, Welch \\(F\\) (Velčo \\(F\\)) kriterijaus (dar vadinamo Welch ANOVA), kai pažeidžiama lygių dispersijų prielaida, ir Kruskal-Wallis (Kruskalo-Voliso) kriterijaus, kai smarkiai pažeidžiama normalumo prielaida. Schema yra supaprastinta ir tik rekomendacinio pobūdžio. Jos tikslas – būti „atspirties tašku“ renkantis analizės metodą. Konkrečiu atveju gali būti išlygų, papildomų sąlygų arba pasirinkimo variantų, kurie schemoje nepažymėti. Pav. 19.1: Skirstinio padėties lyginimas kelioms imtims. Schema, padedanti išsirinkti reikiamą vienfaktorės nepriklausomų imčių (grupių) ANOVA variantą ar jos analogą. Apatinėje dalyje pateikiami keli galimi post-hoc analizės variantai, skirti grupes lyginti poromis. Skaičiais pažymėtų schemos dalių paaiškinimas pateiktas tekste žemiau. Spalvinio žymėjimo reikšmės pateiktos skyriuje „14.4 Schemos metodams pasirinkti“. Skaičiais pažymėtų 19.1 schemos dalių paaiškinimai: Jei imčių dydžiai vienodi arba panašūs, ANOVA atspari mažiems ir net vidutiniams normalumo ir lygių dispersijų prielaidų pažeidimams. Sprendžiant „iš akies“, dispersijos (ne standartiniai nuokrypiai) neturėtų skirtis daugiau kaip 3 kartus. „Vienodos formos“ reiškia, kad visų grupių skirstinių asimetrija (jei yra) – vienos krypties, o sklaida (dispersijos) – daugmaž vienoda. Jei visų grupių skirstinių forma vienoda ir skiriasi tik poslinkio parametru, t. y., skiriasi skirstinio padėtis (tokiems duomenims ir rekomenduojamas Kruskal-Wallis kriterijus), tada galime daryti išvadas apie grupių medianas. Šiuo atveju analizės rezultatai informatyvesni nei 5 punkto atveju. Jei lyginamų grupių skirstinių forma skirtinga (skiriasi dispersijos, būdinga skirtingos krypties asimetrija), išvadas darome tik apie tai, kad bent viena grupė yra linkusi būti kitokia (arba didesnė, arba mažesnė) nei kitos. Techniškai kalbant, išvadas darome tik apie vidutinius rangus, bet ne medianas. Todėl šie rezultatai mažiau informatyvūs nei 4 punkto atveju. Apie galimus ANOVA post-hoc analizės variantus: Tukey HSD (angl. honestly significant difference) kriterijaus taikymui duomenys turi būti normalieji, dispersijos lygios, o imties dydžiai (beveik) vienodi; Games-Howell kriterijaus taikymui duomenys turi būti normalieji, tačiau lygių dispersijų ir vienodų imties dydžių nereikalaujama. Kiekvienoje lyginamoje imtyje turi būti bent 6 nariai; Galima atlikti keletą nepriklausomų imčių (Stjudento ar Welch) \\(t\\) kriterijaus taikymo procedūrų, bet būtina naudoti daugybinių lyginimų \\(p\\) reikšmių korekcijos metodus (Holm, Bonferroni ar kitą procedūrą, kuri gali būti atlikta naudojant funkciją p.adjust()); Yra ir kitų čia nepaminėtų post-hoc kriterijų. Apie galimus Welch ANOVA post-hoc analizės variantus: Games-Howell kriterijui duomenys turi būti normalieji, tačiau lygių dispersijų ir vienodų imties dydžių nereikalaujama. Kiekvienoje lyginamoje imtyje turi būti bent 6 nariai; Galima keletą kartų taikyti Welch t kriterijų grupių poroms, bet būtina naudoti daugybinių lyginimų \\(p\\) reikšmių korekcijos metodus (Holm, Bonferroni ar kitą procedūrą, kuri gali būti atlikta naudojant funkciją p.adjust()); Yra kitų čia nepaminėtų kriterijų. Šie kriterijai privalo nereikalauti lygių dispersijų prielaidos. Apie galimus Kruskal-Wallis kriterijaus post-hoc analizės variantus: Galima taikyti arba Conover-Iman, arba Dunn kriterijų. Tačiau Conover-Iman kriterijus yra galingesnis. Bet kuriuo atveju gautoms \\(p\\) reikšmėms reikia atlikti Holm ar kitą daugybinių lyginimų \\(p\\) reikšmių korekciją (šiame skyrelyje nurodytas metodas tokią korekciją atlieka automatiškai). Galima keletą kartų lyginamų grupių poroms taikyti nepriklausomų imčių Mann-Whitney-Wilcoxon kriterijų, bet tokiu atveju būtina naudoti \\(p\\) reikšmių korekcijos metodus (Holm, Bonferroni ar kitą procedūrą, kuri gali būti atlikta naudojant, funkciją p.adjust()); Yra ir kitų čia nepaminėtų kriterijų. Jie privalo būti neparametriniai ir tikti nenormaliesiems duomenims. Tai schema 18.2. Jei imtys yra pakankamai didelės, o imčių didumai yra vienodi (arba panašūs), vienfaktorė ANOVA yra ganėtinai atspari nedideliems ir netgi vidutiniams nuokrypiams nuo pasiskirstymo normalumo ir lygių dispersijų (dispersijų homogeniškumo) prielaidų. 19.2 Išsamios ANOVA analizės aspektai 19.2.1 Eiga Jei reikia atlikti ANOVA ar į ją panašią analizę, rekomenduojama tokia eiga: tiksliai apsibrėžiamas klausimas; atliekama duomenų suvestinė ir nubraižomas grafikas, galintis padėti atsakyti į iškeltą klausimą; patikrinamos analizės prielaidos: ar duomenų imtys/grupės nepriklausomos: sprendžiame pagal tai, kaip buvo suplanuotas ir atliktas eksperimentas. ar duomenų pakankamai daug: geriausia, kai kiekvienoje grupėje bent po 15, jei grupių daug – bent po 20 atvejų; kitu atveju duomenys privalo skirstytis idealiai normaliai, grupių dispersijos tik nežymiai skirtis; jei duomenų per mažai, negalime patikimai patikrinti parametriniams kriterijams keliamų prielaidų: mažoms imtims/grupėms statistiniai kriterijai linkę rodyti, kad skirtumai yra statistiškai nereikšmingi net esant dideliems skirtumams; didelėms imtims/grupėms net maži skirtumai bus pripažįstami statistiškai reikšmingais. mažoms imtims geriau taikyti neparametrinius kriterijus; kiekvienos imties/grupės pasiskirstymo normalumo prielaida: ir į vieną liniją išsidėstę qq diagramos taškai, ir Shapiro-Wilk kriterijaus \\(p\\ge0,05\\) rodo, kad normalumo prielaida tenkinama; gali būti, kad šių dvejų metodų rezultatai nesutaps: mažoms imtims statistiniai kriterijai yra linkę rodyti, kad nuokrypis nuo normalumo yra statistiškai nereikšmingas, net kai jis yra didelis, didelėms imtims net ir nedidelis nuokrypis nuo normalumo yra pripažįstamas statistiškai reikšmingas. prielaidos tikrinimą atliekame kiekvienai grupei atskirai (qq grafikai braižomi ir Shapiro-Wilk kriterijus atliekamas tiek kartų, kiek yra lyginamų grupių).. lygių dispersijų prielaida: jei ir Levene/Brown-Forsythe kriterijaus \\(p\\ge0,05\\), ir mažiausia bei didžiausia grupių dispersijos skiriasi mažiau nei 3 kartus, lygių dispersijų prielaida tenkinama; pastaba: mažoms grupėms statistiniai kriterijai bus linkę rodyti, kad dispersijų skirtumai (net labai dideli) nėra statistiškai reikšmingi; didelėms grupėms net ir menkiausi skirtumai bus pripažįstami statistiškai reikšmingais; dispersijas apskaičiuojame kiekvienai grupei atskirai, bet Levene/Brown-Forsythe kriterijų taikome tik vieną kartą, nes jis lygina visų grupių dispersijas iš karto. teisingai pasirenkama ir atliekama pagrindinė analizė; jei rezultatas statistiškai reikšmingas (rodo, kad bent viena grupė nuo kitų skiriasi statistiškai reikšmingai), atliekama papildoma post-hoc analizė (poriniai palyginimai norint išsiaiškinti, kurios konkrečiai grupės skiriasi). rezultatai aprašomi. 19.2.2 Kompaktiškas raidinis žymėjimas (cld) Sakykime, kelias grupes lyginame poromis. Statistiškai reikšmingus rezultatus tarp grupių, kai lyginimų daug, galime pažymėti taip vadinamu kompaktišku raidiniu žymėjimu (angl., compact letter display, cld). Šio žymėjimo esmė: kiekvienai grupei suteikiama viena ar keletas raidžių. Interpretacija: tarp grupių, kurios neturi bendros raidės, skirtumai yra statistiškai reikšmingi. Jei grupės turi bent vieną bendrą cld raidę – skirtumai statistiškai nereikšmingi. Raidinis žymėjimas labai patogus, kai vienu metu poromis lyginame daug grupių. Lentelė 19.1: Kompaktiško raidinio žymėjimo (cld) pavyzdys lyginant grupes „Kontrolė“, „Terpė_I“ ir „Terpė_II“. Grupė cld Sulygiuotas cld Kontrolė ab ab Terpė_I a a_ Terpė_II b _b Lentelėje 19.1 rodoma, kad statistiškai reikšmingi skirtumai yra tik tarp grupių „Terpė_I“ ir „Terpė_II“, nes jos neturi bendros raidės. Tuo tarpu reikšmingų skirtumų tarp kontrolės ir kitų grupių nėra, nes jos turi po vieną bendrą cld raidę. 19.3 Kaip atlikti kompiuteriu? Šio darbo metu reikalingi „R“ paketai tidyverse, knitr, userfriendlyscience, rcompanion, PMCMRplus, DescTools. juos galite įsidiegti naudodami funkciją install.packages(). 19.3.1 Reikiama duomenų struktūra Visoms šiame skyriuje aprašytoms analizėms reikiama duomenų struktūra: vienas skaitinis ir vienas kategorinis kintamasis, kuriame bent dvi skirtingos kategorijos. Pvz.: head(my_data) ## y group ## 1 4.53 Kontrolė ## 2 5.87 Terpė_I ## 3 5.18 Kontrolė ## 4 5.37 Terpė_II ## 5 5.12 Terpė_II ## 6 4.81 Terpė_I Neteigsime, kad visais atvejais šiuos pavyzdžio duomenis nurodytais metodais analizuoti korektiška. Jie naudojami tik iliustracijai. 19.3.2 Cld kompiuteriu Paketo rcompanion funkcija cldList() – vienas iš būdų sudaryti kompaktišką rainį žymėjimą („19.2.2 Kompaktiškas raidinis žymėjimas (cld)). Svarbiausi funkcijos argumentai: comparison – lygintų grupių poros: grupių pavadinimai atskirti brūkšniu; p.value – (įprastai koreguotosios) kiekvieno palyginimo metu gautos \\(p\\) reikšmės; threshold – reikšmingumo lygmuo \\(\\alpha\\) (toks, kokį nurodėte koreguotas \\(p\\) reikšmes skaičiuojančiai funkcijai). Pavyzdys. Tarkime, post-hoc analizės metu poromis lyginome grupes „Kontrolė“, „Terpė_I“ ir „Terpė_II“. Lygintų grupių poroje kiekvienos lyginamos grupės pavadinimą kompiuterinė programa automatiškai sujungė brūkšneliu „-“ (dėl to grupės pavadinime brūkšnelio neturėtų būti) ir kiekvienam porinio palyginimo variantui apskaičiavo po (koreguotąją) \\(p\\) reikšmę. Pavyzdžiui: palyginimai &lt;- c(&quot;Kontrolė - Terpė_I&quot;, &quot;Kontrolė - Terpė_II&quot;, &quot;Terpė_I - Terpė_II&quot;) p_koreguota &lt;- c(0.15, 0.01, 0.50) Raidinis žymėjimas sudaromas taip: library(rcompanion) cldList(comparison = palyginimai, p.value = p_koreguota, threshold = 0.05) ## Group Letter MonoLetter ## 1 Kontrolė a a ## 2 Terpė_I ab ab ## 3 Terpė_II b b Interpretacija: su reikšmingumo lygmeniu \\(\\alpha\\) (šiuo atveju 0,05) galime teigti, kad „Kontrolė“ statistiškai reikšmingai skiriasi nuo „Terpė_II“, nes neturi bendros raidės. Tarp kitų grupių skirtumai nėra reikšmingi, nes jos turi bent po vieną bendrą raidę. Kitų skyrių pavyzdžiuose programos kodas, kuriame naudojama cldList(), bus parašytas už jus. Jums tereikės mokėti jį nukopijuoti ir interpretuoti rezultatus. Jei reikia daugiau informacijos, skaitykite funkcijos dokumentacijoje: ?rcompanion::cldList. 19.3.3 Programos kodai: modelio formulė Kai kurioms funkcijoms – ypač toms, kurios vykdo statistinę analizę – duomenis galime pateikti naudodami modelio formulę. Modelio formulę sudaro užrašas, kuriame naudojama bangelė (~, tariama „pagal“), ir įprastai yra kokios dalys (pavyzdys): y ~ group, data = my_data Užrašą y ~ group reiktų skaityti „y pagal group“. Šiuos elementus turite pakeisti pagal savo duomenis šitaip: my_data – jūsų duomenų lentelės pavadinimas (be kabučių); y – skaitinio kintamojo iš šios lentelės pavadinimas (be kabučių); group – kategorinio kintamojo iš šios lentelės pavadinimas (be kabučių). Sakykime, jei jūs tiriate ląstelių skaičiaus pasiskirstymą (kintamasis skaičius) ląsteles augindami skirtingose terpėse (kintamasis terpė), o duomenys įrašyti duomenų lentelėje ląstelės, tada turite rašyti (y tampa skaičius, grupe → terpė, duomenys → ląstelės): skaičius ~ terpė, data = ląstelės Ir, pvz., stačiakampės diagramos braižymas gali atrodyti šitaip: boxplot(skaičius ~ terpė, data = ląstelės) 19.3.4 Programos kodai: funkcija with() Kai kurios funkcijos nepalaiko modelio formulės. Tokiais atvejais naudosime funkciją with(). Tad tokiu atveju tos pačios stačiakampės diagramos braižymo kodas atrodytų taip: with(ląstelės, (boxplot(skaičius ~ terpė)) Daugiau informacijos funkcijos dokumentacijoje: ?with. 19.3.5 Duomenų suvestinės Įsikėlę duomenis būtinai pasižiūrime į duomenų struktūrą, viršutines ir apatines eilutes, palyginame, ar teoriniai duomenų tipai (kategoriniai ir t. t.) atitinka „R“ duomenų klases (pvz., factor). Jei neatitinka, atliekame korekcijas. Po to atliekamos duomenų suvestinės. Jas galima atlikti papildiniu „R Commander“. Šiuo atveju pateikti programos kodai. library(tidyverse) library(knitr) library(DescTools) options(scipen = 8) dplyr::glimpse(my_data) ## Observations: 30 ## Variables: 2 ## $ y &lt;dbl&gt; 4.53, 5.87, 5.18, 5.37, 5.12, 4.81, 3.59, 4.89, 4.41, 4.... ## $ group &lt;fct&gt; Kontrolė, Terpė_I, Kontrolė, Terpė_II, Terpė_II, Terpė_I... summary(my_data) ## y group ## Min. :3.590 Kontrolė:10 ## 1st Qu.:4.550 Terpė_I :10 ## Median :5.155 Terpė_II:10 ## Mean :5.073 ## 3rd Qu.:5.530 ## Max. :6.310 Suvestinė pogrupiams (gali būti, kad jums lengviau ją atlikti naudojant „R Commander“). my_data %&gt;% group_by(group) %&gt;% summarize(n = n(), vidurkis = mean(y), nupjautinis_vid = mean(y, trim = 0.1), mediana = median(y), dispersija = var(y), sd = sd(y), IQR = IQR(y), MAD = mad(y), min = min(y), max = max(y)) %&gt;% knitr::kable(digits = c(1, 1, 1, 1, 1, 2, 1, 1, 1, 1)) group n vidurkis nupjautinis_vid mediana dispersija sd IQR MAD min max Kontrolė 10 5.0 5.0 5.2 0.34 0.6 0.7 0.7 4.2 6.1 Terpė_I 10 4.7 4.6 4.6 0.63 0.8 0.7 0.5 3.6 6.0 Terpė_II 10 5.5 5.5 5.4 0.20 0.4 0.5 0.4 4.9 6.3 Matome, kad yra 2 kintamieji: skaitinis ir kategorinis. Yra 3 skirtingos kategorijos. Duomenys yra nepriklausomi, nes tas pats augalas negali būti auginamas iš karto keliomis skirtingomis sąlygomis. Yra daugiau nei 2 grupės, pagal kurias norima lyginti skaitinį kintamąjį, vadinasi, tinka kažkuris ANOVA variantas arba analogiškas kriterijus. Greitą ir pakankamai išsamią skaitinę ir grafinę suvestinę pogrupiams galite atlikti naudodami funkciją DescTools::Desc(). ANOVA analizei atvaizduojamas duomenų pasiskirstymas pogrupiais. Tam tinka stačiakampės, branduolių tankio, smuikinės ir kitos diagramos. DescTools::Desc(y ~ group, data = my_data) ## ------------------------------------------------------------------------- ## y ~ group ## ## Summary: ## n pairs: 30, valid: 30 (100.0%), missings: 0 (0.0%), groups: 3 ## ## ## Kontrolė Terpė_I Terpė_II ## mean 5.032 4.661 5.526 ## median 5.155 4.550 5.435 ## sd 0.583 0.794 0.443 ## IQR 0.743 0.662 0.467 ## n 10 10 10 ## np 33.333% 33.333% 33.333% ## NAs 0 0 0 ## 0s 0 0 0 ## ## Kruskal-Wallis rank sum test: ## Kruskal-Wallis chi-squared = 7.9882, df = 2, p-value = 0.01842 Apie grafikų interpretaciją rašoma skyriuje („14.5.2 Grafinis grupių palyginimas“). 19.3.6 Duomenų pertvarkymas Kaip pastebėjote, vienfaktorei ANOVA, kaip ir kitoms nepriklausomų imčių analizėms, duomenys turi būti pateikti ilguoju formatu. Jei turime plačiojo formato duomenis (pav. 18.4), juos pertvarkome naudodami funkciją gather() iš paketo dplyr arba naudodami „R Commander“ meniu funkcijomis. Apie šią procedūrą plačiau rašoma poskyriuose „Pasirengimas“ ir „Priklausomų imčių analizės ypatumai“. Toliau dėl patogumo grupes galima išdėlioti pagal grupių medianos (ar kitos statistikos) dydį: my_data_2 &lt;- my_data %&gt;% mutate(group = fct_reorder(group, y, .fun = median, .desc = TRUE)) Rezultatas: my_data_2 %&gt;% Desc(y ~ group, data = .) %&gt;% plot() Dažnai reikia, kad kontrolinė grupė būtų pirmoji. Šiuo tikslu galite naudoti funkciją fct_relevel(). Vietoje group (ar matote, kad kode pasikartoja 2 kartus) įrašykite savo kintamojo pavadinimą (be kabučių), o vietoje \"Kontrolė\" – kontrolinės grupės pavadinimą (kabutėse), ir ji bus perkeliama į priekį. my_data_3 &lt;- my_data_2 %&gt;% mutate(group = fct_relevel(group, &quot;Kontrolė&quot;)) Rezultatas: my_data_3 %&gt;% Desc(y ~ group, data = .) %&gt;% plot() 19.3.7 Normalumo ir dispersijų homogeniškumo tikrinimas Dispersinės analizės normalumo ir homoskedastiškumo (lygių dispersijų) prielaidas galima tikrinti dviem būdais: Taip, kaip tai įprastai atliekama statistiniams kriterijams (skaitykite skyriuje „16 Normalumo tikrinimas“ bei „17 Sklaidos lyginimas“). Normaliojo pasiskirstymo prielaidą turėtų tenkinti kiekviena grupė atskirai. ANOVA ir regresinė analizė yra tiesinių modelių rūšys. Todėl ANOVA normalumo prielaidą galima tikrinti ir pagal liekamąsias paklaidas (plačiau bus rašoma skyriuje „21 Tiesinė regresija“, kurios turi būti normaliosios ir išsidėsčiusios homoskedastiškai. 19.4 Pagrindinė analizė kompiuteriu 19.4.1 ANOVA Klasikinės dispersinės analizės variantas tinka, jei kelioms nepriklausomoms normaliai pasiskirsčiusioms pakankamai didelėms grupėms lyginti, kurių dispersijos daugmaž vienodo dydžio. Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Analizė model_anova &lt;- aov(y ~ group, data = my_data) model_anova_summary &lt;- summary(model_anova) # Rezultatų spausdinimas print(model_anova_summary) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## group 2 3.766 1.8832 4.846 0.0159 * ## Residuals 27 10.492 0.3886 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 \\(P\\) reikšmė parašyta ties Pr(&gt;F). # Grafinė modelio diagnostika op &lt;- par(mfrow = c(2, 2)); plot(model_anova); par(op) 19.4.2 Welch ANOVA (Welch F kriterijus) Metodas tinka kelioms nepriklausomoms normaliai pasiskirsčiusioms pakankamai didelėms grupėms lyginti, jei netenkinama lygių dispersijų prielaida. Klasikinės dispersinės analizės analogas. Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Analizė model_welch_anova &lt;- oneway.test(y ~ group, data = my_data) # Rezultatų spausdinimas print(model_welch_anova) ## ## One-way analysis of means (not assuming equal variances) ## ## data: y and group ## F = 5.181, num df = 2.000, denom df = 17.128, p-value = 0.01739 \\(P\\) reikšmė aprašyta ties p-value. 19.4.3 Kruskal-Wallis kriterijus Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. # Analizė model_kw_test &lt;- kruskal.test(y ~ group, data = my_data) # Rezultatų spausdinimas print(model_kw_test) \\(P\\) reikšmė aprašyta ties p-value. Šį kriterijų automatiškai apskaičiuoja funkcija Desc() iš paketo DescTools. library(DescTools) options(scipen = 8) Desc(y ~ group, data = my_data) Mus dominanti rezultatų dalis: Kruskal-Wallis rank sum test: Kruskal-Wallis chi-squared = 7.9882, df = 2, p-value = 0.01842 19.5 Post-hoc analizė kompiuteriu 19.5.1 Post-hoc: Tukey HSD kriterijus Jei duomenys normalieji, imčių dispersijos yra lygios ir visų lyginamų imčių dydžiai (daugmaž) vienodi, Tukey HSD (Tukio HSD) kriterijus (angl. HSD – honestly significant difference) yra tinkamas naudoti kaip ANOVA post-hoc analizė, kurios metu atliekami poriniai palyginimai. Naudojama paketo userfriendlyscience funkcija posthocTGH() (metodas method = \"Tukey\") nepalaiko modelio formulės, todėl naudojame pagalbinę funkciją with(). library(userfriendlyscience) rez_tukey &lt;- with(my_data, posthocTGH(y, group, method = &quot;Tukey&quot;, digits = 3)) rez_tukey ## n means variances ## Kontrolė 10 5.03 0.340 ## Terpė_I 10 4.66 0.630 ## Terpė_II 10 5.53 0.196 ## ## diff ci.lo ci.hi t df p ## Terpė_I-Kontrolė -0.371 -1.062 0.32 1.33 27 .391 ## Terpė_II-Kontrolė 0.494 -0.197 1.19 1.77 27 .198 ## Terpė_II-Terpė_I 0.865 0.174 1.56 3.10 27 .012 Žymėjimai: n – imties (grupės) dydis; means – grupių vidurkiai; variances – grupių dispersijos. diff – vidutinis skirtumas tarp grupių; ci.lo – viršutinis skirtumo pasikliautinojo intervalo (PI) rėžis; ci.hi – apatinis skirtumo PI rėžis; t – \\(t\\) statistika; df – \\(t\\) skirstinio parametras – laisvės laipsniai; p – porinio lyginimo \\(p\\) reikšmė. Kompaktiškas raidinis žymėjimas. library(rcompanion) cldList(comparison = rez_tukey$intermediate$pairNames, p.value = rez_tukey$output$tukey$p, threshold = rez_tukey$intermediate$alpha) ## Group Letter MonoLetter ## 1 Terpė_I a a ## 2 Terpė_II b b ## 3 Kontrolė ab ab Su pasirinktu reikšmingumo lygmeniu \\(\\alpha\\), tarp grupių, kurios pažymėtos ta pačia raide, skirtumai nėra statistiškai reikšmingi. Jei reikšmingų sirtumų nebus rasta nei tarp vienos poros, pamatysite užrašą: Error: No significant differences. 19.5.2 Post-hoc: Games-Howell kriterijus Jei imčių dispersijos nėra lygios ir/arba grupių dydžiai smarkiai skiriasi, Games-Howell kriterijus yra tinkamas atlikti klasikinės ANOVA arba Welch ANOVA analizės post-hoc analizę (porinius palyginimus). Nudojama paketo userfriendlyscience funkcija posthocTGH() (metodas method = \"Games-Howell\") nepalaiko modelio formulės, todėl naudojame pagalbinę funkciją with(). library(userfriendlyscience) rez_games_howell &lt;- with(my_data, posthocTGH(y, group, method = &quot;Games-Howell&quot;, digits = 3)) rez_games_howell ## n means variances ## Kontrolė 10 5.03 0.340 ## Terpė_I 10 4.66 0.630 ## Terpė_II 10 5.53 0.196 ## ## diff ci.lo ci.hi t df p ## Terpė_I-Kontrolė -0.371 -1.172 0.43 1.19 16.5 .475 ## Terpė_II-Kontrolė 0.494 -0.101 1.09 2.13 16.8 .113 ## Terpė_II-Terpė_I 0.865 0.114 1.62 3.01 14.1 .024 Rezultatai analogiški tiems, kurie pateikti skyriuje 19.5.1. Kompaktiškas raidinis žymėjimas. library(rcompanion) cldList(comparison = rez_games_howell$intermediate$pairNames, p.value = rez_games_howell$output$games.howell$p, threshold = rez_games_howell$intermediate$alpha) ## Group Letter MonoLetter ## 1 Terpė_I a a ## 2 Terpė_II b b ## 3 Kontrolė ab ab Jei reikšmingų sirtumų nebus rasta nei tarp vienos poros, pamatysite užrašą: Error: No significant differences. 19.5.3 Post-hoc: Conover-Iman kriterijus Conover-Iman (Konoverio-Imano) kriterijus naudojamas, kaip neparametrinė post-hoc analizė po Kruskal-Wallis kriterijaus taikymo, jei gaunami statistiškai reikšmingi rezultatai. \\(P\\) reikšmės įprastai papildomai koreguojamos siekiant sumažinti klaidingų atradimų (I rūšies klaidos) tikimybę. Pavyzdyje bus naudojama Holm (Holmo) korekcija. Conover-Iman kriterijų galima taikyti tada ir tik tada, kai Kurskal-Wallis kriterijaus rezultatai yra statistiškai reikšmingi. Galime naudoti arba kwAllPairsConoverTest() (tarpusavyje lygina kiekvieną grupę su kiekviena) arba kwManyOneConoverTest() (lygina kontrolę su kiekviena grupe, bet kitų grupių tarpusavyje nelygina, kontrole laikoma pirmoji kategorinio kintamojo kategorija) iš paketo PMCMRplus. Pavyzdyje pateiktus kodo elementus y ~ group, data = my_data reikia pakeisti tinkamais savo duomenims. library(PMCMRplus) atsakymas &lt;- kwAllPairsConoverTest(y ~ group, data = my_data, p.adjust.method = &quot;holm&quot;) ## Warning in kwAllPairsConoverTest.default(c(4.53, 5.87, 5.18, 5.37, 5.12, : ## Ties are present. Quantiles were corrected for ties. Jei pamatysite užrašą Ties are present. Quantiles were corrected for ties., vadinasi jūsų domenyse yra sutampančių reikšmių (angl. ties arba tied data – sutampančios reikšmės). Rezultatai kaip \\(p\\) reikšmių matrica: print(atsakymas) ## ## Pairwise comparisons using Conover&#39;s all-pairs test ## data: y by group ## Kontrolė Terpė_I ## Terpė_I 0.216 - ## Terpė_II 0.132 0.011 ## ## P value adjustment method: holm Rezultatai kaip \\(p\\) reikšmės (Pr(&gt;|t|)) parašytos stulpeliais (t value – kriterijaus statistika; žvaigždutėmis žymimi statistiškai reikšmingi rezultatai): summary(atsakymas) ## ## Pairwise comparisons using Conover&#39;s all-pairs test ## data: y by group ## P value adjustment method: holm ## H0 ## t value Pr(&gt;|t|) ## Terpė_I - Kontrolė == 0 -1.267 0.215966 ## Terpė_II - Kontrolė == 0 1.915 0.132301 ## Terpė_II - Terpė_I == 0 3.182 0.010983 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Grafikas su cld žymėjimais: plot(atsakymas) 19.6 Rezultatų aprašymas Parametriniai metodai – klasikinė ANOVA ir Welch \\(F\\) kriterijus – lygina duomenų vidurkius (vidurkis yra normaliojo skirstinio parametras), todėl aprašant šios analizės rezultatus reikia nurodyti grupių vidurkius. Tuo tarpu Kruskal-Wallis kriterijaus yra neparametrinis, bendresnis ir lygina, ar duomenų skirstiniai pagal savo padėtį skiriasi, t. y., ar bent viena grupė yra linkusi būti mažesnė arba didesnė už kitas. Aprašant Kruskal-Wallis analizės rezultatus nurodomos visų grupių medianos. Jei grupių daug – vidurkiai/medianos nurodomi lentele. Taip pat nurodomas kriterijaus pavadinimas, kriterijaus statistika, parametrai ir \\(p\\) reikšmė. Geriausia, jei būtų pateikiamas grupių palyginimo grafikas. Taip pat peržvelkite informacją, pateiktą skyriuje „14.6 Rezultatų aprašymo principai\". 19.6.1 ANOVA rezultatai Aprašyme pateikiamas tikslus taikytos analizės pavadinimas, kriterijaus statistika \\(F\\) įprastai 2 skaičių po kablelio tikslumu, abu jos laisvės laipsniai (tiek skaitiklio, angl. numerator, tiek vardiklio, angl. denominator) ir \\(p\\) reikšmė 3-4 skaičių po kablelio tikslumu. Pvz.: ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## group 2 3.766 1.8832 4.846 0.0159 * ## Residuals 27 10.492 0.3886 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Stulpelyje Df pateikti laisvės laipsniai, F value – \\(F\\) statistika, Pr(&gt;F) – \\(p\\) reikšmė. Šių rezultatų aprašymo pavyzdys: „Skirtumai tarp grupių vidurkių buvo statistiškai reikšmingi (ANOVA, \\(F\\)(2; 27) = 4,85, \\(p\\) = 0,016). Grupių vidurkiai pateikti lentelėje (nurodome lentelės numerį)“. Papildomai reiktų nurodyti grupių vidurkius ir, geriausia, pateikti grafiką su grupių palyginimu. 19.6.2 Welch ANOVA rezultatai Welch ANOVA rezultatų pavyzdys: ## ## One-way analysis of means (not assuming equal variances) ## ## data: fscore and fcategory ## F = 90.59, num df = 2.000, denom df = 25.563, p-value = ## 0.000000000002494 Čia F – \\(F\\) statistika, num df – skaitiklio laisvės laipsniai, denom df – vardiklio laisvės laipsniai (įprastai 2 skaičių po kablelio tikslumu), p-value – \\(p\\) reikšmė (3, kartais 4 skaičių po kablelio tikslumu). Tad analizės rezultatai turėtų būti apibūdinti taip: „(Welch \\(F\\) kriterijus, \\(F\\)(2; 25,56) = 90,59, \\(p\\) &lt; 0,0001)“. 19.6.3 Kruskal-Wallis analizės rezultatai Aprašant neparametrinio Kruskal-Wallis kriterijaus rezultatus pateikiamas kriterijaus pavadinimas, kriterijaus statistika \\(\\chi^2\\), naudotino \\(\\chi^2\\) skirtinio laisvės laipsniai bei \\(p\\) reikšmė 3-4 skaičių po kablelio tikslumu. Jei \\(p\\) reikšmė labai maža, tai ją rašome maždaug taip \\(p\\) &lt; 0,001 ar \\(p\\) &lt; 0,0001. Pvz.: ## ## Kruskal-Wallis rank sum test ## ## data: Ozone by Month ## Kruskal-Wallis chi-squared = 29.267, df = 4, p-value = 0.000006901 Aprašymas turėtų atrodyti maždaug taip: „Skirtumai tarp grupių buvo statistiškai reikšmingi (Kruskal-Wallis kriterijus, \\(\\chi^2(4)\\) = 29,27, \\(p\\) &lt; 0,001). Grupių pasiskirstymas vaizduojamas grafike /nurodome grafiko numerį/, skaitinės suvestinės pateiktos lentelėje /nurodome lentelės numerį/“. Reikšmė chi-squared nurodo \\(\\chi^2\\) statistiką, df – skirstinio parametrą pavadinimu „laisvės laipsniai“, p-value – \\(p\\) reikšmę. Papildomai turėtų būti pateiktos visų grupių medianos ir, geriausia, grafikai. 19.6.4 Post-hoc analizės rezultatai Jei atlikta post-hoc analizė, jos rezultatai taip pat aprašomi ir tai daroma panašiai kaip ir \\(t\\) ar Wilcoxon kriterijų aprašymo atvejais. Tiksliai apibūdinamas ir analizės metodas ir \\(p\\) reikšmių korekcijos metodas (jei jis taikytas). Nurodoma, kurių būtent porų lyginimo rezultatas pateikiamas (visų tarpusavyje, visu su kontrole ar pan.). Jei rezultatų daug – jie gali būti pateikiami lentele. Rekomenduoju naudoti cld žymėjimus (skyrelis 19.2.2) ir paaiškinti, ką tie žymėjimai reiškia. 19.7 Nuorodos ANOVA pavyzdžiai: „One-Way ANOVA Test in R “ ; ANOVA „Personality Project“ tinklapyje. „Situation - One-Way ANOVA“ . „ANOVA model diagnostics including QQ-plots“ . ANOVA pavyzdys su post-hoc“ . ANOVA pavyzdys su post-hoc“ . "],
["rysys-tarp-kintamuju.html", "20. Ryšys tarp kintamųjų 20.1 Bendrieji principai 20.2 Koreliacinė analizė 20.3 Sąsaja tarp kategorinių kintamųjų reikšmių 20.4 Ryšio tarp kintamųjų analizė naudojant R Commander", " 20. Ryšys tarp kintamųjų Šio skyriaus medžiaga vis dar rengiama arba neatnaujinta šių metų kursui, todėl kol kas jos nenagrinėkite. Šiame skyriuje bus mokoma atlikti analizę, kuria tiriamas ryšys (sąsaja) tarp kintamųjų. Tokia analizė gali padėti atsakyti į klausimą, ar yra ryšys tarp į terpę įdėtos gliukozės kiekio ir ląstelių dydžio, tarp padarytų pritūpimų skaičiaus ir pulso dažnumo, tarp ląstelių rūšies ir dydžio (didelės/mažos), tarp valandų skaičiaus besirengiant atsiskaitymui ir pažymio. T. y., ar pasikeitus vieno kintamojo reikšmėms, tikėtina, kad analogiška (arba priešinga) kryptimi pasikeis ir kito kintamojo reikšmės. Užsiėmimo tikslas – išmokti įvertinti sąsajos tarp kintamųjų reikšmių stiprumą. 20.1 Bendrieji principai 20.1.1 Sąsaja neparodo priežastingumo Atliekant sąsajos tarp kintamųjų analizę, svarbu prisiminti, kad: Nustatyta sąsaja tarp kelių kintamųjų reikšmių pati savaime neparodo priežastingumo. Bei kad: Koreliacija pati savaime neparodo priežastingumo. Tai, kad dviejų kintamųjų reikšmės yra susijusios ar koreliuoja, dar nereiškia, kad vienas kintamasis yra kito kintamojo priežastis. Norint pagrįsti preižastingumą, būtinar reikia pagrįsti dar bent 2 dalykus: abu tiriamieji reiškiniai yra nutolę laike, t. y., vyksta ne tuo pačiu metu, tas reikšinys, kuris laikomas priežastini, visada įvyksta anksčiau nei tas, kuris laikomas pasėkme. Deja, nei koreliacinė, nei kitokia požymių nepriklausomumo analizė savaime šių dalykų neparodo. Analizės rezultatai gali atskleisti tik tai, kad kintant vieno požymio reikšmėms, tikėtina, kis ir kito požymio reikšmės. Norint daryti priežastinio tipo išvadas būtinas tikslingai suplanuotas eksperimentas. Be to dažna situacija, kad abudu mūsų tiriamieji kintamieji yra trečiojo, tyrime netiriamo kintamojo pasėkmė. 20.1.2 Statistinis sąsajos reikšmingumas Norint patikrinti, ar ryšys tarp kintamųjų yra statistiškai reikšmingas, tikrinama statistinė hipotezė, kuri bendruoju atveju, gali būti formuluojama taip: \\(H_0\\): dviejų požymių reikšmės nėra susijusios (sąsajos stiprumas lygus nuliui); \\(H_1\\): dviejų požymių reikšmės yra susijusios (sąsajos stiprumas nelygus nuliui). „Požymių reikšmės susijusios“ reiškia, kad žinodami vieno požymio reikšmes (ir jų kitimą) gauname papildomos informacijos ir apie kito požymio reikšmes (ir jų kitimą). Pvz., kad padidėjus vieno kintamojo reikšmėms (pvz., atliktų pritūpimų skaičiui), tikėtina, padidės ir kito kintamojo (pvz., pulso dažnis) reikšmės. Jei reikšmingumo lygmuo \\(\\alpha =\\) 0,05, tai, kai: \\(p &lt;\\) 0,05, teigiame, kad požymiai susiję (priimame \\(H_1\\), sąryšis statistiškai reikšmingas); \\(p \\ge\\) 0,05, teigti, kad požymiai susiję negalime (neatmetame \\(H_0\\), sąryšis statistiškai nereikšmingas). Koreliacinės analizės, kuri yra skirta įvertinti tiesinį (arba monotoninį) ryšį tarp skaitinių (arba ranginių) kintamųjų, atveju statistines hipotezes galima formuluoti taip: \\(H_0\\): koreliacijos koeficientas lygus nuliui, koreliacijos nėra; \\(H_1\\): koreliacijos koeficientas nelygus nuliui, kintamieji yra koreliuoti (dvipusė alternatyva). Galimos ir vienpusės alternatyvos: koreliacijos koeficientas mažesnis už nulį, kintamieji koreliuoti neigiamai (vienpusė alternatyva); koreliacijos koeficientas didesnis už nulį, kintamieji koreliuoti teigiamai (vienpusė alternatyva). Nors yra 3 alternatyvų variantai, jei neturime pagrindo rinktis kitaip, įprastai renkamės dvipusę. 20.1.3 Sąsajos stiprumas Visiems šiame skyriuje minimiems ryšio matams (koreliacijos koeficientams ir kitiems) galioja tokios taisyklės: kuo absoliučioji koeficiento vertė didesnė, tuo priklausomybė tarp požymių reikšmių yra stipresnė; įprastai maksimali absoliučioji koeficientų vertė būna 1 (t. y., \\(|1|\\) arba \\(|-1|\\), čia \\(|...|\\) – modulio ženklas); kuo ši vertė arčiau nulio, tuo matuojamo tipo sąsaja silpnesnė. 20.2 Koreliacinė analizė Koreliacinė analizė yra vienas iš analizės tipų, skirtų įvertinti statistinę sąsają (ryšį) tarp dviejų kintamųjų. Tinka, kai statistinis ryšys tarp kintamųjų yra monotoninis (negriežtai sakant, arba nuolat didėjantis ir protarpiais nekintantis, arba nuolat mažėjantis ir protarpiais nekintantis) ir netinka, kai ryšys yra kitokio pobūdžio (pvz., iš pradžių mažėja, o po to didėja, pvz., pav. 20.1 trečia eilutė). Iš to išplaukia, kad kintamieji turi būti skaitiniai arba ranginiai, bet turėti pakankamai daug skirtingų reikšmių. Kitu atveju naudojama kategorinių kintamųjų ryšiui tirti skirta analizė. Koreliacijos koeficientas parodo tiesinio, jei koreliacija tiesinė, arba ranginio, jei koreliacija ranginė, sąryšio tarp 2 kintamųjų stiprumą: t. y., ar tikėtina, kad padidėjus vieno kintamojo reikšmėms, padidės (arba sumažės) ir kito kintamojo reikšmės (ką tai reiškia ir ko nereiškia, vaizduojama pirmoje ir antroje pav. 20.1 eilutėse). Įprastai, jei neminima, apie kurį koreliacijos koeficientą kalbama, omenyje turimas Pearson (Pirsono) tiesinės koreliacijos koeficientas. Visgi, aprašant savo tyrimo rezultatus, rekomenduoju vengti dviprasmybės ir aiškiai nurodyti, kurį koreliacijos koeficientą naudojate. Keletas teiginių apie koreliacinę analizę: Koreliacijos koeficientas nepriklauso nuo kintamųjų matavimo vienetų. Kinta nuo -1 iki +1; Ypatingieji taškai: -1, 0, +1; Koeficiento ženklas: teigiamas koeficientas rodo tiesioginę priklausomybę (padidėjus X reikšmėms, tikėtina, padidėja ir Y reikšmės); neigiamas – atvirkštinę (padidėjus X reikšmėms, tikėtina, Y reikšmės sumažėja). Koreliacijos stiprumą rodo absoliučioji koeficiento reikšmė: konkreti interpretacija priklauso nuo tyrimo srities; preliminarus vertinimas pateiktas 20.1 lentelėje. Jei dydžiai koreliuoja, vadinasi – jie yra priklausomi, bet jei nekoreliuoja, tada gali būti visaip: ir priklausomi (pvz., netiesiškai), ir nepriklausomi. Koreliacija laikoma statistiškai reikšminga, kai \\(p\\) reikšmė yra maža (pvz., kai \\(p &lt;\\) 0,05, jei \\(\\alpha =\\) 0,05). Iš principo toks rezultatas rodo, kad koreliacijos koeficientas (žymėkime \\(\\varrho\\)) statistiškai reikšmingai skiriasi nuo 0 \\((\\varrho \\ne 0)\\). Generalinės aibės tiesinės koreliacijos koeficientas įprastai žymimas \\(\\varrho\\), o jo įvertis, apskaičiuotas iš imties duomenų, žymimas \\(r.\\) Koeficientas \\(r\\) yra atsitiktinis dydis (dėl to, kad imtis sudaryta atsitiktinai), tad jo reikšmė gali būti didelė, nors tikrasis \\(\\varrho = 0\\). Dėl to ir tikriname statistinį reikšmingumą (t. y., tikriname, ar iš turimų duomenų galime pagrįstai teigti, kad tikrasis koeficientas nelygus nuliui). Pav. 20.1: Grafiškai atvaizduoti dviejų kintamųjų priklausomybės variantai (sklaidos diagramos) ir Pearson (Pirsono) koreliacijos koeficientas (skaičius virš grafikų). Kiekviena eilutė vaizduoja tam tikrus koreliacinės analizės aspektus. (1) Pirmoji eilutė – ką Pearson koreliacijos koeficientas parodo tiesinės sąsajos stiprumą, t. y., kuo sąsaja stipresnė, tuo glaudžiau taškai išsidėsto į vieną tiesę. (2) Antroji eilutė – ko neparodo, tai geriausiai taškus atitinkančios regresijos tiesės pokrypio kampo. Apskritai, šios eilutės vidutiniam grafikui (horizontali linija) koreliacijos koeficientas negali būti apibrėžtas, nes y ašies reikšmių pokytis lygus nuliui. (3) Trečioji eilutė – kada netinka: kai statistinė priklausomybė tarp kintamųjų nėra tiesinė, didėjant X reikšmėms, Y ir didėja, ir mažėja. Tokiais atvejais priklausomybė yra, bet koreliacijos koeficientas jos neparodys. Iliustracijos šaltinis , autorius – DenisBoigelot, licencija – Creative Commons, CC0. Lentelė 20.1: Preliminarus Pearson koreliacijos koeficiento vertinimas. Preliminarus koreliacijos vertinimas Koreliacijos koeficiento reikšmės koreliacijos nėra 0 labai silpna [-0,2; 0) arba (0; 0,2 ] silpna [-0,4; -0,2) arba (0,2; 0,4] vidutinė [-0,7; -0,4) arba (0,4; 0, 7] stipri [-0,9; -0,7) arba (0,7; 0,9] labai stipri [-1,0; -0,9) arba (0,9 ; 1,0] tiesinis sąryšis -1 arba 1 20.2.1 Kurį koreliacijos variantą pasirinkti? Yra keli praktikoje dažnai naudojami koreliacinės analizės variantai: Tiesinė koreliacija (Pearson (Pirsono) koreliacijos koeficientas \\(\\varrho\\)) – tinka, kai ryšys tarp kintamųjų yra tiesinis, o duomenys yra skaitiniai ir be išskirčių. Įprastai norime patikrinti ir statistinį reikšmingumą (t. y., kaip labai tikėtina, kad sąsaja yra atsitinktinė), o tam papildomai reikia, kad duomenys būtų normalieji ir imties dydis pakankamai didelis, pvz., 20 ar didesnis (Čekanavičius ir Murauskas 2008, p.33): angl. Pearson product-moment correlation coefficient. Ranginė koreliacija (Spearman (Spirmeno) koeficientas \\(\\varrho_s\\) arba Kendall (Kendalo) koeficientas \\(\\tau\\)) – įprastai naudojamas, kai netenkinamos kai kurios tiesinei koreliacijai keliamos prielaidos. Tinka, kai ryšys yra nebūtinai tiesinis, bet monotoninis, duomenys nebūtinai normalieji arba ranginiai, yra išskirčių bei kai stebėjimų skaičius mažas. Ranginių koreliacijos koeficientų skaičiavimo prielaida yra ta, kad bendras analizuojamų požymių skirstinys yra tolydusis, t. y., yra mažai pasikartojančių reikšmių (Venclovienė 2010, p.175). Spearman (Spirmeno) ranginės koreliacijos koeficientas (angl. Spearman rank-order) yra populiaresnis (Field ir kt. 2012), bet jautresnis duomenų neatitikimui ir klaidoms; Kendall (Kendalo) koreliacijos koeficientas (angl. Kendall’s tau) – lengviau interpretuojamas nei Spirmeno (Venclovienė 2010, p.177), tiksliau įvertina tikrąją koreliaciją generalinėje aibėje, tad geriau generalizuoja (Field ir kt. 2012, p.225), labiau tinka mažoms imtims, kuriose yra daug pasikartojančių reikšmių (Field ir kt. 2012, p.225); Absoliučiąja reikšme Kendall koreliacijos koeficientas yra šiek tiek mažesnis už Spearman, bet padarytos išvados yra vienodai reikšmingos (Čekanavičius ir Murauskas 2008, p.39), jei koeficientai naudojami tinkamai. Schemoje 20.2 pateikiamas siūlymas, kaip išsirinkti tinkamą koreliacinės analizės variantą. Jei duomenys tenkina reikiamas prielaidas, įprastai pasirenkamas Pirsono koreliacijos koeficientas. Schema yra supaprastinta ir tik rekomendacinio pobūdžio. Jos tikslas – būti „atspirties tašku“ renkantis analizės metodą. Konkrečiu atveju gali būti išlygų, papildomų sąlygų arba pasirinkimo variantų, kurie schemoje nepažymėti. Pav. 20.2: Schema, rekomenduojanti, kurį (Pearson, Spearman ar Kendall) koreliacijos koeficientą pasirinkti. Spalvinio žymėjimo reikšmės pateiktos skyriuje „14.4 Schemos metodams pasirinkti“. 20.2.2 Prielaidų ir kitų reikalavimų tikrinimas Tiesiškumo prielaida. Ar tenkinama tiesiškumo prielaida, įvertinama iš sklaidos diagramos. Išskirtys. Aš yra išskirčių taip pat vertiname pagal sklaidis diagramą. Normaliojo pasiskirstymo prielaida. Duomenys turėtų tenkinti dvimačio normaliojo pasiskirstymo reikalavimą. Dažnai, jei kiekvienas tiriamasis kintamasis yra normalusis, tai ir dvimatis jų pasiskirstymas būna normalusis. Apie normalumo tikrinimą kiekvienam kintamajam atskirai plačiau skaitykite skyriuje „16 Normalumo tikrinimas“. Reikiama duomenų struktūra – du skaitiniai kintamieji: head(my_data) ## x y ## 1 181.9 2.0772 ## 2 152.6 2.0452 ## 3 184.6 2.1814 ## 4 164.1 1.9127 ## 5 155.9 2.1286 ## 6 173.3 1.8185 20.2.3 Rezultatų aprašymas: koreliacinė analizė Aprašant rezultatus nurodomas tikslus koreliacijos koeficiento pavadinimas, jo didumas, bei statistinį koreliacijos reikšmingumą apibūdinanti \\(p\\) reikšmė, jei reikia, nurodoma, ar vienpusė ar dvipusė alternatyva. Taip pat pateikiama sklaidos diagrama. Keli aprašymo pavyzdžiai pateikti skyriuje 20.2.5. 20.2.4 Simuliacija: Pirsono koreliacijos koeficientas Tai papildoma užduotis, todėl dabar ją praleiskite. Siekdami susipažinti su koreliacijos koeficientu ir jo grafine interpretacija, išbandysite interaktyvią simuliaciją „Koreliacijos koeficiento interpretacija “. Nuorodą atsidarykite atskirame lange ir atlikite 20.1 užduotį. Užduotis 20.1 Atskirame lange atsidarykite pareiktą nuorodą ir atsakykite į šiuos klausimus (nuoroda: http://rpsychologist.com/d3/correlation/): Kaip sklaidos diagramos taškų „debesėlio“ forma priklauso nuo pasirinkto koreliacijos koeficiento? Pasirinkite imties dydį („sample size“) lygų 100; Koreliacijos koeficientą keiskite nuo -1 iki +1 kas 0,25 (slankiklis „Slide me“); Naudodami tą patį koreliacijos koeficientą sugeneruokite 3-5 naujas imtis (tai atliksite pakartotinai paspaudę mygtuką „New sample“) ir pažiūrėkite, ką visos jos turi bendra. Užrašuose nusibraižykite, kaip atrodo sklaidos diagramos taškų „debesėlis“ naudojant kiekvieną išbandytą koreliacijos koeficientą. Visą simuliaciją pakartokite su kitokio dydžio imtimi. Kas pasikeičia, jei imties dydis yra: 20? 200? Kokią įtaką Pirsono koreliacijos koeficientui daro išskirtys? Imties dydis lygus 100, koreliacijos koeficientas – -0,8. Pele pasirinkite vieną tašką sklaidos diagramoje (užveskite žymeklį ir paspauskite dešinį pelės klavišą) ir neatleisdami klavišo nutempkite jį į viršutinį dešinį kampą. Įvertinkite, kaip pasikeitė koreliacijos koeficientas. Koreliacijos koeficientas – 0. Vėl pasirinkite vieną tašką ir nutempkite į tą patį kampą. Vėl įvertinkite, kaip pakito koreliacijos koeficientas. Simuliaciją pakartokite naudodami kitokio dydžio imtis (20, 200 ir pan.). Kokį įspūdį susidarėte: ar Pirsono koreliacijos koeficiento įvertis atsparus išskirtims? 20.2.5 Pavyzdžiai Pradžioje bus pateikiamas programos kodas ir „R“ rezultatai, po jų – rezultatų aprašymo pavyzdys. Pavyzdys 1 Panagrinėkime pavyzdį apie krabus. library(tidyverse) library(car) ## Loading required package: carData ## ## Attaching package: &#39;car&#39; ## The following object is masked from &#39;package:DescTools&#39;: ## ## Recode ## The following object is masked from &#39;package:dplyr&#39;: ## ## recode ## The following object is masked from &#39;package:purrr&#39;: ## ## some library(RcmdrMisc) ## Loading required package: sandwich library(DescTools) options(scipen = 8) library(qqplotr) library(ggstatsplot) data(crabs, package = &quot;MASS&quot;) glimpse(crabs) ## Observations: 200 ## Variables: 8 ## $ sp &lt;fct&gt; B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, B, B,... ## $ sex &lt;fct&gt; M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, M,... ## $ index &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1... ## $ FL &lt;dbl&gt; 8.1, 8.8, 9.2, 9.6, 9.8, 10.8, 11.1, 11.6, 11.8, 11.8, 1... ## $ RW &lt;dbl&gt; 6.7, 7.7, 7.8, 7.9, 8.0, 9.0, 9.9, 9.1, 9.6, 10.5, 10.8,... ## $ CL &lt;dbl&gt; 16.1, 18.1, 19.0, 20.1, 20.3, 23.0, 23.8, 24.5, 24.2, 25... ## $ CW &lt;dbl&gt; 19.0, 20.8, 22.4, 23.1, 23.0, 26.5, 27.1, 28.4, 27.8, 29... ## $ BD &lt;dbl&gt; 7.0, 7.4, 7.7, 8.2, 8.2, 9.8, 9.8, 10.4, 9.7, 10.3, 10.9... Mus domina kintamieji FL (frontal lobe size, mm) – priekinės skilties dydis milimetrais ir BD (body depth, mm) – kūno storis milimetrais. Ištirkime sąsają tarp šių požymių. Imtis didelė – 200 tiriamųjų. Toliau pažiūrėkime, ar ryšys tiesinis? Ar yra išskirčių? Desc(BD ~ FL, data = crabs) ## ------------------------------------------------------------------------- ## BD ~ FL ## ## Summary: ## n pairs: 200, valid: 200 (100.0%), missings: 0 (0.0%) ## ## ## Pearson corr. : 0.988 ## Spearman corr.: 0.987 ## Kendall corr. : 0.912 Grafiką galime nusibraižyti ir ggplot2 sistema. ggplot(crabs, aes(FL, BD)) + geom_smooth(method = lm, se = FALSE) + geom_point(alpha = 0.3) Panašu, kad ryšys yra tiesinis, duomenys – be aiškių išskirčių. Ar požymiai normalieji? Prielaidas tikrinti galime abiems kintamiesiems iš karto, jei duomenis pasiversime į ilgąjį formatą: crabs_grafikams &lt;- crabs %&gt;% gather(key = &quot;savybe&quot;, value = &quot;reiksme&quot;, FL, BD, factor_key = TRUE) RcmdrMisc::normalityTest(reiksme ~ savybe, data = crabs_grafikams) ## ## -------- ## savybe = FL ## ## Shapiro-Wilk normality test ## ## data: reiksme ## W = 0.99037, p-value = 0.2023 ## ## -------- ## savybe = BD ## ## Shapiro-Wilk normality test ## ## data: reiksme ## W = 0.99027, p-value = 0.1957 ## ## -------- ## ## p-values adjusted by the Holm method: ## unadjusted adjusted ## FL 0.20228 0.39131 ## BD 0.19565 0.39131 Arba kiekvienam kintamajam kintamajam atskirai. with(crabs, shapiro.test(FL)) ## ## Shapiro-Wilk normality test ## ## data: FL ## W = 0.99037, p-value = 0.2023 with(crabs, shapiro.test(BD)) ## ## Shapiro-Wilk normality test ## ## data: BD ## W = 0.99027, p-value = 0.1957 Imtis didelė, o Šapiro-Vilko (SW) kriterijaus \\(p\\) reikšmė didesnė už 0,05 abiem atvejais, tad normalumo prielaida tenkinama. Jei imtis būtų labai maža, šiais (statistiškai nereikšmingais) rezultatais galėtume abejoti. QQ diagramos (kelios iš karto): car::qqPlot(reiksme ~ savybe, data = crabs_grafikams) QQ diagramos po vieną: with(crabs, car::qqPlot(FL)) ## [1] 51 150 with(crabs, car::qqPlot(BD)) ## [1] 51 150 Diagramas galime nubraižyti ir ggplot2 būdu: # Paketo `qqplotr` dokumentacija: https://aloy.github.io/qqplotr/ ggplot(crabs, aes(sample = FL)) + stat_qq_band() + stat_qq_line() + stat_qq_point() + labs(x = &quot;Teoriniai kvantiliai&quot;, y = &quot;Duomenų kvantiliai&quot;) ggplot(crabs, aes(sample = BD)) + stat_qq_band() + stat_qq_line() + stat_qq_point() + labs(x = &quot;Teoriniai kvantiliai&quot;, y = &quot;Duomenų kvantiliai&quot;) QQ diagrama aiškaus nukrypimo nuo normalumo irgi nerodo. Pasirenkame, kad tinkamas Pearson koreliacijos koeficientas. with(crabs, cor.test(BD, FL, method = &quot;pearson&quot;)) ## ## Pearson&#39;s product-moment correlation ## ## data: BD and FL ## t = 88.618, df = 198, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.9836734 0.9906280 ## sample estimates: ## cor ## 0.9876272 Šio tipo analizę taip pat atlieka ir ggstatsplot funkcija ggscatterstats() nurodant, jog reikia parametrinio kriterijaus (type = \"parametric\"). Virš grafiko – apibendrinti rezultatai. ggstatsplot::ggscatterstats( x = BD, y = FL, data = crabs, type = &quot;parametric&quot;, marginal = FALSE ) Aprašymo pavyzdys. „Atliktas 200 krabų tyrimas, kuriame lyginta gyvūnų priekinės skilties dydžio (FL) ir kūno storio (BD) priklausomybė. Pastebėta stipri teigiama koreliacija (\\(r\\) = 0,99, 95% PI 0,98–0,99, \\(p\\) &lt; 0,001). Sąryšis tarp kintamųjų atvaizduotas pav. ___ (nurodomas paveikslo numeris).“ arba „…tarp krabų (\\(n\\) = 200) priekinės skilties dydžio ir kūno storio nustatyta stipri koreliacija (\\(r\\) = 0,99, 95% PI 0,98–0,99, \\(p\\) &lt; 0,001).“ Taip pat turi būti nurodomi trumpinių paaiškinimai: n – imties dydis, \\(r\\) – Pirsono (Pearson) koreliacijos koeficientas, PI – pasikliautinasis intervalas. Svarbu! Moksliniuose darbuose nerašykite „koreliacijos nėra“, nes tai nekorektiškas teiginys. Įprastai rašoma „koreliacija buvo statistiškai nereikšminga“ ar „statistiškai reikšmingos koreliacijos nerasta“. Pavyzdys 2 Toliau ištirkime, kaip namų dydis (kvadratinėmis pėdomis, angliški matavimo vienetai) ir jų suvartojamas elektros kiekis (kilovatvalandės per mėnesį) koreliuoja. library(tidyverse) library(DescTools) library(ggstatsplot) data(Energy, package = &quot;BSDA&quot;) glimpse(Energy) ## Observations: 12 ## Variables: 2 ## $ size &lt;int&gt; 2820, 2500, 2350, 2000, 1950, 1875, 1740, 1650, 1490,... ## $ kilowatt &lt;int&gt; 1975, 1952, 1894, 1841, 1769, 1674, 1590, 1505, 1386,... Tik 12 stebėjimų. Duomenis nusibraižome: Desc(kilowatt ~ size, data = Energy) ## ------------------------------------------------------------------------- ## kilowatt ~ size ## ## Summary: ## n pairs: 12, valid: 12 (100.0%), missings: 0 (0.0%) ## ## ## Pearson corr. : 0.940 ## Spearman corr.: 1.000 ## Kendall corr. : 1.000 Panašu, kad ryšys nėra tiesinis, bet monotoninis. Pažiūrėkime, kaip duomenys atrodo ties jais nusibraižius tiesę. ggplot(Energy, aes(size, kilowatt)) + geom_smooth(method = lm, se = FALSE) + geom_point() Panašu, kad ryšys netiesinis, bet monotoninis. Tiks ranginė koreliacija. with(Energy, cor.test(size, kilowatt, method = &quot;kendall&quot;)) ## ## Kendall&#39;s rank correlation tau ## ## data: size and kilowatt ## T = 66, p-value = 0.000000004175 ## alternative hypothesis: true tau is not equal to 0 ## sample estimates: ## tau ## 1 Ranginę Spearman koreliacinę analizę gali atlikti ggstatsplot funkcija ggscatterstats() nurodant, jog reikia neparametrinio kriterijaus (type = \"nonparametric\"). Deja, šiuo būdu Kendall koreliacinės analizės atlikti negalime: ggstatsplot::ggscatterstats( x = size, y = kilowatt, data = Energy, type = &quot;nonparametric&quot;, method = &quot;auto&quot;, # &quot;lm&quot; marginal = FALSE) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; with(Energy, cor.test(size, kilowatt, method = &quot;spearman&quot;)) ## ## Spearman&#39;s rank correlation rho ## ## data: size and kilowatt ## S = 0, p-value &lt; 2.2e-16 ## alternative hypothesis: true rho is not equal to 0 ## sample estimates: ## rho ## 1 Aprašymo pavyzdys. „Tiriant sąsają tarp namų dydžio (kvadratinės pėdos) ir suvartojamo elektros kiekio (kilovatvalandės per mėnesį) atlikta ranginė Kendall koreliacinė analizė, kuri atskleidė teigiamą labai stiprų ryšį tarp šių kintamųjų (\\(\\tau\\) = 1,00, \\(p\\) &lt; 0,001). Imties dydis – 12. Priklausomybė atvaizduota sklaidos diagrama (skliaustuose nurodomas paveikslo numeris).“ Taip pat turi būti nurodomi trumpinių paaiškinimai: \\(\\tau\\) – Kendall koreliacijos koeficientas. arba „Tarp namų dydžio ir suvartoto elektros kiekio ryšys buvo netiesinis, tačiau aptikta stipri ranginė koreliacija (Kendall \\(\\tau\\) = 1,00, \\(p\\) &lt; 0,001). Imties dydis – 12 stebėjimų.“ Jei atlikome Spearnam analizę: „Tarp namų dydžio ir suvartoto elektros kiekio ryšys buvo netiesinis, tačiau aptikta stipri ranginė koreliacija (Spearman \\(\\varrho_s\\) = 1,00, \\(p\\) &lt; 0,001). Imties dydis – 12 stebėjimų.“ 20.2.6 Rekomenduojami informacijos šaltiniai Šiame konspekte pateikti tik esminiai koreliacinės analizės bruožai. Išsamiau teorija išdėstyta šiuose vadovėliuose: (Čekanavičius ir Murauskas 2006, p.97–98, 124–126, 165–169) – tiesinė koreliacija; (Čekanavičius ir Murauskas 2008, p.33–40) – ranginė koreliacija; (Venclovienė 2010, p.66–68, 167–183). 20.3 Sąsaja tarp kategorinių kintamųjų reikšmių 20.3.1 Požymių nepriklausomumo tikrinimas Sąsaja ir nepriklausomumas – tai viena kitai atvirkštinės sąvokos. Iš principo, šiame poskyryje mokysimės tirti, ar sąsaja tarp kategorinių kintamųjų yra reikšminga. Kategorinių duomenų analizės principas: pirma susidarome dažnių lentelę ir toliau kitomis funkcijomis šią lentelę analizduojame. Pavyzdyje tirsime duomenų lentelės mtcars (32 atsitiktinai pasirinkti automobiliai) kintamuosius cyl(cilindrų skaičius) ir am (pavarų dėžė: 0 – automatinė, 1 – rankinė). data(mtcars) glimpse(mtcars) ## Observations: 32 ## Variables: 11 ## $ mpg &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.... ## $ cyl &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, ... ## $ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 1... ## $ hp &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, ... ## $ drat &lt;dbl&gt; 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.9... ## $ wt &lt;dbl&gt; 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3... ## $ qsec &lt;dbl&gt; 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 2... ## $ vs &lt;dbl&gt; 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, ... ## $ am &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, ... ## $ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, ... ## $ carb &lt;dbl&gt; 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, ... Prieš tiriant sąsają tarp kategorinių kintamųjų, įprasta sudaryti porinę dažnių lentelę. Tai atlieka funkcija table(). Įprasta naudoti tokią sintaksę: with(duomenų_lentelė, table(požymis_1, požymis_2)) dazniu_lentele &lt;- with(mtcars, table(cyl, am)) dazniu_lentele ## am ## cyl 0 1 ## 4 3 8 ## 6 4 3 ## 8 12 2 Greitam apražymui galime naudoti funkciją Desc(). DescTools::Desc(dazniu_lentele) ## ------------------------------------------------------------------------- ## dazniu_lentele (table) ## ## Summary: ## n: 32, rows: 3, columns: 2 ## ## Pearson&#39;s Chi-squared test: ## X-squared = 8.7407, df = 2, p-value = 0.01265 ## Likelihood Ratio: ## X-squared = 9.2948, df = 2, p-value = 0.009586 ## Mantel-Haenszel Chi-squared: ## X-squared = 8.4667, df = 1, p-value = 0.003617 ## ## Warning message: ## Exp. counts &lt; 5: Chi-squared approx. may be incorrect!! ## ## ## Phi-Coefficient 0.523 ## Contingency Coeff. 0.463 ## Cramer&#39;s V 0.523 ## ## ## am 0 1 Sum ## cyl ## ## 4 freq 3 8 11 ## perc 9.4% 25.0% 34.4% ## p.row 27.3% 72.7% . ## p.col 15.8% 61.5% . ## ## 6 freq 4 3 7 ## perc 12.5% 9.4% 21.9% ## p.row 57.1% 42.9% . ## p.col 21.1% 23.1% . ## ## 8 freq 12 2 14 ## perc 37.5% 6.2% 43.8% ## p.row 85.7% 14.3% . ## p.col 63.2% 15.4% . ## ## Sum freq 19 13 32 ## perc 59.4% 40.6% 100.0% ## p.row . . . ## p.col . . . ## Analogiškus rezultatus gautume naudodami ir duomenų lentelę, jei analizuojami kintamieji būtų paversti į kategorinius: mtcars2 &lt;- mtcars %&gt;% mutate( am = as.factor(am), cyl = as.factor(cyl) ) DescTools::Desc(cyl ~ am, data = mtcars2) Kategorinių požymių nepriklausomumui tirti naudojami šie kriterijai: Fišerio tikslusis kriterijus. Šis kriterijus įprastai taikomas imtims, mažesnėms nei 1000, nes kitu atveju skaičiavimai gali užtrukti ilgai (McDonald 2014b). Taip pat tais atvejais, kai nekorektiška naudoti \\(\\chi^2\\) ar G požymių nepriklausomumo kriterijus. Tarkim, kai kažkurių pogrupių dažniai (dažnių lentelės langelių reikšmės) mažesni kaip 5. Pirsono \\(\\chi^2\\) kriterijus. \\(\\chi^2\\) požymių nepriklausomumo kriterijus laikomas tinkamu naudoti, kai imties dydis bent 30, o 75% dažnių lentelės langelių dažnis yra 5 arba daugiau. Įprastai taikomas, kai imtis mažesnė už 1000 Plačiau apie \\(\\chi^2\\) tinkamumą skaitykite vadovėlyje (Čekanavičius ir Murauskas 2006, p.213–214) bei (McDonald 2014a). G kriterijus. Kai kurie autoriai teigia, kad ten, kur seniau buvo rekomenduojama naudoti \\(\\chi^2\\) kriterijų, dabar yra rekomenduojama naudoti tikėtinų santykio, t. y., G kriterijų (McDonald 2014c). Įprastai naudojamas, kai imties dydis didesnis nei 1000, nes kitu atveju tikslesniu laikomas Fišrsio tikslusis kriterijus. Atkreipkite dėmesį, kad šie kriterijai gali padėti atsakyti į klausimą „Ar tikėtina, kad požymiai susiję?“, bet neatsako – „Kaip labai? Koks sąsajos stiprumas?“ (apie tai – poskyryje 20.3.2). \\(\\chi^2\\) požymių nepriklausomumo kriterijus taikymas: chisq.test(dazniu_lentele) ## Warning in chisq.test(dazniu_lentele): Chi-squared approximation may be ## incorrect ## ## Pearson&#39;s Chi-squared test ## ## data: dazniu_lentele ## X-squared = 8.7407, df = 2, p-value = 0.01265 Atkreipkite dėmesį į perspėjimą, kad \\(\\chi^2\\) kriterijų naudoti tikriausiai nekorektiška: Chi-squared approximation may be incorrect. Alternatyva – Fišerio tikslusis kriterijus: fisher.test(dazniu_lentele) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: dazniu_lentele ## p-value = 0.009105 ## alternative hypothesis: two.sided Gavome, kad \\(p\\) &lt; 0,05, tad galime teigti, kad kintamieji (šiuo atveju cyl, am) yra priklausomi. Rezultatus galime aprašyti taip: „Ryšys tarp cilindrų skaičiaus ir pavarų dėžės tipo yra statistiškai reikšmingas (Fišerio tikslusis kriterijus, \\(p\\) = 0,009).“ Savo išvadas grįsti vien tik \\(p\\) reikšmėmis yra bloga praktika. Dar reiktų išsiaiškinti *efekto dydį**, t.y., sąsajos stiprumą. Apie tai raroma kitame poskyryje. 20.3.2 Kategorinių kintamųjų ryšio stiprumas Ryšio stiprumą galime įvertinti naudodami vieną iš kelių galimų kategorinių kintamųjų ryšio matų (apie šios koeficientus plačiau rašoma (Čekanavičius ir Murauskas 2006, p.216–221)): Koeficientas \\(\\phi\\) (Phi-Coefficient) – tarpusavio sutapimo rodiklis. Skaičiuojamas tik \\(2 \\times 2\\) dažnių lentelėms. Kinta nuo 0 iki 1. Kontingencijos koeficientas (Contingency Coeff.). Niekada neviršija 1. Didžiausia reikšmė priklauso nuo dažnių lentelės stulpelių ir eilučių skaičiaus. Kramerio koeficientas \\(V\\) (Cramer's V). Kinta nuo 0 iki 1. \\(2 \\times 2\\) dažnių lentelei koeficientai \\(V\\) ir \\(\\phi\\) sutampa \\((V = \\phi)\\). Juos galite apskaičiuoti naudodami paketo vcd funkciją assocstats(), kuriai pateikiama funkcija table() apskaičiuota dažnių lentelė: vcd::assocstats(dazniu_lentele) ## X^2 df P(&gt; X^2) ## Likelihood Ratio 9.2948 2 0.0095865 ## Pearson 8.7407 2 0.0126466 ## ## Phi-Coefficient : NA ## Contingency Coeff.: 0.463 ## Cramer&#39;s V : 0.523 Likelihood Ratio – tikėtinumų santykio (t.y., G) kriterijaus rezultatai. Pearson – Pirsono \\(\\chi^2\\) kriterijaus rezultatai. Phi-Coefficient, Contingency Coeff. bei Cramer's V yra atitinkamai \\(\\phi\\), kontingencijos ir įprastinis (paslinktasis) Kramerio \\(V\\) koeficientas. Šiuos rezultatus galime rasti ir tarp DescTools paketo funkcijos Desc() rezultatų (pažiūrėkite pastarąjį funkcijos pavyzdį, esantį aukščiau. Įprastinis Kramerio \\(V\\) koeficientas gali rodyti didesnį sąsajos spiprumą, jei jis yra visoje generainėje aibėje (GA). Tad naudodami paketo rcompanion funkciją cramerV() ir jos parametrą bias.correct = TRUE galime gauti nepaslinktąjį (angl. bias corrected) Kramerio \\(V\\). rcompanion::cramerV(dazniu_lentele, bias.correct = TRUE) ## Cramer V ## 0.4643 Papildomai nurodžius ci = TRUE bus apskaičiuotas koeficiento pasikliautinasis itervalas savirankos (angl. bootstrap) koreguotųjų procentilių (angl. bias corrected and accelerated, BCa, bca) metodu. Šiuo atveju naudojama 1000 (R = 1000) perskaičiavimų. Teoriškai rekomenduojama, kad būtų tarp \\(10^3\\) ir \\(10^4\\) perskaičiavimų. Taip pat savirankos metodams imties dydis privalo būti didesnis nei 20. rcompanion::cramerV( dazniu_lentele, bias.correct = TRUE, ci = TRUE, conf = 0.95, type = &quot;bca&quot;, R = 1000) ## r lower.ci upper.ci ## 1 0.4643 0 0.7217 Apskaičiavę ryšio stiprumo koeficientą, rezultatų aprašymą galime papildyti. Įprastai koreliacijos ir asociacijos koeficientus pateikiame 2 skaičių po kablelio tikslumu: „Analizuodami duomenis nustatėme vidutinio stiprumo statistinę sąsają tarp automobilių cilindrų skaičiaus ir pavarų dėžės tipo (Fišerio tikslusis kriterijus, \\(p\\) = 0,009, Cramer’io \\(V^*\\) = 0,46).“ Būtinai paaiškiname, kad \\(V^*\\) yra koreguotasis/nepaslinktasis Kramerio \\(V\\) koeficientas. Jei sąsaja būtų statistiškai nereikšminga, taip ir rašytume: „Sąsaja tarp kintamųjų buvo statistiškai nereikšminga (Pirsono \\(\\chi^2\\) kriterijus, \\(\\chi^2\\)(1) = 0,415, \\(p\\) = 0,519, \\(V\\) = 0,12).“ arba „Sąsaja tarp kintamųjų buvo statistiškai nereikšminga (Fišerio tikslusis kriterijus, \\(p\\) = 0,408, Cramer \\(V\\) = 0,09).“ Vėlgi būtina paaiškinti, kas yra \\(V\\). 20.3.3 Programos kodai Žemiau pateikti programos kodai, kurie yra skirti atlikti sąsajos tarp kategorinių kintamųjų analizę. Jums reikiamose vietose reikia įrašyti savo duomenų bei kintamųjų pavadinimus bei pasirinkti tik jūsų atvejui tinkamus metodus. library(DescTools) library(rcompanion) duomenys &lt;- ...duomenų_užkrovimo_kodas... dazniu_lentele &lt;- with(duomenys, table(kintamasis_1, kintamasis_2)) dazniu_lentele chisq.test(dazniu_lentele) fisher.test(dazniu_lentele) DescTools::Desc(dazniu_lentele) rcompanion::cramerV( dazniu_lentele, bias.correct = TRUE, ci = TRUE, conf = 0.95, type = &quot;bca&quot;, R = 1000) 20.3.4 Rekomenduojami informacijos šaltiniai Šiame konspekte pateikti tik esminiai sąsajos tarp kategorinių kintamųjų aspektai. Išsamiau teorija išdėstyta vadovėlyje: (Čekanavičius ir Murauskas 2006, p.197–223). 20.4 Ryšio tarp kintamųjų analizė naudojant R Commander Prieš žiūrėdami video epizodus, iš VMA parsisiųskite šioms pratyboms skirtus duomenis (nuoroda ), susikurkite sukonfigūruotą RStudio projektą ir duomenis įsikelkite į šio projekto aplanką. Video epizodas 20.1 Duomenų lentelių stulpelių sujungimas pagal eilučių identifikacijos numerius bei kelių duomenų lentelių eilučių sujungimas (R Commander). Video epizodas 20.2 Koreliacinė analizė (R Commander). Video epizodas 20.3 Koreliacinė analizė kelių kintamųjų poroms: koreliacijos koeficientų matrica ir sklaidos diagramų matrica (R Commander). Video epizodas 20.4 Kintamojo reikšmių perkodavimas, kintamojo klasės keitimas (R Commander). Atliekant kategorinių kintamųjų analizę, šių kintamųjų R klasė privalo būti factor (nominalusis) arba ordered (ranginis). Kitu atveju reikiamus kintamuosius reikia pasiversti į faktorius arba R Commander gali neleisti sudaryti dažnių lentelės. Video epizodas 20.5 Sąryšio tarp kategorinių kintamųjų tikrinimas (R Commander). Užduotis 20.2 Duomenų lentelėje „LungCapData.xlsx“ (ją parsisiuntėte iš VMA) pateikti vaikų plaučių tūrio (lung capacity) duomenys: 1. Kiekvienai skaitinių kintamųjų porai atlikite koreliacinę analizę: parinkite tinkamą koreliacijos variantą ir rezultatus aprašykite. Kiekvienai kategorinių kintamųjų porai atlikite analizę, kuri parodytų, ar šie kintamieji yra priklausomi. Įvertinkite sąsajos stiprumą. Rezultatus aprašykite. Informacijos šaltiniai "],
["tiesine-regresija.html", "21. Tiesinė regresija 21.1 Regresinė analizė 21.2 Informacijos šaltiniai 21.3 Regresinė analizė naudojant R Commander 21.4 Išsamios tiesinės regresinės analizės pavyzdys", " 21. Tiesinė regresija Šio skyriaus medžiaga vis dar rengiama arba neatnaujinta šių metų kursui, todėl kol kas jos nenagrinėkite. Užsiėmimo tikslas – praktiškai susipažinti su išsamios tiesinės regresinės analizės principais. Pratybų metu reikalingi „R“ paketai: # Bendrosios paskirties paketai library(tidyverse) library(data.table) # Kalibracijos uždavniui library(chemCal) # Jei regresinę analizę norite atlikti naudodami R Commander library(Rcmdr) library(RcmdrPlugin.biostat) # Versija 0.0.33 ar naujesnė # Jei analizę norite atlikti naudodami R kodą library(RcmdrMisc) library(car) library(Hmisc) library(lmtest) library(broom) library(lm.beta) library(ggstatsplot) # Linux vartotojams gali reikti įdiegti papildomų # sistemos įrankių. Atidžiai skaitykite žinutes. Instrukcija, kaip įsidiegti paketą RcmdrPlugin.biostat, pateikta paketo tinklapyje . Likusius galite įsidiegti naudodami funkciją install.packages(). 21.1 Regresinė analizė Koreliacinė analizė parodo, ar dviejų kintamųjų reikšmės yra susijusios ir koks tos sąsajos stiprumas. Jei šito užtenka, šioje vietoje analizę ir baigiame. Jei norime griežčiau apsirašyti šią sąsają, galime atliki regresinę analizę. Regresijos modelis – statistinis modelis, leidžiantis vieno kintamojo reikšmes prognozuoti pagal kito kintamojo reikšmes. Regresija – statistinė vieno atsitiktinio dydžio reikšmių priklausomybė nuo kito – neatsitiktinio – dydžio (arba kelių kitų dydžių), turinti griežtą funkcinį ryšį (t. y., aprašoma lygtimi). Pavyzdžiai: pirmas pavyzdys, kuris ateina į galvą – yra kalibravimas, kai paruošiame žinomos koncentracijos tirpalus, supilstome į kiuvetes bei išmatuojame šviesos sugertį. Susidarome koncentracijos ir šviesos sugerties priklausomybės (t. y., kalibracinę) kreivę bei lygtį. Vėliau į mėgintuvėlį įpylę nežinomos koncentracijos tirpalą pagal šviesos sugerties intensyvumą galime nustatyti koncentraciją. Tai dažnas uždavinys per biochemijos laboratorinius darbus; regresija gali būti naudojama ir tada, kai, tarkime, norime nustatyti, koks įprastai būna pulsas padarius tam tikrą kiekį pritūpimų; koks būna vabzdžio šarvo storis, jei žinome vabzdžio svorį ir ilgį; kaip svoris priklauso nuo amžiaus; kaip plaučių tūris priklauso nuo per savaitę surūkomų cigarečių skaičiaus. Paprastosios tiesinės regresijos modelis užrašomas lygtimi: \\[Y = a + bX + \\varepsilon\\] Čia: \\(Y\\) ir \\(X\\) – mūsų tiriami kintamieji: \\(Y\\) – vadinamas priklausomu, arba atsako, kintamuoju, nes jį modeliuojame; \\(X\\) – nepriklausomu, arba aiškinamuoju, kintamuoju, arba regresoriumi, nes pagal jį modeliuojame \\(Y\\) reikšmes. Daroma prielaida, kad \\(X\\) yra matuojamas be paklaidų (t. y., nėra atsitiktinis dydis); \\(a\\) ir \\(b\\) – lygties koeficientai: \\(a\\) – laisvasis narys, kartais vadinamas konstanta (angl., intercept). Paprastosios regresijos atveju parodo, kurioje vietoje regresijos tiesė kerta y ašį, kai \\(X = 0\\); \\(b\\) – koeficientai, dar vadinami krypties koeficientais (angl., slope) arba svertiniais koeficientais. Parodo, kiek pakinta Y reikšmė, kai X reikšmė pakinta vienu vienetu. Atliekant regresinę analizę mūsų tikslas apskaičiuoti šiuos koeficientus. \\(\\varepsilon\\) – liekamosios paklaidos, dar vadinamos likučiais (angl., residuals): tai visa kita, nuo ko gali priklausyti Y reikšmės; šios paklaidos – tai kintamojo \\(Y\\) matavimo paklaidos (nes modelyje laikoma, kad \\(X\\) matuojamas be paklaidų); pagal paklaidas galime patikrinti daugelį tiesinės regresijos modelio prielaidų. Daugialypės tiesinės regresijos modelis panašus, tik yra daugiau nepriklausomų kintamųjų ir \\(b\\) koeficientų. Pvz., kai yra 3 aiškinamieji kintamieji: \\[Y = a + b_1X_1 + b_2X_2 + b_3X_3 + \\varepsilon\\] Bendruoju atveju: \\[Y = a + \\left( \\sum b_iX_i \\right)+ \\varepsilon\\] 21.1.1 Regresinės analizės eiga Visą regresinę analizę galima suskirstyti į 3 pagrindinius etapus: Pirmiausia modelis yra sudaromas (parenkami kintamieji, užrašoma regresijos lygtis, apskaičiuojami koeficientai). Tada vykdoma modelio diagnostika (patikrinamas modelio tinkamumas duomenims, duomenų tinkamumas modeliui, modelio prielaidos): jei reikia – modelis tobulinamas. Galiausiai tinkamai sudarytas modelis aprašomas ir naudojamas prognozuoti: ateityje žinodami visų X’ų reikšmes, galėsime prognozuoti, kokia, tikėtina, bus kintamojo Y reikšmė. 21.1.2 Tinkamo tiesinės regresijos modelio rodikliai Tinkamo tiesinės regresijos modelio, pagal kurį galima daryti pagrįstas išvadas, rodikliai (labai išsami regresinė analizė): Determinacijos koeficientas \\(R^2 \\ge 0,20\\): kuo \\(R^2\\) didesnis, tuo glaudžiau taškai išsidėsto apie regresijos tiesę; naudojame tik vieną determinacijos koeficientą, kuris labiau tinka: arba įprastinį: tinka paprastajai tiesinei regresijai arba daugialypei, kai duomenų pakankamai daug – pvz., vienam nepriklausomam kintamajam \\(X_i\\) tenka bent 7 duomenų taškai; arba koreguotąjį: kai modelyje yra daug nepriklausomų kintamųjų \\(X_i\\) (ir palyginus mažai taškų), įprastinis \\(R^2\\) gali būti nepagrįstai didelis. ANOVA \\(p &lt; 0,05\\): parodo, kad bent vienas regresorius yra reikalingas, t. y., bent vieno koeficiento vertė statistiškai reikšmingai skiriasi nuo nulio; Visiems regresoriams t kriterijų \\(p &lt; 0,05\\): parodo, kurių konkrečiai koeficientų vertė statistiškai reikšmingai skiriasi nuo 0; Nėra išskirčių, jei: Bonferroni išskirčių kriterijaus koreguotoji \\(p \\ge 0,05\\) (arba NA); Kuko matas d (Cook‘s distance) visiems stebėjimams \\(d &lt; 1\\). Liekamosios paklaidos normalios: Sprendžiant pagal q-q grafiką bei Shapiro-Wilk testo \\(p \\ge 0,05\\). Liekamųjų paklaidų vidurkis lygus 0: Sprendžiant iš liekamųjų paklaidų pagal prognozuojamas reikšmes grafiko bei Vienos imties t testo \\(p \\ge 0,05\\). Nėra heteroskedastiškumo problemos: Sprendžiant iš liekamųjų paklaidų grafikų bei Breusch-Pagan (Breušo-pagano) testo \\(p \\ge 0,05\\). Nėra multikolinearumo problemos, dėl kurios neteisingai apskaičiuojami lygties koeficientai (tik daugialypei regresijai), jei: regresijos koeficientų ženklai atitinka koreliacijos koef. ženklus tarp Y ir kiekvieno X; visi \\(VIF \\le 4\\) (VIF – dispersijos mažėjimo daugiklis, angl., variance inflation factor). Nėra autokoreliacijos: Tikriname tik tada, jei dirbame su laiko eilutėmis (pvz., mėnesiais, sekundėmis) arba dėl kitokių priežasčių įtariame, kad reikšmės gali būti priklausomos; Durbin-Watson autokoreliacijos kriterijaus \\(p\\ge0,05\\), kai alternatyva \\(\\varrho \\ne 0\\) (čia \\(\\varrho\\) – (auto)koreliacijos koeficientas); arba Durbin-Watson statistikos reikšmė yra tarp 1,5-2,5. Jei turime daugialypę regresiją, papildomai apskaičiuojame standartizuotuosius (beta) koeficientus: kuo absoliučioji koeficiento vertė didesnė, tuo atitinkamas regresorius daro didesnę įtaką priklausomam kintamajam. Nestandartizuoti koeficientai tokios informacijos neteikia. Analogišką (bet šiek tiek glaustesnį) apibendrinimą galite rasti regresijos vadovėlio 36 psl. (). Pastabos: visi kintamieji regresinėje analizėje turi būti skaitiniai arba pseudokintamieji; regresijos vadovėlyje skaitiniai kintamieji vadinami intervaliniais; pseudokintamieji (angl. dummy variables) – tai kategoriniai kintamieji, tam tikru būdu perkoduoti į skaitinius. Kuriant tiesinės regresijos modelį R tai atlieka automatiškai, todėl galite pamatyti neįprastai apibūdintų koeficientų, jei naudojate kategorinį kintamąjį; apie pseudokintamuosius šio kurso metu plačiau nesimokysime). Užduotis 21.1 Sąsiuvinyje arba atskirame lape pasidarykite atmintinę, ką reikia patikrinti vykdant išsamią regresinę analizę. Apibūdinkite, kokie turi būti šios patikros rezultatai, kad būtų korektiška naudoti regresinės analizės modelį. Užduotį atlikite raštu. 21.1.3 Regresijos modelio grafikas ggplot2 sistema Paprastosios tiesinės regresijos modelį \\(Y = a + bX\\) galima nubraižyti naudojant tokį ggplot2 kodą: data(birthwt, package = &quot;MASS&quot;) library(ggplot2) ggplot(birthwt, aes(x = age, y = bwt)) + geom_point() + geom_smooth(method = lm, se = FALSE) Pasirinkus parametrą se = TRUE bus braižomas tiesės pasikliauties intervalas. Jei reikalinga tokio tipo kreivė, kuri eina per tašką (0; 0) – \\(Y = 0 + bX\\),– tada reikia tokio kodo geom_smooth(method = lm, se = FALSE, formula = y ~ 0 + x): ggplot(birthwt, aes(x = age, y = bwt)) + geom_smooth(method = lm, se = FALSE, formula = y ~ 0 + x) + geom_point() + coord_cartesian(xlim = c(0, 45), ylim = c(0, 5500)) Be abejo, šiuo atveju toks modelis mums nėra tinkamas. Tai tik pavyzdys. Dar vienas būdas, skirtas braižyti paprastajai regresijai skirtą grafiką, kuriame pateikiami papildomi tiesinės koreliacijžnės analizės rezultatai, tai paketo ggstatsplot funkcija ggscatterstats(). ggstatsplot::ggscatterstats(birthwt, x = age, y = bwt, marginal = FALSE) Daugiau apie ją skaitykite dokumentacijoje: ?ggstatsplot::ggscatterstats Užduotis 21.2 Išbandykite šiame skyriuje pateiktus programos kodus. 21.1.4 Rezultatų aprašymas: tiesinė regresinė analizė Standartinių tiesinės regresijos modelio aprašymų pavyzdžių galite rasti regresijos vadovėlio () skyriuose: „2.1.8. Standartiniai tiesinės regresijos modelio aprašymai“ 40-41 psl.; „2.5.6. Išvados“ 114 psl. Užduotis 21.3 Atsiverskite nurodytus vadovėlio puslapius ir perskaitykite, kaip turi atrodyti regresinės analizės aprašymas. Raštu įvardinkite svarbiausias tiesinės regresijos modelio aprašymo principus. 21.2 Informacijos šaltiniai Šiame konspekte itin glaustai pateikti tik esminiai regresinės analizės bruožai. Teorinė dalis išdėstyta šiuose vadovėliuose: Čekanavičius ir Murauskas „Taikomoji regresinė analizė socialiniuose tyrimuose“ 28-41 ir 127 psl. (išdėstyti praktiniai modelio taikymo aspektai vengiant matematinių detalių) ; Čekanavičius ir Murauskas „Taikomoji regresinė analizė socialiniuose tyrimuose“ 100-123 psl. analizės pavyzdys naudojant R; Čekanavičius ir Murauskas „Statistika ir jos taikymai II“ 123-147 ir 151-179 psl. (pateikti ir matematiniai modelio aspektai). Papildomi informacijos šaltiniai, kuriuose mokoma, kaip interpretuoti regresinės analizės rezultatus: Straipsnis, kuriame mokoma, kaip interpretuoti keturis pagrindinius tiesinės regresijos modelio diagnostikos grafikus (nuoroda ); Tinklaraščio straipsnis, kuriame supažindinama, kaip naudojantis R susidaryti tiesinės regresijos modelį ir kaip interpretuoti skaitinius modelio rezultatus (nuoroda ); Atsakymas diskusijų forume „Cross Validated“, kuriame aiškinama, kaip interpretuoti liekamųjų paklaidų pagal prognozuojamas reikšmes grafiką (nuoroda ); Atsakymas diskusijų forume „Cross Validated“, kuriame aiškinama, kaip interpretuoti liekamųjų paklaidų pagal įtakos indeksą grafiką (nuoroda ). 21.3 Regresinė analizė naudojant R Commander Prieš žiūrėdami video epizodus, iš VMA parsisiųskite šioms pratyboms skirtus duomenis (nuoroda ), susikurkite sukonfigūruotą RStudio projektą ir duomenis įsikelkite į šio projekto aplanką. 21.3.1 Paprastoji tiesinė regresija Epizode su kalibracijos uždaviniu nekorektiškai sudarytas regresijos modelis. Sprendžiant kalibracijos uždavinį korektiška nepriklausomu kintamuoju (X) pasirinkti koncentraciją (tai, ką išmatavome patys), o priklausomu (Y) – optinį tankį (tai, ką išmatavo kalibruojamasis prietaisas). Korektiška modelio lygtis: \\[optinis\\_tankis = a + b \\times koncentracija\\] Korektiškas kalibracijos uždavinio sprendimas po epizodu. Video epizodas 21.1 Išsamios paprastosios tiesinės regresijos pavyzdys (R Commander). Užduotis 21.4 Duomenų lentelėje „smoking.xlsx“ (ją parsisiuntėte iš VMA) pateikti skirtingų šalių duomenys apie rūkymą ir plaučių vėžio atvejus. Su šiais duomenimis atkartokite video epizode 21.1 parodytą regresinę analizę: sudarykite prasmingą modelį, užrašykite jo lygtį, patikrinkite, ar modelį korektiška naudoti. Modelį aprašykite. Kintamieji: lungca – mirčių nuo plaučių vėžio skaičius milijonui gyventojų; cigs – per metus surūkytų cigarečių skaičius, tenkantis vienam gyventojui. Kalibracijos uždavinio sprendimas Kalibracijos uždavinio sprendimo pavyzdys. Šiame pavyzdyje modelio prielaidos tikrinamos tik grafiškai. # Duomenys kalibracijos_duomenys &lt;- data.frame( koncentracija = c( 1, 1, 0.75, 0.75, 0.5, 0.5, 0.25, 0.25, 0.125, 0.125, 0.0625, 0.0625), OD = c(0.98, 0.96, 0.746, 0.751, 0.46, 0.475, 0.23, 0.245, 0.123, 0.126, 0.0615, 0.0626)) Modelio sudarymas: \\(X\\) (nepriklausomas kintamasis) turi būti koncentracija (t. y., tai, ką dedame į prietaisą). Darome prielaidą, kad ši koncentracija išmatuota visiškai tiksliai, t.y., be klaidų. \\(Y\\) (priklausomas kintamasis) turi būti optinis tankis ar kitas rodmuo, kurį išmatuoja prietaisas. Prietaisas matuoja su paklaidomis, o modelis į šias paklaidas atsižvelgia. Sudarome tokios formos lygtį: \\(Y = a + bX\\), t. y., \\(OD = a + b \\times koncentracija\\). # Modelio sudarymas: modelis &lt;- lm(OD ~ koncentracija, data = kalibracijos_duomenys) # Regresijos lygties koeficientai: modelis ## ## Call: ## lm(formula = OD ~ koncentracija, data = kalibracijos_duomenys) ## ## Coefficients: ## (Intercept) koncentracija ## -0.002598 0.976982 # Modelio suvestinė: summary(modelis) ## ## Call: ## lm(formula = OD ~ koncentracija, data = kalibracijos_duomenys) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.025893 -0.011081 0.003414 0.005831 0.020862 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.002598 0.006662 -0.39 0.705 ## koncentracija 0.976982 0.011855 82.41 1.69e-15 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.01393 on 10 degrees of freedom ## Multiple R-squared: 0.9985, Adjusted R-squared: 0.9984 ## F-statistic: 6792 on 1 and 10 DF, p-value: 1.692e-15 Tad gauname \\(OD = -0.0026 + 0.9770\\times koncentracija\\), \\(R^2 = 0.999\\). # Prielaidų tikrinimas grafiškai: op &lt;- par(mfrow = c(2, 2)); plot(modelis); par(op) Kalibracijos kreivė su pasikliauties ir prognozės intervalais # Kalibracinė kreivė: chemCal::calplot(modelis, xlab = &quot;Koncentracija&quot;, ylab = &quot;OD&quot;) Pagal sudarytą modelį apskaičiuosime koncentraciją (t. y., \\(X\\)), kai duotas OD (t. y., \\(Y\\)). Tam reikia persitvarkyti mūsų modelio lygtį į tokios formos lygtį: \\(X = \\frac{Y - a}{b}\\), t. y., \\(koncentracija = \\frac{OD - a}{b}\\). naujas_OD &lt;- c(0.701, 0.394, 0.095) (naujas_OD + 0.0026)/0.9770 ## [1] 0.72016377 0.40593654 0.09989765 Paketo chemCal funkcija inverse.predict() šiuos skaičiavimus gali atlikti už mus. Ši funkcija papildomai įvertina paklaidas bei ir apskaičiuoja pasikliauties intervalą. naujas_OD_1 &lt;- 0.701 chemCal::inverse.predict(modelis, naujas_OD_1) ## $Prediction ## [1] 0.720175 ## ## $`Standard Error` ## [1] 0.01520787 ## ## $Confidence ## [1] 0.03388524 ## ## $`Confidence Limits` ## [1] 0.6862898 0.7540603 Tad šiuo atveju koncentracija yra 0.720 (95% pasikliauties intervalas 0.676-0.764). Kaip pastebite, šis atsakymas paklaidų ribose sutampa su tuo, kuris video epizode pateikiamas ties 7:30 min. Visgi epizode lygtis sudaryta nekorektiškai. Daugiau pavyzdžių: naujas_OD_2 &lt;- 0.394 chemCal::inverse.predict(modelis, naujas_OD_2) ## $Prediction ## [1] 0.4059422 ## ## $`Standard Error` ## [1] 0.01485344 ## ## $Confidence ## [1] 0.03309552 ## ## $`Confidence Limits` ## [1] 0.3728467 0.4390377 naujas_OD_3 &lt;- 0.095 chemCal::inverse.predict(modelis, naujas_OD_3) ## $Prediction ## [1] 0.0998978 ## ## $`Standard Error` ## [1] 0.01543368 ## ## $Confidence ## [1] 0.03438838 ## ## $`Confidence Limits` ## [1] 0.06550942 0.13428618 Papildomai paketas gali apskaičiuoti mažiausią statistiškai reikšmingai aptinkamą koncentraciją (angl. lod – limit of detection): chemCal::lod(modelis) ## $koncentracija ## [1] 0.05690188 ## ## $OD ## [1] 0.05299375 Ši koncentracija yra apie 0.057, kai optinis tankis yra apie 0.053. Jei žinome, kad mūsų lygties laisvasis narys yra lygus nuliui (pvz., „nusinulinome“ prietaisą, kad rodytų 0, kai koncentracija yra 0), tada modelyje papildomai įrašome + 0 ir analizę atliekame iš naujo. # Modelio sudarymas: modelis_2 &lt;- lm(OD ~ koncentracija + 0, data = kalibracijos_duomenys) modelis_2 ## ## Call: ## lm(formula = OD ~ koncentracija + 0, data = kalibracijos_duomenys) ## ## Coefficients: ## koncentracija ## 0.9733 Atsakyme nebėra laisvojo nario („(Intercept)“). 21.3.2 Daugialypė tiesinė regresija Šiame skyriuje demonstuojamas pavyzdys taip pat aprašomas ir 21.4 skyriuje. Video epizodas 21.2 Išsamios daugialypės tiesinės regresijos pavyzdys (R Commander). Užduotis 21.5 Duomenų lentelėje „auction.xlsx“ (ją parsisiuntėte iš VMA) pateikti sendaikčių aukciono duomenys. Sudarykite knygos kainos (Price) priklausomybės nuo knygos amžiaus (Age) ir dalyvių skaičiaus (Bidders) modelį. Įvertinkite, kuris požymis yra reikšmingesnis prognozei. Rezultatus aprašykite. 21.3.3 Modelio tobulinimas Keli paprasti pavyzdžiai, ką daryti, jei netenkinami kai kurie tiesinės regresijos modelio reikalavimai, pateikti video epizode 21.3. Daugiau informacijos apie modelio tobulinimą galite rasti regresijos vadovėlyje (nuoroda pateikta 21.2 skyriuje). Pastaba: tobulindami modelį vienu metu pašalinkite ne daugiau kaip vieną kintamąjį arba vieną duomenų tašką. Tada sudarykite modelį iš naujo ir atlikite naujojo modelio diagnostiką. To gali pakakti, kad reikalavimai modeliui vėl būtų tenkinami. Be aiškaus pagrindimo ir argumetacijos duomenų, neatitinkamčių modelio, šalinti negalima! Video epizodas 21.3 Tiesinės regresijos modelio tobulinimas: keli pavyzdžiai (R Commander). Užduotis 21.6 Duomenų lentelėje „LungCapData.xlsx“ (ją parsisiuntėte iš VMA) pateikti vaikų plaučių tūrio (lung capacity) duomenys. Sudarykite plaučių tūrio priklausomybės nuo amžiaus ir ūgio modelį. Jei reikia, modelį koreguokite. Tinkamai aprašykite galutinį modelį. 21.4 Išsamios tiesinės regresinės analizės pavyzdys Šiame poskyryje pateikiamas išsamios daugialypės tiesinės regresinės analizės pavyzdys. 21.4.1 Klausimas / Problema Mums reikalingas modelis, kuriuo galime įvertinti medienos tūrio priklausomybę nuo medžio aukščio ir medžio apimties. 21.4.2 Duomenys Užkraunami duomenys, kuriose užregistruotas medžio aukštis, medžio apimtis ir medienos tūris. data(&quot;trees&quot;) ?trees Susidarome vaizdą apie duomenis. Pasižiūrime į duomenų struktūrą ir duomenų tipus: dplyr::glimpse(trees) ## Observations: 31 ## Variables: 3 ## $ Girth &lt;dbl&gt; 8.3, 8.6, 8.8, 10.5, 10.7, 10.8, 11.0, 11.0, 11.1, 11.2... ## $ Height &lt;dbl&gt; 70, 65, 63, 72, 81, 83, 66, 75, 80, 75, 79, 76, 76, 69,... ## $ Volume &lt;dbl&gt; 10.3, 10.3, 10.2, 16.4, 18.8, 19.7, 15.6, 18.2, 22.6, 1... Visi kintamieji yra skaitiniai (dbl, angl. double). Pasižiūrime į pirmas ir paskutine eilutes: head(trees) ## Girth Height Volume ## 1 8.3 70 10.3 ## 2 8.6 65 10.3 ## 3 8.8 63 10.2 ## 4 10.5 72 16.4 ## 5 10.7 81 18.8 ## 6 10.8 83 19.7 tail(trees) ## Girth Height Volume ## 26 17.3 81 55.4 ## 27 17.5 82 55.7 ## 28 17.9 80 58.3 ## 29 18.0 80 51.5 ## 30 18.0 80 51.0 ## 31 20.6 87 77.0 Padarome kintamųjų suvestinę: summary(trees) ## Girth Height Volume ## Min. : 8.30 Min. :63 Min. :10.20 ## 1st Qu.:11.05 1st Qu.:72 1st Qu.:19.40 ## Median :12.90 Median :76 Median :24.20 ## Mean :13.25 Mean :76 Mean :30.17 ## 3rd Qu.:15.25 3rd Qu.:80 3rd Qu.:37.30 ## Max. :20.60 Max. :87 Max. :77.00 Mūsų modelis galioja tik toms kintamųjų reikšmėms, kurios patenka tarp minimalių ir maksimalių kiekvieno modeliuojamo kintamojo ribų. Tarkim, girth turėtų būti tarp 8.30 ir 20.60. Jei sudarę modelį vėliau turėsime medį, kurio apimtis yra 25, tada jam taikyti modelį bus nekorektiška. 21.4.3 Nusibraižome kintamuosius Nusibraižome sklaidos diagramų matricą, kurioje visi analizuojami kintamieji viename grafike (susidarome bendrą vaizdą, ar priklausomybė tarp kintamųjų tiesinė): pairs(trees) Į kai kurias diagramas pasižiūrime atidžiau – sukuriame atskiras sklaidos diagramas, kuriose priklausomo kintamojo reikšmės y ašyje atidedamos pagal kiekvieną nepriklausomo kintamojo (regresoriaus) reikšmes. Pridedame papildomus grafiko elementus – pakraštines stačiakampes diagramas ir regresijos kreivę,– kurie padeda tiksliau vertinti grafikus: car::scatterplot( Volume ~ Height, data = trees, boxplots = &#39;xy&#39;, smooth = FALSE ) car::scatterplot( Volume ~ Girth, data = trees, boxplots = &#39;xy&#39;, smooth = FALSE ) ggstatsplot::ggscatterstats( y = Volume, x = Height, data = trees, type = &quot;parametric&quot;, # Pearson&#39;s correlation marginal = FALSE ) ggstatsplot::ggscatterstats( y = Volume, x = Height, data = trees, type = &quot;nonparametric&quot;, # Spearman&#39;s correlation marginal = FALSE ) ggstatsplot::ggscatterstats( y = Volume, x = Girth, data = trees, marginal = FALSE ) 21.4.4 Įvertiname koreliaciją tarp kintamųjų Nusibraižome koreliacijos koeficientų matricą, kurioje atidėti kiekvienos kintamųjų poros koreliacijos koeficientai bei atlikta koreliacijos patikimumo analizė (pridėta p reikšmių matrica, korektiškiau p reikšmes vertinti pagal koreguotų p reikšmių matricą). Priklausomas kintamasis turėtų bent šiek tiek koreliuoti su kiekvienu iš regresorių, kitaip regresoriaus įtraukimas į modelį labai abejotinas. Tuo tarpu regresoriai tarpusavyje neturėtų per smarkiai koreliuoti, nes kitu atveju galime susidurti su multikolinearumo problema. RcmdrMisc::rcorr.adjust(trees) 21.4.5 Regresijos lygties sudarymas Modelis sudaromas naudojant funkciją lm() (angl. linear model), jos viduje modeliuojamą sąryšį tarp kintamųjų užrašant „R“ formulės sąsajos pavidalu: regresijos_modelis &lt;- lm(Volume ~ Girth + Height, data = trees) 21.4.6 Modelio suvestinė Suvestinėje pažiūrime į: Determinacijos koeficientą \\(R^2\\) (standartinį „Multiple R-squared“ arba koreguotąjį „Adjusted R-squared“). Kuo šis rodiklis arčiau 1, tuo modelis tinkamesnis; ANOVA testo p reikšmę („p-value“). Jei ANOVA \\(p &lt; 0.05\\), vadinasi lygtyje yra bent vienas reikalingas regresorius. Jei \\(p \\ge 0.05\\) vadinasi regresoriai ne pakankamai gerai aprašo priklausomą kintamąjį ir regresijos lygtis yra bevertė; regresijos koeficientus („Coefficients“ → „Estimate“) ir jiems atlikto t-testo p reikšmes („Coefficients“ → „Pr(&gt;|t|)“). Jei regresoriaus \\(p &lt; 0.05\\), galima manyti, jog regresorius yra reikalingas. Kitu atveju – regresorius šalintinas iš lygties; Suvestinė atliekama šitaip: summary(regresijos_modelis) ## ## Call: ## lm(formula = Volume ~ Girth + Height, data = trees) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.4065 -2.6493 -0.2876 2.2003 8.4847 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -57.9877 8.6382 -6.713 0.000000275 *** ## Girth 4.7082 0.2643 17.816 &lt; 2e-16 *** ## Height 0.3393 0.1302 2.607 0.0145 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.882 on 28 degrees of freedom ## Multiple R-squared: 0.948, Adjusted R-squared: 0.9442 ## F-statistic: 255 on 2 and 28 DF, p-value: &lt; 2.2e-16 21.4.7 Standartizuotieji koeficientai Apskaičiuojame standartizuotuosius beta koeficientus, pagal kurių absoliučiąją vertę sprendžiame, kurie kintamieji yra įtakingiausi (daro didžiausią įtaką priklausomo kintamojo vertėms): library(lm.beta) lm.beta(regresijos_modelis) ## ## Call: ## lm(formula = Volume ~ Girth + Height, data = trees) ## ## Standardized Coefficients:: ## (Intercept) Girth Height ## 0.0000000 0.8988319 0.1315042 Šiuo atveju regresorius „Girth“ yra įtakingesnis už „Height“. summary(lm.beta(regresijos_modelis)) ## ## Call: ## lm(formula = Volume ~ Girth + Height, data = trees) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.4065 -2.6493 -0.2876 2.2003 8.4847 ## ## Coefficients: ## Estimate Standardized Std. Error t value Pr(&gt;|t|) ## (Intercept) -57.9877 0.0000 8.6382 -6.713 0.000000275 *** ## Girth 4.7082 0.8988 0.2643 17.816 &lt; 2e-16 *** ## Height 0.3393 0.1315 0.1302 2.607 0.0145 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.882 on 28 degrees of freedom ## Multiple R-squared: 0.948, Adjusted R-squared: 0.9442 ## F-statistic: 255 on 2 and 28 DF, p-value: &lt; 2.2e-16 21.4.8 Liekamųjų paklaidų analizė Liekamosios modelio paklaidos (įprastai žymimos \\(\\varepsilon\\)) gali būti vadinamos tiesiog paklaidomis arba likučiais (angl. „residuals“). Pagal jas tikrinamos kelios tiesinės regresinės analizės prielaidos. 1. Išskirčių paieška Bonferroni išskirčių testas regresinei analizei. Jei išskirčių nėra, testo Bonferroni būdu koreguota \\(p\\) reikšmė (Bonferonni p) \\(p \\ge 0.05\\) (arba \\(p =\\) NA): outlierTest(regresijos_modelis) ## No Studentized residuals with Bonferonni p &lt; 0.05 ## Largest |rstudent|: ## rstudent unadjusted p-value Bonferonni p ## 31 2.765603 0.010122 0.31377 Kuko mato (angl. „Cook’s distance“) įverčiai ir jų grafikai. Kuko mato reikšmės kiekvienam kintamajam turi būti \\(&lt; 1\\). Jei Kuko mato reikšmė konkrečiam taškui didesnė už vienetą, taškas laikomas išskirtimi. Pirmame – liekamųjų paklaidų pagal įtakos indeksą (angl., „Residuals vs. Leverage Plot“) – grafike x ašyje – įtakos indeksas (angl. „leverage“), y ašyje – standartizuotosios paklaidos. Grafiko zonos, kuriose Kuko mato vertė lygi 0.5 bei 1.0, žymimos raudonais punktyrais. Jei taškas nėra išskirtis, jis nepatenka į zoną, kurioje Kuko mato reikšmė didesnė už 1 (šiame grafike šios srities net ir nesimato, pavaizduota tik 0.5 riba): plot(regresijos_modelis, which = 5) Antrame (papildomame) – Kuko mato pagal stebėjimo (taško) indeksą – grafike x ašyje atidedamas taško (duomenų eilutės) numeris, o y ašyje – Kuko mato vertė. Taip galime matyti, kurios taškus galima įtarti kaip išskirtis. plot(regresijos_modelis, which = 4) 2. Paklaidų normalumo prielaidos tikrinimas Kvantilių palyginimo (qq) grafikas standartizuotoms paklaidoms. Jei paklaidos išsidėstyto „ant“ tiesės (arba kuo arčiau jos), prielaida nėra pažeidžiama: plot(regresijos_modelis, which = 2) Shapiro-Wilk kriterijus paklaidų pasiskirstymo normalumui tikrinti. Prielaida nepažeidžiama, jei \\(p \\ge 0.05\\): shapiro.test(residuals(regresijos_modelis)) ## ## Shapiro-Wilk normality test ## ## data: residuals(regresijos_modelis) ## W = 0.97431, p-value = 0.644 3. Prielaidos, kad paklaidų vidurkis lygus nuliui, tikrinimas Liekamųjų paklaidų pagal prognozuojamas reikšmes grafikas (angl. „Residuals vs. Fitted Plot“). Jei prielaida nepažeidžiama, jame likučiai turi barstytis apie nulį. plot(regresijos_modelis, which = 1) Stjudento t kriterijus, kuriuo tikrinama hipotezė, kad paklaidų likučių vidurkis lygus nuliui. Prielaida nepažeidžiama, jei \\(p \\ge 0.05\\): t.test(residuals(regresijos_modelis)) ## ## One Sample t-test ## ## data: residuals(regresijos_modelis) ## t = 2.2336e-16, df = 30, p-value = 1 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## -1.375587 1.375587 ## sample estimates: ## mean of x ## 1.504453e-16 p-value = 1 &gt; 0,05, tad prielaida nepažeidžiama. 4. Homoskedastiškumo prielaidos tikrinimas Homoskedartiškumo (arba lygių dispersijų prielaida) prielaida – tai prielaida, kad kiekvienai fiksuotai X reikšmei liekamųjų paklaidų dispersijos turėtų būti vienodos. (Terminai „homoskedastiškas“/„heteroskedastiškas“ būdingi regresinei analizei). Liekamųjų paklaidų grafikai kiekvienam regresoriui (daliniai įtakos grafikai, angl. „Added-Variable Plots“), kuriuose, esant homoskedastiškumui (lygioms dispersijoms), taškai aplink regresijos tiesę turėtų išsidėstyti tolygiai, tarsi sudarydami juostelę. Jei išsibarstymas platėja, siaurėja ar kitokiu būdu kinta, galima įtarti, kad prielaida pažeidžiama. # car::avPlots(regresijos_modelis, main = &quot;Liekamųjų paklaidų grafikai&quot;) car::avPlots(regresijos_modelis) Kitas grafinio vertinimo būdas – sklaidos-padėties grafikas (angl. „Scale-Location Plot“). Tai vienas iš standartizuotųjų prognozuojamų reikšmių – liekamųjų paklaidų grafiko variantų. Jame likučiai turėtų išsidėstyti tolygiai ir lygiagrečiai x ašiai. Jei matoma tendencija, kad grafiko taškai kyla arba leidžiasi (t. y., nėra lygiagretūs x ašiai) arba jų išsibarstymas siaurėja, platėja arba kitaip kinta, galima numanyti esant heteroskedastiškumą: plot(regresijos_modelis, which = 3) Breusch-Pagan kriterijus, atliekamas prognozuojamų reikšmių (angl. „fitted values“) atžvilgiu. Stjudentizuota kriterijaus versija (tokią pagal nutylėjimą atlieka žemiau pateikta R funkcija) yra robastiškesnė (labiau atspari nukrypimams). Tikrinamos hipotezės: \\(H_0\\): dispersijos lygios (homoskedastiški duomenys) \\(H_1\\): dispersijos skiriasi (heteroskedastiški duomenys) Jei kriterijaus \\(p \\ge 0.05\\), tada homoskedastiškumo prielaida tenkinama: lmtest::bptest( Volume ~ Girth + Height, data = trees, varformula = ~ fitted.values(regresijos_modelis)) ## ## studentized Breusch-Pagan test ## ## data: Volume ~ Girth + Height ## BP = 2.2763, df = 1, p-value = 0.1314 Rezultatai rodo, kad skirtumas tarp dispersijų statistiškai nereikšmingas, tad homoskedastiškumo prielaida tenkinama. 21.4.9 Tikrinimas dėl multikolinearumo Multikolinearumo problemos nėra, kai kiekvienam kintamajam VIF &lt; 4 (VIF – dispersijos mažėjimo daugiklis, angl., „variance inflation factor“): car::vif(regresijos_modelis) ## Girth Height ## 1.36921 1.36921 21.4.10 Prognozavimas Kai modelis sudarytas ir patikrintas, jį galima naudoti prognozavimui. Šiuo atveju sudarėme modelį, kuriuo pagal medžio apimtį ir aukštį prognozuojamas vidutinis medienos tūris. Prognozuoti galime naudodamiesi funkcija predict(). Pavyzdys, kai prognozė (kiekvienai duomenų eilutei) atliekama naudojant pradinius duomenis: medienos_turis &lt;- predict(regresijos_modelis, newdata = trees) medienos_turis ## 1 2 3 4 5 6 7 ## 4.837660 4.553852 4.816981 15.874115 19.869008 21.018327 16.192688 ## 8 9 10 11 12 13 14 ## 19.245949 21.413021 20.187581 22.015402 21.468465 21.468465 20.506154 ## 15 16 17 18 19 20 21 ## 23.954110 27.852203 31.583966 33.806482 30.600978 28.697035 34.388184 ## 22 23 24 25 26 27 28 ## 36.008319 35.385260 41.768998 44.877702 50.942868 52.223751 53.428513 ## 29 30 31 ## 53.899329 53.899329 68.515305 Aišku, modelį sudarėme tam, kad galėtume prognozuoti naujas reikšmes. Tam mums reikalingi nauji duomenys, kuriuose būtinai turi būti regresorių pavadinimai (mūsų atveju „Girth“ ir „Height“). Pavyzdžiai, kai prognozė atliekama naudojant naujus duomenis (nurodomos naujos regresorių, pagal kuriuos buvo modeliuota, reikšmės): medienos_turis2 &lt;- predict( regresijos_modelis, newdata = data.frame(Girth = 20, Height = 75)) medienos_turis2 ## 1 ## 61.61939 nauji_duomenys &lt;- data.table::fread(&quot; Girth Height 11 60 17 60 20 60 20 75 &quot;) medienos_turis3 &lt;- predict( regresijos_modelis, newdata = nauji_duomenys) medienos_turis3 ## 1 2 3 4 ## 14.15718 42.40614 56.53063 61.61939 Prognozuotąsias vertes įdedame į duomenų lentelę šalia regresorių: nauji_duomenys$`Spėjamas_vidutinis_medienos_tūris` &lt;- medienos_turis3 nauji_duomenys ## Girth Height Spėjamas_vidutinis_medienos_tūris ## 1: 11 60 14.15718 ## 2: 17 60 42.40614 ## 3: 20 60 56.53063 ## 4: 20 75 61.61939 Prisiminkite, kad regresijos lygtimi modeliuojamos tik vidutinės priklausomo kintamojo reikšmės. "],
["zodynai.html", "A Žodynėliai A.1 Kompiuterijos terminai A.2 Programavimo ir matematikos terminai (anglų-lietuvių) A.3 Simbolių pavadinimai (anglų-lietuvių) A.4 Statistikos terminai (aiškinamasis žodynas) A.5 Statistikos terminai (anglų-lietuvių) Klausimai ir komentarai", " A Žodynėliai A.1 Kompiuterijos terminai Anglų–lietuvių kalbų kompiuterijos žodynas Enciklopedinis kompiuterijos žodynas A.2 Programavimo ir matematikos terminai (anglų-lietuvių) A.3 Simbolių pavadinimai (anglų-lietuvių) A.4 Statistikos terminai (aiškinamasis žodynas) Žodynėlis (statistikos terminai) A.5 Statistikos terminai (anglų-lietuvių) Klausimai ir komentarai Please enable JavaScript to view the comments powered by Disqus. "],
["priedas-r-sesijos-info.html", "B R sesijos informacija", " B R sesijos informacija „R“ ir šios programos paketų versijos bei kita techninė darbo programa „R“ sesijos informacija šios svetainės kūrimo metu. devtools::session_info() ## - Session info ----------------------------------------------------------------------------------- ## setting value ## version R version 3.5.3 (2019-03-11) ## os Windows 10 x64 ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate Lithuanian_Lithuania.1257 ## ctype Lithuanian_Lithuania.1257 ## tz Europe/Helsinki ## date 2019-05-04 ## ## - Packages --------------------------------------------------------------------------------------- ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 3.5.3) ## backports 1.1.4 2019-04-10 [1] CRAN (R 3.5.3) ## bookdown 0.9.2 2019-04-26 [1] Github (rstudio/bookdown@5998ab4) ## callr 3.2.0 2019-03-15 [1] CRAN (R 3.5.3) ## cli 1.1.0 2019-03-19 [1] CRAN (R 3.5.3) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 3.5.3) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 3.5.1) ## desc 1.2.0 2018-05-01 [1] CRAN (R 3.5.0) ## devtools 2.0.2 2019-04-08 [1] CRAN (R 3.5.3) ## digest 0.6.18 2018-10-10 [1] CRAN (R 3.5.1) ## dplyr 0.8.0.1 2019-02-15 [1] CRAN (R 3.5.2) ## evaluate 0.13 2019-02-12 [1] CRAN (R 3.5.2) ## fs 1.3.0 2019-05-02 [1] CRAN (R 3.5.3) ## ggplot2 3.1.1.9000 2019-05-01 [1] Github (tidyverse/ggplot2@3b69172) ## glue 1.3.1 2019-03-12 [1] CRAN (R 3.5.3) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 3.5.3) ## htmltools 0.3.6 2017-04-28 [1] CRAN (R 3.5.0) ## knitr 1.22.8 2019-04-26 [1] Github (yihui/knitr@00ffce2) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 3.5.3) ## magrittr 1.5 2014-11-22 [1] CRAN (R 3.5.0) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 3.5.0) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 3.5.0) ## pillar 1.3.1 2018-12-15 [1] CRAN (R 3.5.1) ## pkgbuild 1.0.3 2019-03-20 [1] CRAN (R 3.5.3) ## pkgconfig 2.0.2 2018-08-16 [1] CRAN (R 3.5.1) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 3.5.1) ## prettyunits 1.0.2 2015-07-13 [1] CRAN (R 3.5.0) ## processx 3.3.0 2019-03-10 [1] CRAN (R 3.5.2) ## ps 1.3.0 2018-12-21 [1] CRAN (R 3.5.2) ## purrr 0.3.2 2019-03-15 [1] CRAN (R 3.5.3) ## R6 2.4.0 2019-02-14 [1] CRAN (R 3.5.2) ## Rcpp 1.0.1 2019-03-17 [1] CRAN (R 3.5.3) ## remotes 2.0.4 2019-04-10 [1] CRAN (R 3.5.3) ## rlang 0.3.4 2019-04-07 [1] CRAN (R 3.5.3) ## rmarkdown 1.12.6 2019-04-26 [1] Github (rstudio/rmarkdown@9923811) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.5.0) ## scales 1.0.0 2018-08-09 [1] CRAN (R 3.5.1) ## sessioninfo 1.1.1.9000 2018-12-01 [1] Github (r-lib/sessioninfo@ac8fcc1) ## stringi 1.4.3 2019-03-12 [1] CRAN (R 3.5.3) ## stringr 1.4.0 2019-02-10 [1] CRAN (R 3.5.2) ## testthat 2.1.1 2019-04-23 [1] CRAN (R 3.5.3) ## tibble 2.1.1 2019-03-16 [1] CRAN (R 3.5.3) ## tidyselect 0.2.5 2018-10-11 [1] CRAN (R 3.5.1) ## usethis 1.5.0 2019-04-07 [1] CRAN (R 3.5.3) ## withr 2.1.2 2018-03-15 [1] CRAN (R 3.5.1) ## xfun 0.6 2019-04-02 [1] CRAN (R 3.5.3) ## yaml 2.2.0 2018-07-25 [1] CRAN (R 3.5.1) ## ## [1] D:/Dokumentai/R/win-library/3.5 ## [2] C:/Program Files/R/R-3.5.3/library "],
["saltiniai.html", "Informacijos šaltiniai", " Informacijos šaltiniai "]
]
